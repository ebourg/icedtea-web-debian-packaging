diff -r ba6519dd5e79 -r 263e152a6084 ChangeLog
--- a/ChangeLog	Fri Sep 11 14:57:30 2015 +0200
+++ b/ChangeLog	Tue Jan 26 15:18:30 2016 +0100
@@ -1,3 +1,447 @@
+2016-01-26  Jiri Vanek <jvanek@redhat.com>
+
+	Messages for Invalid JDK dialog improved a bit.
+	* netx/net/sourceforge/jnlp/resources/Messages.properties:
+	* netx/net/sourceforge/jnlp/resources/Messages_cs.properties:
+	* netx/net/sourceforge/jnlp/resources/Messages_de.properties:
+	* netx/net/sourceforge/jnlp/resources/Messages_pl.properties:
+
+2016-01-26  Jiri Vanek <jvanek@redhat.com>
+
+	Revisited some jnlp_href tests. 
+	* tests/reproducers/signed/ClasspathManifestTest/testcases/ClasspathManifestTest.java:
+	explained why localtests on "." are passing (removed KnownToFail) and added
+	(correctly failing) tests in various dirs
+	* tests/reproducers/signed/CodeBaseManifestEntrySignedMatching/testcases/CodeBaseManifestEntrySignedMatching.java:
+	used diamond
+	* tests/reproducers/signed/CodeBaseManifestEntrySignedMatching/testcases/CodeBaseManifestEntrySignedNotMatching.java:
+	same
+	* tests/reproducers/signed/CodeBaseManifestEntrySignedMatching/testcases/CodeBaseManifestEntryUnsignedMatching.java:
+	same
+	* tests/reproducers/signed/CodeBaseManifestEntrySignedMatching/testcases/CodeBaseManifestEntryUnsignedNotMatching.java:
+	same
+	* tests/reproducers/simple/SingleInstanceServiceTest/testcases/SingleInstanceTest.java:
+	fixed midori incompatible tests
+
+2016-01-25  Jiri Vanek <jvanek@redhat.com>
+
+	Fixed various cosmetic NPEs when codebase is null (+tests)
+	* NEWS: mentioned PR2489
+	* netx/net/sourceforge/jnlp/JNLPFile.java: added method getNotNullProbalbeCodeBase
+	workaround cases when codebase is null (for various output reasons)
+	* netx/net/sourceforge/jnlp/PluginBridge.java: using getNotNullProbalbeCodeBase
+	when fixing codebase during generation of jnlp stub.
+	* netx/net/sourceforge/jnlp/SecurityDesc.java: same for generating uri for policies
+	record
+	* netx/net/sourceforge/jnlp/runtime/JNLPClassLoader.java: (manageExternalJars)
+	same for ref string comparsion
+	* netx/net/sourceforge/jnlp/security/SecurityDialog.java: same for visible form of
+	codebase
+	* netx/net/sourceforge/jnlp/security/SecurityDialogs.java: same
+	* netx/net/sourceforge/jnlp/security/appletextendedsecurity/UnsignedAppletTrustConfirmation.java:
+	same
+	* netx/net/sourceforge/jnlp/security/dialogs/TemporaryPermissionsButton.java:
+	same
+	* netx/net/sourceforge/jnlp/security/dialogs/apptrustwarningpanel/PartiallySignedAppTrustWarningPanel.java:
+	same
+	* netx/net/sourceforge/jnlp/util/UrlUtils.java: (normalizeUrlAndStripParams) and
+	(removeFileName) when input is null, return null.
+	* tests/junit-runner/JunitLikeXmlOutputListener.java: now supports hg commits
+	* tests/reproducers/signed/CodebasesAttsSigned/srcs/CodebasesAttsSigned.java:
+	test printing "hardocded" id and paramet to know jar and calling jnlp/html source
+	* tests/reproducers/signed/CodebasesAttsSigned/resources/CodebasesAttsSigned.html.in:
+	resouirce capable of substitue id param, codebase, jar and htmlHref
+	* tests/reproducers/signed/CodebasesAttsSigned/resources/CodebasesAttsSignedApp.jnlp.in:
+	same
+	* tests/reproducers/signed/CodebasesAttsSigned/resources/CodebasesAttsSignedApplet.jnlp.in:
+	same
+	* tests/reproducers/signed/CodebasesAttsSigned/resources/CodebasesAttsSignedJnlpHref.html.in:
+	same
+	* tests/reproducers/signed/CodebasesAttsSigned/testcases/CodebasesAttsSignedDialogsTest1.java:
+	Test testing various dialogues of signed app. Including tests for corrupted signature
+	* tests/reproducers/simple/CodebasesAtts/srcs/CodebasesAtts.java: same as CodebasesAttsSigned
+	but not signed
+	* tests/reproducers/simple/CodebasesAtts/resources/CodebasesAtts.html.in:
+	same as signed ones
+	* tests/reproducers/simple/CodebasesAtts/resources/CodebasesAttsApp.jnlp.in:
+	same
+	* tests/reproducers/simple/CodebasesAtts/resources/CodebasesAttsApplet.jnlp.in:
+	same
+	* tests/reproducers/simple/CodebasesAtts/resources/CodebasesAttsJnlpHref.html.in:
+	same
+	* tests/reproducers/simple/CodebasesAtts/testcases/CodebasesAttsDialogsTest1.java:
+	same
+	* tests/reproducers/simple/CodebasesAtts/testcases/CodebasesAttsNoDialogsTest1.java:
+	* tests/reproducers/simple/CodebasesAtts/testcases/CodebasesAttsNoDialogsTest2.java:
+	* tests/reproducers/simple/CodebasesAtts/testcases/CodebasesAttsNoDialogsTest3.java:
+	Again tests for various substituted values
+	* tests/test-extensions/net/sourceforge/jnlp/ServerAccess.java:
+	added stubs to create independent instance upon tmp folder and execute browser
+	upon url.
+	* tests/test-extensions/net/sourceforge/jnlp/browsertesting/browsers/firefox/FirefoxProfilesOperator.java:
+	(copyFile) moved to autocloseable
+	* tests/test-extensions/net/sourceforge/jnlp/closinglisteners/AutoErrorClosingListener.java:
+	fixed to not to close on rhino exception
+	* tests/test-extensions/net/sourceforge/jnlp/closinglisteners/StringBasedClosingListener.java:
+	condition made protected
+
+2016-01-19  Jiri Vanek <jvanek@redhat.com>
+
+	When tagsoup is missing, parsing errors are more informative
+	* acinclude.m4: when building without tagsoup, more verbose warning is printed
+	* netx/net/sourceforge/jnlp/GuiLaunchHandler.java: (launchError) is now noting
+	that BasicExceptionDialog will be shown.
+	* netx/net/sourceforge/jnlp/MalformedXMLParser.java: Now react on NoClassDefFoundError
+	by returning original stream.
+	* netx/net/sourceforge/jnlp/ParseException.java: Stores information about
+	parsers loading, and add this info to ParseException message.
+	* netx/net/sourceforge/jnlp/Parser.java: (getRootNode) logic retrieving parser
+	class extracted to separate method getParserInstance
+	* netx/net/sourceforge/jnlp/resources/Messages.properties: added family of TAGSOUP
+	for messages about its state
+	* netx/net/sourceforge/jnlp/runtime/JNLPRuntime.java: (exit) now waits for 
+	BasicExceptionDialog.
+	* netx/net/sourceforge/jnlp/runtime/html/AppletExtractor.java: (cleanStreamIfPossible)
+	now uses Parser.getParserInstance ratehr then its own.
+	* netx/net/sourceforge/jnlp/util/BasicExceptionDialog.java: Is now capable of
+	publishing number of shown instances.
+
+2016-01-14  Jiri Vanek <jvanek@redhat.com>
+            Fridrich Strba  <fridrich.strba@suse.com>
+
+	Adapted to change in package of HexDumpEncoder (1.8 sun.misc.HexDumpEncoder, 
+	1.9 sun.security.util.HexDumpEncoder)
+	* acinclude.m4: added new macro IT_CHECK_FOR_HEXDUMPENCODER, which tries both
+	locations of HexDumpEncoder
+	* configure.ac: now uses IT_CHECK_FOR_HEXDUMPENCODER instead of 
+	IT_CHECK_FOR_CLASS(SUN_MISC_HEXDUMPENCODER, [sun.misc.HexDumpEncoder])
+	* netx/net/sourceforge/jnlp/security/dialogs/CertsInfoPane.java: added imports
+	to both import sun.misc.*; and import sun.security.util.*;
+
+2016-01-14  Jiri Vanek <jvanek@redhat.com>
+
+	Added GenericName to desktop files
+	* itweb-settings.desktop.in:
+	* javaws.desktop.in:
+	* policyeditor.desktop.in:
+
+2016-01-14  Jiri Vanek <jvanek@redhat.com>
+
+	Included maven artifacts and appstream metadata
+	* .Makefile: (clean-local) and (.PHONY) now depends on clean-metadata.
+	($(abs_top_builddir)/metadata) new target, copy metadata-in to metadata and
+	replace name, vendor and version check-meatdata, new stand alone target, checks
+	correctness of poms and xmls in	metadata folder. (stamps/netx-dist.stamp) now
+	depends on $(abs_top_builddir)/metadata. clean-metadata, new target, removes
+	built metadata folder
+	* metadata.in/icedtea-web-javaws.appdata.xml: appstream metadata for javaws
+	* metadata.in/icedtea-web.metainfo.xml: appstream metadata for plugin
+	* metadata.in/icedtea-web-plugin.pom: pom for plugin.jar
+	* metadata.in/icedtea-web.pom: pom for netx jar
+
+2016-01-14  Jiri Vanek  <jvanek@redhat.com>
+
+	Vendor desktop entry replaced by X-Vendor
+	* ChangeLog: fixed date
+	* netx/net/sourceforge/jnlp/util/XDesktopEntry.java: if vendor is present in jnlp
+	instead of Vendor X-Vendor entry is generated to desktop file
+
+2016-01-14  Jiri Vanek  <jvanek@redhat.com>
+
+	Added reprodcuer for NoClassDeffFoundError behavior
+	* tests/reproducers/custom/NoClassDeff/srcs/NoClassDeff.java: small app including
+	inner class, which is missing in deployed jar. Then calling this class on demand
+	* tests/reproducers/custom/NoClassDeff/srcs/.Makefile: responsible for removing
+	the compiled inner class before jarring
+	* tests/reproducers/custom/NoClassDeff/testcases/NoClassDeffTest.java:
+	testing behavior when ClassNotFound/NoClassDefFound  is thrown in various stages
+	* tests/reproducers/custom/NoClassDeff/resources/NoClassDeff.html.in:
+	* tests/reproducers/custom/NoClassDeff/resources/NoClassDeffApp.jnlp.in:
+	* tests/reproducers/custom/NoClassDeff/resources/NoClassDeffApplet.jnlp.in:
+	* tests/reproducers/custom/NoClassDeff/resources/NoClassDeffJnlpHref.html.in:
+	templates to launch app with instruction when to call LostClass and how to deal with it
+
+2016-01-07  David Cantrell <david.l.cantrell@gmail.com>
+            Jiri Vanek  <jvanek@redhat.com>
+            Andrew John Hughes  <ahughes@redhat.com>
+
+	Remove bash-specifics from top level Makefile.a
+	* Makefile.am: (generate-docs.stamp) double == in test function replaced by single =
+	(stamps/netx-html-gen.stamp) call to plain bash replaced by ${SHELL}
+	* NEWS: mentioned PR2669
+
+2016-01-07  Tiago Stürmer Daitx <tdaitx@gmail.com>
+            Jiri Vanek  <jvanek@redhat.com>
+
+	Resolves an issue where, if IcedTea's call to NPN_GetValueForURL fails,
+	IcedTea-Web attempts to send uninitialized memory garbage across a pipe, which
+	(usually) results in an error. At this point, IcedTea gives up, but does not
+	inform Firefox that it has done so, and unless dom.ipc.plugins.asyncInit is
+	true, this causes Firefox's UI to lock up in addition to the Java component failing to load.
+	* plugin/icedteanp/IcedTeaNPPlugin.cc: (onsume_plugin_message) initialize len
+	and proxy_info. (get_proxy_info) returns correct message if 
+	browser_functions.getvalueforurl returns error
+	* NEWS: mentioned PR2714
+
+2016-01-07  Jiri Vanek  <jvanek@redhat.com>
+
+	Codebase resolution of jnlp-href is now aligned with oracle plugin
+	* netx/net/sourceforge/jnlp/PluginBridge.java: When jnlp href is used, codebase
+	is forced to become codebase of jnlp
+	* netx/net/sourceforge/jnlp/SecurityDesc.java: When file.getCodeBase() is null
+	then instead of NPE, codebase of file.fileLocation is used
+	* netx/net/sourceforge/jnlp/security/appletextendedsecurity/UnsignedAppletTrustConfirmation.java:
+	stripFile and ensureSlashTail moved to UrlUtils
+	* netx/net/sourceforge/jnlp/util/UrlUtils.java: 	stripFile and ensureSlashTail
+	moved from UnsignedAppletTrustConfirmation
+	* tests/netx/unit/net/sourceforge/jnlp/PluginBridgeTest.java: removed empty lines
+	* tests/netx/unit/net/sourceforge/jnlp/security/appletextendedsecurity/UnsignedAppletTrustConfirmationTest.java:
+	adapted to moved methods
+	* tests/netx/unit/net/sourceforge/jnlp/util/UrlUtilsTest.java: added more tests
+	to removeFileName and enabled accidentlay disabled  getHostAndPortTest and
+	getPortTest
+	* tests/netx/unit/net/sourceforge/jnlp/runtime/CodeBaseClassLoaderTest.java:
+	ensured manifest attributes are off for this test
+	* tests/netx/unit/net/sourceforge/jnlp/ParserMalformedXml.java: fixed bom tests
+	to use proper classloader
+
+2016-01-07  Jiri Vanek  <jvanek@redhat.com>
+
+	BOM character now dont cause error
+	* netx/net/sourceforge/nanoxml/XMLElement.java: duplicated whitespace recognition
+	code moved to isRegularWhiteSpace.  First call to scanWhitespace repalced by
+	call to scanLeadingWhitespace. New field BOM introduced. (scanWhitespace)
+	made private, and uses isRegularWhiteSpace. (scanLeadingWhitespace) new method,
+	same as scanWhitespacebut also skipps BOM and marks it.
+	* tests/netx/unit/net/sourceforge/jnlp/ParserMalformedXml.java: Added tests to
+	issue
+	* tests/netx/unit/net/sourceforge/jnlp/templates/EFBBBF.jnlp: new file. jnlp
+	file starting with bom.
+	* NEWS: mentioned PR2690
+
+2016-01-06  James Le Cuirot <chewi@gentoo.org>
+
+	Fixed typo in javadoc generation
+	* Makefile.am: (stamps/netx-docs.stamp) (	_OPTS)->(JAVADOC_OPTS)
+
+2016-01-06  Jiri Vanek  <jvanek@redhat.com>
+
+	Fixed PR2591 - IcedTea-Web request resources twice for meta informations and
+	causes ClientAbortException on tomcat in conjunction with JnlpDownloadServlet 
+	* NEWS: mentioned PR2591
+	* netx/net/sourceforge/jnlp/cache/ResourceDownloader.java: CodeWithRedirect renamed
+	to UrlRequestResult and now cached also lastModified and length if available.
+	(initializeFromURL) now expects UrlRequestResult instead of URL, (findBestUrl)
+	now returns in same manner
+	(SimpleTest1CountRequests) now passes
+	* tests/netx/unit/net/sourceforge/jnlp/cache/ResourceDownloaderTest.java: adapted
+	to ResourceDownloader.
+
+2016-01-06  Jiri Vanek  <jvanek@redhat.com>
+
+	Added redirection tests
+	* tests/test-extensions/net/sourceforge/jnlp/ServerLauncher.java:  Enhanced so
+	it can redirect requests to another instance. Enhanced to be able to count requests
+	* tests/test-extensions/net/sourceforge/jnlp/TinyHttpdImpl.java: same
+	* tests/reproducers/simple/simpletest1/testcases/SimpleTest1Test.java: small
+	refactoring to reuse checking methods
+	* tests/reproducers/simple/simpletest1/testcases/SimpleTest1CountRequests.java:
+	Added FAILING tests for 2591 - counting ITW requests to test server
+	* tests/reproducers/simple/simpletest1/testcases/SimpleTestDefaultRedirects.java:
+	added set of tests to test behavior under various redirect codes
+
+2016-01-05  Jiri Vanek  <jvanek@redhat.com>
+
+	* NEWS: mentioned PR2779
+	* html-gen.sh: now don't generate mercurial changesets' links if .hg is missing
+
+2015-12-23  Jiri Vanek  <jvanek@redhat.com>
+
+	Small properties parser in C (plugin) now unescapes \= \\ \: \t \n and \r correctly
+	* plugin/icedteanp/IcedTeaParseProperties.cc: (get_property_value) now unescape
+	known escape sequences by calling IcedTeaPluginUtilities::unescape
+	* plugin/icedteanp/IcedTeaPluginUtils.cc: implemented (unescape) which unescape
+	known properties escape sequences
+	* plugin/icedteanp/IcedTeaPluginUtils.h: declared (unescape)
+	* tests/cpp-unit-tests/IcedTeaParsePropertiesTest.cc: ((get_property_value))
+	added testcase which verifies unnescape of escaped sequences from  get_property_value 
+	* tests/cpp-unit-tests/IcedTeaPluginUtilsTest.cc: added family of (unescape) tests
+	* /tests/reproducers/signed/CheckPluginParams: reproducer to verify if params
+	from -D in deployment.plugin.jvm.arguments get correctly unescaped during its
+	way up to users program.
+
+2015-11-26  Jiri Vanek  <jvanek@redhat.com>
+
+	Main-class attribute get trimmed by default
+	* netx/net/sourceforge/jnlp/Parser.java: declared MAINCLASS to keep main-class
+	constant, declared anyWhiteSpace regex to determine whitespaces. All possible fields
+	made final, hardcoded main-class replaced bu constant. New method getOptionalMainClass
+	wrapper around getMainClass but consuming exception. getMainClass, new method
+	reading MAINCLASS from node and handling it. cleanMainClassAttribute, new method
+	trim value and do checks to die or warn if necessary.
+	* tests/netx/unit/net/sourceforge/jnlp/ParserTest.java: added tests for top level
+	behavior on various spaced main-classes. Now extends NoStdOutErrTest
+	* NEWS: mentioned main-class handling change
+
+2015-11-12  Jiri Vanek  <jvanek@redhat.com>
+
+	Added parser to read ico images
+	* netx/net/sourceforge/jnlp/controlpanel/desktopintegrationeditor/JListUtils.java:
+	When reading images, also ico is attempted to parse.
+	* netx/net/sourceforge/jnlp/tools/ico/impl/IcoException.java: new class,
+	exception for special cases in ico parsing	
+	* netx/net/sourceforge/jnlp/tools/ico/impl/IcoHeader.java: new class, parser
+	and holder of parsed information of header of ico file
+	* netx/net/sourceforge/jnlp/tools/ico/impl/IcoHeaderEntry.java: new class,
+	parser and holder of parsed information of headers of individual images stored
+	in header of ico file
+	* netx/net/sourceforge/jnlp/tools/ico/impl/ImageInputStreamIco.java: parser
+	of icon files from ImageInputStream
+
+2015-11-12  Jiri Vanek  <jvanek@redhat.com>
+
+	Added desktop integration dialog
+	* netx/net/sourceforge/jnlp/controlpanel/DesktopShortcutPanel.java: added linux-only
+	button to sow FreeDesktopIntegrationEditorFrame 
+	* netx/net/sourceforge/jnlp/controlpanel/desktopintegrationeditor/Blinker.java:
+	new class, blink colors on selected component
+	* netx/net/sourceforge/jnlp/controlpanel/desktopintegrationeditor/FreeDesktopIntegrationEditorFrame.java:
+	new class, window to allow managing generated icons, jnlpfiles and shortcuts
+	* netx/net/sourceforge/jnlp/controlpanel/desktopintegrationeditor/JListUtils.java:
+	new class, provides models, extensions, renderers and listeners for FreeDesktopIntegrationEditorFrame
+	* netx/net/sourceforge/jnlp/controlpanel/desktopintegrationeditor/Panels.java:
+	new class, provides various encapsulated parts of FreeDesktopIntegrationEditorFrame
+	* netx/net/sourceforge/jnlp/controlpanel/desktopintegrationeditor/PreviewSelectionJTextPane.java:
+	new class, impelmetation of preview for FreeDesktopIntegrationEditorFrame
+	* netx/net/sourceforge/jnlp/resources/Messages.properties: added  Control 
+	Panel - desktop integration manager DIM family
+	* netx/net/sourceforge/jnlp/security/dialogs/SecurityDialogPanel.java: htmlWrap
+	made public
+	* netx/net/sourceforge/jnlp/util/XDesktopEntry.java: findFreedesktopOrgDesktopPathCatch
+	made public
+	* netx/net/sourceforge/jnlp/util/logging/ConsoleOutputPaneModel.java:  replacing of chars by html
+	entities extracted to new method escapeHtmlForJTextPane
+	* tests/netx/unit/net/sourceforge/jnlp/security/dialogs/apptrustwarningpanel/AppTrustWarningPanelTest.java:
+	htmlwrap moved to use SecurityDialogPanel's implementation
+
+2015-11-12  Jiri Vanek  <jvanek@redhat.com>
+
+	fixed build and runtime with jdk9
+	* netx/net/sourceforge/jnlp/NetxPanel.java: (init) setting doInit to true
+	replaced by call to setDoInitIfExists
+	* netx/sun/applet/AppletViewerPanelAccess.java: added new function of
+	(setDoInitIfExists) which sets doInit if exists
+
+2015-10-27  Jiri Vanek  <jvanek@redhat.com>
+
+	itweb-settings, debugging panel made aware about legacy log and client apps log
+	* netx/net/sourceforge/jnlp/controlpanel/DebuggingPanel.java: added checboxes for
+	KEY_ENABLE_APPLICATION_LOGGING_TOFILE and KEY_ENABLE_LEGACY_LOGBASEDFILELOG
+	Cusotm config directory place was a bit repacked to be more compact and more useful.
+	* netx/net/sourceforge/jnlp/resources/Messages.properties: added labels
+	and tooltips for new checkboxes
+
+2015-10-27  Jiri Vanek  <jvanek@redhat.com>
+
+	Added and by default disabled logging to files for client applications.
+	* netx/net/sourceforge/jnlp/config/Defaults.java: KEY_ENABLE_APPLICATION_LOGGING_TOFILE
+	added and set by default to false
+	* netx/net/sourceforge/jnlp/config/DeploymentConfiguration.java: declared
+	KEY_ENABLE_APPLICATION_LOGGING_TOFILE
+	* netx/net/sourceforge/jnlp/util/logging/FileLog.java: next to createFileLog
+	can now does also createAppFileLog
+	* netx/net/sourceforge/jnlp/util/logging/LogConfig.java: made aware of
+	KEY_ENABLE_APPLICATION_LOGGING_TOFILE
+	* netx/net/sourceforge/jnlp/util/logging/OutputController.java: if logging 
+	to file is enabled and logging to file for client applications is enabled
+	then output of client app is sent also to special file. Added new singleton of
+	AppFileLogHolder to keep instance of file log for client app. proceedHeader
+	extracted as separate method to be reused.
+
+2015-10-15  Jiri Vanek  <jvanek@redhat.com>
+
+	Added to enable and write logs directly to	file without java.util.logging
+	* netx/net/sourceforge/jnlp/config/Defaults.java: (defaults) added new key
+	KEY_ENABLE_LEGACY_LOGBASEDFILELOG, by default true
+	* netx/net/sourceforge/jnlp/config/DeploymentConfiguration.java: defined
+	KEY_ENABLE_LEGACY_LOGBASEDFILELOG for deployment.log.file.legacylog
+	* netx/net/sourceforge/jnlp/runtime/JNLPRuntime.java: (exit) catch new exception
+	* netx/net/sourceforge/jnlp/util/logging/FileLog.java: removed all logic.
+	Now serve onl as factory provider of FileLog implementation
+	* netx/net/sourceforge/jnlp/util/logging/LogConfig.java: fixed indentation, made 
+	aware about LOGBASEDFILELOG
+	* netx/net/sourceforge/jnlp/util/logging/OutputController.java: adapted to
+	autocloseable SingleStreamLogger
+	* netx/net/sourceforge/jnlp/util/logging/SingleStreamLogger.java: this interface
+	now extends	AutoCloseable
+	* netx/net/sourceforge/jnlp/util/logging/filelogs/LogBasedFileLog.java: copy 
+	of original FileLog. Writing to file is done via java.util.loggiing engine
+	* netx/net/sourceforge/jnlp/util/logging/filelogs/WriterBasedFileLog.java:
+	writing to file is done by simple buffered writer
+	* tests/netx/unit/net/sourceforge/jnlp/util/logging/FileLogTest.java: now tests
+	LogBasedFileLog
+	* tests/netx/unit/net/sourceforge/jnlp/util/logging/OutputControllerTest.java:
+	now tests WriterBasedFileLog instead of FileLog
+	* tests/netx/unit/net/sourceforge/jnlp/util/logging/WriterBasedFileLogTest.java:
+	Similar set of tests as are in FileLogTest but for WriterBasedFileLog
+
+2015-10-15  Jiri Vanek  <jvanek@redhat.com>
+
+	Broken file logging now dont crash itw
+	* NEWS: mentioned
+	* netx/net/sourceforge/jnlp/util/logging/FileLog.java: Instance now acquired
+	from factory method  (createFileLog) which defaults new SingleStreamLoggerImpl
+	if normal initialization fails.
+	* netx/net/sourceforge/jnlp/util/logging/OutputController.java: (getFileLog)
+	uses new factory method rather then constructor.
+	* netx/net/sourceforge/jnlp/util/logging/SingleStreamLogger.java: enforces
+	now also close method
+	* netx/net/sourceforge/jnlp/util/logging/PrintStreamLogger.java: impl close
+	* netx/net/sourceforge/jnlp/util/logging/UnixSystemLog.java: impl close
+	* netx/net/sourceforge/jnlp/util/logging/WinSystemLog.java: impl close
+	* netx/net/sourceforge/jnlp/util/logging/headers/PluginMessage.java: removed
+	unused import
+
+2015-10-07  Jiri Vanek  <jvanek@redhat.com>
+
+	All connection restrictions now consider also port
+	* NEWS: mentioned restriction about ports
+	* netx/net/sourceforge/jnlp/SecurityDesc.java: downloadHost redeclared to URL
+	and made final. All set/gets adapted
+	* netx/net/sourceforge/jnlp/Parser.java: (base) passes url to SecurityDesc
+	* netx/net/sourceforge/jnlp/PluginBridge.java: (PluginBridge) same
+	* netx/net/sourceforge/jnlp/runtime/JNLPClassLoader.java: same
+	* plugin/icedteanp/java/sun/applet/PluginAppletViewer.java: (getApplet)
+	(getApplets) same
+	* netx/net/sourceforge/jnlp/util/UrlUtils.java:	added methods sanitizePort and
+	getPort, which always returns port. If no port goes in, default port is going
+	out. Added getHostAndPort which returns host also with port.
+	* tests/netx/unit/net/sourceforge/jnlp/SecurityDescTest.java: adapted to new api
+	* tests/netx/unit/net/sourceforge/jnlp/util/UrlUtilsTest.java: tested new methods
+	
+2015-10-02  Jiri Vanek  <jvanek@redhat.com>
+
+	Fixed possible segfault during files on and debug on
+	* plugin/icedteanp/IcedTeaNPPlugin.cc: added file_logs_initiated initiated as
+	false. plugin_file_log initiated to NULL.
+	* plugin/icedteanp/IcedTeaNPPlugin.h: made aware about extern file_logs_initiated
+	* plugin/icedteanp/IcedTeaPluginUtils.h: (initialize_debug) set file_logs_initiated
+	to true after initFileLog finishes. (PLUGIN_DEBUG) and (PLUGIN_ERROR) logs to
+	file only when enabled and initiated.
+
+2015-09-22  Jiri Vanek  <jvanek@redhat.com>
+
+	fixed two doclint errors
+	* netx/net/sourceforge/jnlp/security/package-info.java: diagram put inside code annotation 
+	* netx/net/sourceforge/jnlp/security/policyeditor/PolicyEditorPermissions.java:
+	(getTitle) added javadoc to prevent auto-generated return with (doclint) invalid character
+
+2015-09-11  Jiri Vanek  <jvanek@redhat.com>
+
+	Post-release changes 
+	* NEWS: added 1.6.2 section
+	* configure.ac: (AC_INIT) bumped to 1.6.2pre
+
 2015-09-10  Jiri Vanek  <jvanek@redhat.com>
 
 	Pre-release tuning
diff -r ba6519dd5e79 -r 263e152a6084 Makefile.am
--- a/Makefile.am	Fri Sep 11 14:57:30 2015 +0200
+++ b/Makefile.am	Tue Jan 26 15:18:30 2016 +0100
@@ -220,7 +220,7 @@
 export PLUGIN_VERSION = IcedTea-Web $(FULL_VERSION)
 
 export EXTRA_DIST = $(top_srcdir)/netx $(top_srcdir)/plugin javaws.png javaws.desktop.in policyeditor.desktop.in icedteaweb-completion \
- itweb-settings.desktop.in launcher $(top_srcdir)/tests html-gen.sh NEW_LINE_IFS
+ itweb-settings.desktop.in launcher $(top_srcdir)/tests html-gen.sh NEW_LINE_IFS $(top_srcdir)/metadata.in
 
 # reproducers `D`shortcuts
 export DTEST_SERVER=-Dtest.server.dir=$(REPRODUCERS_TESTS_SERVER_DEPLOYDIR)
@@ -263,7 +263,7 @@
 check-local: $(RHINO_TESTS) $(JUNIT_TESTS)
 
 clean-local: clean-netx clean-plugin clean-liveconnect \
- clean-native-ecj clean-launchers clean-desktop-files clean-docs clean-generated-docs clean-tests clean-bootstrap-directory
+ clean-native-ecj clean-launchers clean-desktop-files clean-docs clean-generated-docs clean-metadata clean-tests clean-bootstrap-directory
 	if [ -e stamps ] ; then \
 	  rmdir stamps ; \
 	fi
@@ -271,7 +271,7 @@
 .PHONY: clean-IcedTeaPlugin clean-add-netx clean-add-netx-debug clean-add-plugin clean-add-plugin-debug \
  clean-bootstrap-directory clean-native-ecj clean-desktop-files clean-netx-docs clean-docs clean-plugin-docs clean-generated-docs \
  clean-tests check-local clean-launchers stamps/check-pac-functions.stamp stamps/run-netx-unit-tests.stamp clean-netx-tests \
- clean-junit-runner clean-netx-unit-tests
+ clean-junit-runner clean-netx-unit-tests clean-metadata 
 
 install-exec-local:
 	${mkinstalldirs} $(DESTDIR)$(bindir) $(DESTDIR)$(datadir)/$(PACKAGE_NAME)/ $(DESTDIR)$(libdir) $(ICONS_DEST_DIR)
@@ -508,6 +508,37 @@
 	sed -i '/RhinoBasedPacEvaluator/ d' $@
 endif
 
+$(abs_top_builddir)/metadata: $(top_srcdir)/metadata.in
+	mkdir -p $(abs_top_builddir)/metadata-work ; \
+	METAFILES=`ls $(top_srcdir)/metadata.in` ; \
+	for F in $$METAFILES ; do \
+	  cat $(top_srcdir)/metadata.in/$$F | sed "s;%{name};$(PACKAGE_NAME);g" |  sed "s;%{version};$(FULL_VERSION);g" > $(abs_top_builddir)/metadata-work/$$F ; \
+	done ; \
+	mv $(abs_top_builddir)/metadata-work $(abs_top_builddir)/metadata ;
+
+check-metadata: $(abs_top_builddir)/metadata
+	xmllint --noout $(abs_top_builddir)/metadata/* ; \
+	if [ $$? -eq 0 ] ; then \
+	  echo "Passed: well formed" ; \
+	else \
+	  echo "FAILED: well formed" ; \
+	fi ; \
+	xmllint --noout --schema http://maven.apache.org/xsd/maven-4.0.0.xsd $(abs_top_builddir)/metadata/*.pom ; \
+	if [ $$? -eq 0 ] ; then \
+	  echo "Passed: valid poms" ; \
+	else \
+	  echo "FAILED: valid poms" ; \
+	fi ; \
+	appstream-util validate $(abs_top_builddir)/metadata/*.appdata.xml  $(abs_top_builddir)/metadata/*.metainfo.xml ; \
+	if [ $$? -eq 0 ] ; then \
+	  echo "Passed: valid software descriptors" ; \
+	else \
+	  echo "FAILED: valid software descriptors" ; \
+	fi ;
+# very strange results:
+# appstreamcli  validate $(abs_top_builddir)/metadata/*.appdata.xml  $(abs_top_builddir)/metadata/*.metainfo.xml
+	
+
 stamps/generate-docs.stamp: stamps/netx.stamp
 	mkdir -p "$(DOCS_DIR)" ; \
 	HTML_DOCS_TARGET_DIR="$(DOCS_DIR)/html"  ; \
@@ -531,7 +562,7 @@
 	  $$TP_COMMAND html "$$HTML_DOCS_TARGET_DIR/$$ID" $$TP_TAIL ; \
 	  mkdir "$$PLAIN_DOCS_TARGET_DIR/$$ID" ; \
 	  $$TP_COMMAND plain "$$PLAIN_DOCS_TARGET_DIR/$$ID" 160 $$TP_TAIL; \
-	  if [ $$ID == "en" ] ; then \
+	  if [ $$ID = "en" ] ; then \
 	    MAN_DESC="$$MAN_DOCS_TARGET_DIR/man1" ; \
 	  else \
 	    MAN_DESC="$$MAN_DOCS_TARGET_DIR/$$ID/man1" ; \
@@ -549,7 +580,7 @@
 	mkdir -p html-gen; \
 	cp AUTHORS NEWS COPYING ChangeLog html-gen/; \
 	export HTML_GEN_DEBUG=true; \
-	bash html-gen.sh 40; \
+	${SHELL} html-gen.sh 40; \
 	unset HTML_GEN_DEBUG)
 	${INSTALL_DATA} $(NETX_SRCDIR)/../html-gen/*.html $(NETX_RESOURCE_DIR)
 	rm -r $(NETX_SRCDIR)/../html-gen/
@@ -575,7 +606,7 @@
 	mkdir -p stamps
 	touch $@
 
-stamps/netx-dist.stamp: stamps/netx.stamp $(abs_top_builddir)/netx.manifest stamps/generate-docs.stamp
+stamps/netx-dist.stamp: stamps/netx.stamp $(abs_top_builddir)/netx.manifest stamps/generate-docs.stamp $(abs_top_builddir)/metadata
 	(cd $(NETX_DIR) ; \
 	 mkdir -p lib ; \
 	 $(SYSTEM_JDK_DIR)/bin/jar cfm lib/classes.jar \
@@ -652,7 +683,7 @@
 
 stamps/netx-docs.stamp:
 if ENABLE_DOCS
-	$(SYSTEM_JDK_DIR)/bin/javadoc $(JAVADOC_MEM_OPTS) $(	_OPTS) \
+	$(SYSTEM_JDK_DIR)/bin/javadoc $(JAVADOC_MEM_OPTS) $(JAVADOC_OPTS) \
 	 -d ${abs_top_builddir}/docs/netx -sourcepath $(NETX_SRCDIR) \
 	 -doctitle 'IcedTea-Web: NetX API Specification' \
 	 -windowtitle 'IcedTea-Web: NetX ' \
@@ -691,6 +722,9 @@
 	rm -f stamps/generate-docs.stamp
 
 
+clean-metadata:
+	rm -rf $(abs_top_builddir)/metadata
+
 # check
 # ==========================
 
diff -r ba6519dd5e79 -r 263e152a6084 NEWS
--- a/NEWS	Fri Sep 11 14:57:30 2015 +0200
+++ b/NEWS	Tue Jan 26 15:18:30 2016 +0100
@@ -8,6 +8,21 @@
 
 CVE-XXXX-YYYY: http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=XXXX-YYYY
 
+New in release 1.6.2 (YYYY-MM-DD):
+* all connection restrictions now consider also port
+* PR2779: html-gen.sh: Don't try to call hg if .hg directory isn't present
+* PR2591 - IcedTea-Web request resources twice for meta informations and causes ClientAbortException on tomcat in conjunction with JnlpDownloadServlet
+* PR2690 - Can't run BOM into JNLP file
+* PR2669 - remove bash-specific syntax from top level Makefile.am
+* PR2489 - various NPEs when codebase is null
+* NetX
+  - main-class attribute trimmed by default
+  - in strict mode, main-class attribute checked for invalid characters
+* Plugin
+  - RH1273691 - Escaped equals signs in deployment.properties not un-escaped when used
+  - PR2746 - IcedTea-Web Plugin 1.6.1: net.sourceforge.jnlp.LaunchException 
+  - PR2714 - IcedTea-Web plugin sends uninitialized memory garbage across a pipe when NPN_GetValueForURL call fails
+
 New in release 1.6.1 (2015-09-11):
 * Enabled Entry-Point attribute check
 * permissions sandbox and signed app and unsigned app with permissions all-permissions now run in sandbox instead of not at all.
@@ -20,6 +35,7 @@
 * RH1231441 Unable to read the text of the buttons of the security dialogue
 * Fixed RH1233697 icedtea-web: applet origin spoofing
 * Fixed RH1233667 icedtea-web: unexpected permanent authorization of unsigned applets
+* fixed fatal impact of initialization error of FileLog
 * MissingALACAdialog made available also for unsigned applications (but ignoring actual manifest value) and fixed
 * NetX
   - fixed issues with -html shortcuts
diff -r ba6519dd5e79 -r 263e152a6084 acinclude.m4
--- a/acinclude.m4	Fri Sep 11 14:57:30 2015 +0200
+++ b/acinclude.m4	Tue Jan 26 15:18:30 2016 +0100
@@ -446,6 +446,12 @@
     done
   fi
   AC_MSG_RESULT(${TAGSOUP_JAR})
+  if test -z "${TAGSOUP_JAR}"; then
+    AC_MSG_RESULT(***********************************************)
+    AC_MSG_RESULT(*  Warning you are building without tagsoup   *)
+    AC_MSG_RESULT(* Some jnlps and most htmls will be malformed *)
+    AC_MSG_RESULT(***********************************************)
+  fi
   AC_SUBST(TAGSOUP_JAR)
   AM_CONDITIONAL([HAVE_TAGSOUP], [test x$TAGSOUP_JAR != xno -a x$TAGSOUP_JAR != x ])
 ])
@@ -500,6 +506,55 @@
 AC_PROVIDE([$0])dnl
 ])
 
+dnl Macro to check for a Java class HexDumpEncoder
+AC_DEFUN([IT_CHECK_FOR_HEXDUMPENCODER],[
+AC_REQUIRE([IT_FIND_JAVAC])
+AC_REQUIRE([IT_FIND_JAVA])
+AC_CACHE_CHECK([if HexDumpEncoder is available], it_cv_HEXDUMPENCODER, [
+CLASS=sun/applet/Test.java
+BYTECODE=$(echo $CLASS|sed 's#\.java##')
+mkdir -p tmp.$$/$(dirname $CLASS)
+cd tmp.$$
+cat << \EOF > $CLASS
+[/* [#]line __oline__ "configure" */
+package sun.applet;
+
+import sun.misc.*;
+import sun.security.util.*;
+
+public class Test
+{
+  public static void main(String[] args)
+    throws Exception
+  {
+    try {
+      System.out.println(Class.forName("sun.misc.HexDumpEncoder"));
+    } catch (ClassNotFoundException e) {
+      System.out.println(Class.forName("sun.security.util.HexDumpEncoder"));
+    }
+  }
+}
+]
+EOF
+if $JAVAC -cp . $JAVACFLAGS -nowarn $CLASS >&AS_MESSAGE_LOG_FD 2>&1; then
+  if $JAVA -classpath . $BYTECODE >&AS_MESSAGE_LOG_FD 2>&1; then
+      it_cv_HEXDUMPENCODER=yes;
+  else
+      it_cv_HEXDUMPENCODER=no;
+  fi
+else
+  it_cv_HEXDUMPENCODER=no;
+fi
+])
+rm -f $CLASS *.class
+cd ..
+# should be rmdir but has to be rm -rf due to sun.applet usage
+rm -rf tmp.$$
+if test x"${it_cv_HEXDUMPENCODER}" = "xno"; then
+   AC_MSG_ERROR([HexDumpEncoder not found.])
+fi
+])
+
 AC_DEFUN_ONCE([IT_CHECK_FOR_MERCURIAL],
 [
   AC_PATH_TOOL([HG],[hg])
diff -r ba6519dd5e79 -r 263e152a6084 configure.ac
--- a/configure.ac	Fri Sep 11 14:57:30 2015 +0200
+++ b/configure.ac	Tue Jan 26 15:18:30 2016 +0100
@@ -1,4 +1,4 @@
-AC_INIT([icedtea-web],[1.6.1],[distro-pkg-dev@openjdk.java.net], [icedtea-web], [http://icedtea.classpath.org/wiki/IcedTea-Web])
+AC_INIT([icedtea-web],[1.6.2pre],[distro-pkg-dev@openjdk.java.net], [icedtea-web], [http://icedtea.classpath.org/wiki/IcedTea-Web])
 AM_INIT_AUTOMAKE([1.9 tar-pax foreign])
 AC_CONFIG_FILES([Makefile netx.manifest])
 AM_MAINTAINER_MODE([enable])
@@ -68,7 +68,7 @@
 
 dnl PR46074 (gcc) - Missing java.net cookie code required by IcedTea plugin
 dnl IT563 - NetX uses sun.security code
-dnl IT605 - NetX depends on sun.misc.HexDumpEncoder
+dnl IT605 - NetX depends on sun.misc HexDumpEncoder or sun.security.util.HexDumpEncoder
 dnl IT570 - NetX depends on sun.applet.AppletViewPanel
 dnl IT571 - NetX depends on com.sun.net.ssl.internal.ssl.X509ExtendedTrustManager.java
 dnl IT573 - Plugin depends on sun.awt,X11.XEmbeddedFrame.java
@@ -83,7 +83,7 @@
 IT_CHECK_FOR_CLASS(SUN_SECURITY_UTIL_SECURITYCONSTANTS, [sun.security.util.SecurityConstants])
 IT_CHECK_FOR_CLASS(SUN_SECURITY_UTIL_HOSTNAMECHECKER, [sun.security.util.HostnameChecker])
 IT_CHECK_FOR_CLASS(SUN_SECURITY_X509_X500NAME, [sun.security.x509.X500Name])
-IT_CHECK_FOR_CLASS(SUN_MISC_HEXDUMPENCODER, [sun.misc.HexDumpEncoder])
+IT_CHECK_FOR_HEXDUMPENCODER
 IT_CHECK_FOR_CLASS(SUN_SECURITY_VALIDATOR_VALIDATOREXCEPTION, [sun.security.validator.ValidatorException])
 IT_CHECK_FOR_CLASS(COM_SUN_NET_SSL_INTERNAL_SSL_X509EXTENDEDTRUSTMANAGER,
 	[com.sun.net.ssl.internal.ssl.X509ExtendedTrustManager])
diff -r ba6519dd5e79 -r 263e152a6084 html-gen.sh
--- a/html-gen.sh	Fri Sep 11 14:57:30 2015 +0200
+++ b/html-gen.sh	Tue Jan 26 15:18:30 2016 +0100
@@ -67,13 +67,23 @@
 if [ -z "$CHANGESETS" ] || [ "$CHANGESETS" -lt 0 ]; then CHANGESETS=10; fi
 
 NEWS_ITEMS=2
-REPO_URL="$(hg paths default | sed -r 's/.*icedtea.classpath.org\/(.*)/\1/')"
+
+if [ -d .hg ]; then
+    REPO_URL="$(hg paths default | sed -r 's/.*icedtea.classpath.org\/(.*)/\1/')"
+else
+    unset REPO_URL
+fi
 
 start_time="$(date +%s.%N)"
 
+if [ ! -e html-gen ]; then
+	echo "No html-gen directory, exiting. See Makefile.am for usage"
+	exit 1
+fi
+
 cd html-gen
 
-print_debug "Generating HTML content for javaws -about for $REPO_URL. $CHANGESETS changesets, $NEWS_ITEMS news items"
+print_debug "Generating HTML content for javaws -about${REPO_URL:+ for }$REPO_URL. $CHANGESETS changesets, $NEWS_ITEMS news items"
 print_debug "Starting sed substitutions"
 for FILE in NEWS AUTHORS COPYING ChangeLog
 do
@@ -99,7 +109,9 @@
 sed -i '5i <br><img src="jamIcon.jpg" alt="Jam Icon" width="87" height="84"><br><br>' AUTHORS.html
 echo "</center>" >> AUTHORS.html
 
-REVS=(`hg log -l"$CHANGESETS" | grep 'changeset:' | cut -d: -f3 | tr '\n' ' '`)
+if [ -n "${REPO_URL}" ]; then
+    REVS=(`hg log -l"$CHANGESETS" | grep 'changeset:' | cut -d: -f3 | tr '\n' ' '`)
+fi
 
 print_debug "Done. Starting formatting (bolding, mailto and hyperlink creation)"
 
@@ -132,9 +144,11 @@
             if [[ "$LINE" =~ $date_regex* ]] # Matches line starting with eg 2013-07-01
             then
                 html_space="\&ensp;\&ensp;"
-                REV="${REVS["$COUNTER"]}"
-                # Turn the date into a hyperlink for the revision this changelog entry describes
-                LINE=$(echo "$LINE" | sed -r "s|($date_regex)($html_space.*$html_space.*)|<a href=http://icedtea.classpath.org/$REPO_URL/rev/$REV>\1</a>\2|")
+                if [ -n "${REPO_URL}" ]; then
+                    REV="${REVS["$COUNTER"]}"
+                    # Turn the date into a hyperlink for the revision this changelog entry describes
+                    LINE=$(echo "$LINE" | sed -r "s|($date_regex)($html_space.*$html_space.*)|<a href=http://icedtea.classpath.org/$REPO_URL/rev/$REV>\1</a>\2|")
+                fi
                 COUNTER="$(( COUNTER + 1 ))"
             fi
             if [ "$COUNTER" -gt "$CHANGESETS" ] # Cut to ten changesets
diff -r ba6519dd5e79 -r 263e152a6084 itweb-settings.desktop.in
--- a/itweb-settings.desktop.in	Fri Sep 11 14:57:30 2015 +0200
+++ b/itweb-settings.desktop.in	Tue Jan 26 15:18:30 2016 +0100
@@ -3,6 +3,7 @@
 Name[de]=IcedTea-Web Systemsteuerung
 Name[pl]=Panel sterowania IcedTea-Web
 Name[cs]=Ovládací panel IcedTea-Web
+GenericName=Control Panel
 Comment=Configure IcedTea-Web (javaws and plugin)
 Comment[de]=Konfiguriert IcedTea-Web (javaws und Plug-in)
 Comment[pl]=Konfiguruj IcedTea-Web (javaws i wtyczkę)
diff -r ba6519dd5e79 -r 263e152a6084 javaws.desktop.in
--- a/javaws.desktop.in	Fri Sep 11 14:57:30 2015 +0200
+++ b/javaws.desktop.in	Tue Jan 26 15:18:30 2016 +0100
@@ -1,5 +1,6 @@
 [Desktop Entry]
 Name=IcedTea Web Start
+GenericName=Java Web Start
 Comment=IcedTea Application Launcher
 Exec=PATH_TO_JAVAWS %f
 Icon=javaws
diff -r ba6519dd5e79 -r 263e152a6084 metadata.in/icedtea-web-javaws.appdata.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/metadata.in/icedtea-web-javaws.appdata.xml	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,47 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<component type="desktop">
+<!-- <component> -->
+  <id>javaws.desktop</id>
+  <name>%{name}</name>
+  <name>Java</name>
+  <summary>Javaws implementation from OpenJDK</summary>
+<!--   <provides>
+​    <library>netx.jar</library>
+​    <library>plugin.jar</library>
+​    <binary>javaws</binary>
+​    <binary>itweb-settings</binary>
+​    <binary>policyeditor</binary>
+​  </provides>
+-->
+  <description>
+<p>
+Free java implementation of jnlp launching protocol.
+</p><p>
+Originally based on NetX,but now bringing many improvements compared to proprietary implementations.
+</p><p>
+Powerful debug console, internal appletviewer, safe run-in-sandbox option, extendable "remember me" options and custom policy editor.
+</p><p>
+It have also  possibility to turn all security off and just enjoy legacy web (on your own risk). All via simple itweb-settings gui.
+</p>
+   </description>
+  <url type="homepage">http://icedtea.classpath.org/wiki/IcedTea-Web</url>
+  <metadata_license>CC0-1.0</metadata_license>
+  <updatecontact>distro-pkg-dev@openjdk.java.net</updatecontact>
+  <mimetypes>
+​    <mimetype>text/jnlp</mimetype>
+  </mimetypes>
+ <screenshots>
+  <screenshot type="default"> 
+   <image>http://icedtea.classpath.org/wiki/images/Javaws_splash.png</image>
+   <caption>Itw self describing splash screen</caption>
+  </screenshot>
+  <screenshot>
+   <image>http://icedtea.classpath.org/wiki/images/Fullysigned.png</image>
+   <caption>Run in sandbox dialog</caption>
+  </screenshot>
+  <screenshot>
+   <image>http://icedtea.classpath.org/wiki/images/Policyeditor-in-use.png</image>
+   <caption>Simplified view of policy editor</caption>
+  </screenshot>
+ </screenshots>
+</component>
diff -r ba6519dd5e79 -r 263e152a6084 metadata.in/icedtea-web-plugin.pom
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/metadata.in/icedtea-web-plugin.pom	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,9 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
+                      http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+    <groupId>sun.applet</groupId>
+    <artifactId>%{name}-plugin</artifactId>
+    <version>%{version}</version>
+</project>
diff -r ba6519dd5e79 -r 263e152a6084 metadata.in/icedtea-web.metainfo.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/metadata.in/icedtea-web.metainfo.xml	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<component type="addon">
+  <id>%{name}</id>
+  <extends>epiphany.desktop</extends>
+  <extends>firefox.desktop</extends>
+  <extends>midori.desktop</extends>
+  <name>Java</name>
+  <summary>Browser plug-in implementation from OpenJDK. This plugin is running java applets</summary>
+  <url type="homepage">http://icedtea.classpath.org/wiki/IcedTea-Web</url>
+  <metadata_license>CC0-1.0</metadata_license>
+  <updatecontact>distro-pkg-dev@openjdk.java.net</updatecontact>
+</component>
diff -r ba6519dd5e79 -r 263e152a6084 metadata.in/icedtea-web.pom
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/metadata.in/icedtea-web.pom	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,9 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
+                      http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+    <groupId>net.sourceforge.jnlp</groupId>
+    <artifactId>%{name}</artifactId>
+    <version>%{version}</version>
+</project>
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/GuiLaunchHandler.java
--- a/netx/net/sourceforge/jnlp/GuiLaunchHandler.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/GuiLaunchHandler.java	Tue Jan 26 15:18:30 2016 +0100
@@ -69,6 +69,7 @@
 
     @Override
     public void launchError(final LaunchException exception) {
+        BasicExceptionDialog.willBeShown();
         SwingUtilities.invokeLater(new Runnable() {
             @Override
             public void run() {
@@ -102,6 +103,7 @@
     }
 
     @Override
+    @SuppressWarnings("empty-statement")
     public void launchInitialized(final JNLPFile file) {
 
         int preferredWidth = 500;
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/JNLPFile.java
--- a/netx/net/sourceforge/jnlp/JNLPFile.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/JNLPFile.java	Tue Jan 26 15:18:30 2016 +0100
@@ -37,6 +37,7 @@
 import net.sourceforge.jnlp.runtime.JNLPClassLoader;
 import net.sourceforge.jnlp.runtime.JNLPRuntime;
 import net.sourceforge.jnlp.util.ClasspathMatcher;
+import net.sourceforge.jnlp.util.UrlUtils;
 import net.sourceforge.jnlp.util.logging.OutputController;
 
 /**
@@ -419,6 +420,25 @@
     public URL getCodeBase() {
         return codeBase;
     }
+    
+    /**
+     * It is not recommended to use this method for internals of itw - use normal getCodeBase rather, as null is expected always except toString calls.
+     *
+     * If you are not sure, use getCodeBase and chek null as you need. See that this method is used mostly for xtendedAppletSecuriyty dialogs.
+     * 
+     * @return the codebase URL for the JNLP file  or url of location of calling file (jnlp, hreffed jnlp, or directly html)
+     */
+    public URL getNotNullProbalbeCodeBase() {
+        if (getCodeBase()!=null){
+            return getCodeBase();
+        }
+        try {
+            return UrlUtils.removeFileName(getSourceLocation());
+        } catch (Exception ex) {
+            OutputController.getLogger().log(ex);
+        }
+        return getSourceLocation();
+    }
 
     /**
      * @return the information section of the JNLP file as viewed
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/MalformedXMLParser.java
--- a/netx/net/sourceforge/jnlp/MalformedXMLParser.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/MalformedXMLParser.java	Tue Jan 26 15:18:30 2016 +0100
@@ -111,10 +111,12 @@
 
             reader.parse(s);
             return new ByteArrayInputStream(out.toByteArray());
-        } catch (SAXException e) {
-            throw new ParseException(R("PBadXML"), e);
-        } catch (IOException e) {
-            throw new ParseException(R("PBadXML"), e);
+        } catch (SAXException | IOException e1) {
+            throw new ParseException(R("PBadXML"), e1);
+        } catch (NoClassDefFoundError  e2) {
+            OutputController.getLogger().log(e2);
+            ParseException.setUsed(null);
+            return original;
         }
 
     }
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/NetxPanel.java
--- a/netx/net/sourceforge/jnlp/NetxPanel.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/NetxPanel.java	Tue Jan 26 15:18:30 2016 +0100
@@ -204,7 +204,7 @@
     }
 
     public void init(PluginBridge bridge) throws LaunchException {
-        doInit = true;
+        setDoInitIfExists(true);
         dispatchAppletEvent(APPLET_LOADING, null);
         status = APPLET_LOAD;
 
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/ParseException.java
--- a/netx/net/sourceforge/jnlp/ParseException.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/ParseException.java	Tue Jan 26 15:18:30 2016 +0100
@@ -16,6 +16,9 @@
 
 package net.sourceforge.jnlp;
 
+import net.sourceforge.jnlp.runtime.JNLPRuntime;
+import net.sourceforge.jnlp.runtime.Translator;
+
 /**
  * Thrown to indicate that an error has occurred while parsing a
  * JNLP file.
@@ -34,7 +37,7 @@
      * @param message to be shown in exception
      */
     public ParseException(String message) {
-        super(message);
+        super(getParserSettingsMessage() + message);
     }
 
     /**
@@ -44,7 +47,48 @@
      * @param cause cause of exception
      */
     public ParseException(String message, Throwable cause) {
-        super(message, cause);
+        super(getParserSettingsMessage() + message, cause);
     }  
 
+    public ParseException(Throwable cause) {
+        super(getParserSettingsMessage(), cause);
+    }
+    
+    
+    static enum UsedParsers {
+
+        MALFORMED, NORMAL
+    }
+
+    private static UsedParsers expected;
+    private static UsedParsers used;
+
+    static void setExpected(UsedParsers ex) {
+        expected = ex;
+    }
+
+    static void setUsed(UsedParsers us) {
+        used = us;
+    }
+    
+    private static String getParserSettingsMessage() {
+        final String tail = ""
+                + " "
+                + Translator.R("TAGSOUPtail")
+                + " ";
+        if (expected == UsedParsers.NORMAL && used == UsedParsers.NORMAL) {
+            //warn about xml mode
+            return Translator.R("TAGSOUPnotUsed", OptionsDefinitions.OPTIONS.XML.option)+tail;
+        }
+        if (expected == UsedParsers.MALFORMED && used != UsedParsers.MALFORMED) {
+            //warn about TagSoup
+            return Translator.R("TAGSOUPbroken") + tail;
+        }
+        if (JNLPRuntime.isDebug()) {
+            return expected + " " + used + "; ";
+        } else {
+            return "";
+        }
+    }
+
 }
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/Parser.java
--- a/netx/net/sourceforge/jnlp/Parser.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/Parser.java	Tue Jan 26 15:18:30 2016 +0100
@@ -24,6 +24,8 @@
 import java.lang.reflect.Method;
 import java.net.*;
 import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 
 import net.sourceforge.jnlp.SecurityDesc.RequestedPermissionLevel;
 import net.sourceforge.jnlp.UpdateDesc.Check;
@@ -40,6 +42,8 @@
 public final class Parser {
     
     private static String CODEBASE = "codebase";
+    private static String MAINCLASS = "main-class";
+    private static final Pattern anyWhiteSpace = Pattern.compile("\\s");
 
     // defines netx.jnlp.Node class if using Tiny XML or Nano XML
 
@@ -72,29 +76,29 @@
     // constructors
     //
     /** the file reference */
-    private JNLPFile file; // do not use (uninitialized)
+    private final JNLPFile file; // do not use (uninitialized)
 
     /** the root node */
-    private Node root;
+    private final Node root;
 
     /** the specification version */
-    private Version spec;
+    private final Version spec;
 
     /** the base URL that all hrefs are relative to */
-    private URL base;
+    private final URL base;
 
     /** the codebase URL */
     private URL codebase;
 
     /** the file URL */
-    private URL fileLocation;
+    private final URL fileLocation;
 
     /** whether to throw errors on non-fatal errors. */
-    private boolean strict; // if strict==true parses a file with no error then strict==false should also
+    private final boolean strict; // if strict==true parses a file with no error then strict==false should also
 
     /** whether to allow extensions to the JNLP specification */
-    private boolean allowExtensions; // true if extensions to JNLP spec are ok
-
+    private final boolean allowExtensions; // true if extensions to JNLP spec are ok
+    
     /**
      * Create a parser for the JNLP file. If the location
      * parameters is not null it is used as the default codebase
@@ -622,7 +626,7 @@
         }
 
         if (base != null) {
-            return new SecurityDesc(file, requestedPermissionLevel, type, base.getHost());
+            return new SecurityDesc(file, requestedPermissionLevel, type, base);
         } else {
             return new SecurityDesc(file, requestedPermissionLevel, type, null);
         }
@@ -687,7 +691,7 @@
      */
     private AppletDesc getApplet(Node node) throws ParseException {
         String name = getRequiredAttribute(node, "name", R("PUnknownApplet"));
-        String main = getRequiredAttribute(node, "main-class", null);
+        String main = getMainClass(node, true);
         URL docbase = getURL(node, "documentbase", base);
         Map<String, String> paramMap = new HashMap<>();
         int width = 0;
@@ -718,7 +722,7 @@
      * @throws ParseException if the JNLP file is invalid
      */
     private ApplicationDesc getApplication(Node node) throws ParseException {
-        String main = getAttribute(node, "main-class", null);
+        String main = getMainClass(node, false);
         List<String> argsList = new ArrayList<>();
 
         // if (main == null)
@@ -766,7 +770,7 @@
      * @return the installer descriptor.
      */
     private InstallerDesc getInstaller(Node node) {
-        String main = getAttribute(node, "main-class", null);
+        String main = getOptionalMainClass(node);
 
         return new InstallerDesc(main);
     }
@@ -1311,24 +1315,10 @@
      * @throws ParseException if the JNLP file is invalid
      */
     static Node getRootNode(InputStream input, ParserSettings settings) throws ParseException {
-        String className;
-        if (settings.isMalformedXmlAllowed()) {
-            className = MALFORMED_PARSER_CLASS;
-        } else {
-            className = NORMAL_PARSER_CLASS;
-        }
-
         try {
-            Class<?> klass;
-            try {
-                klass = Class.forName(className);
-            } catch (ClassNotFoundException e) {
-                klass = Class.forName(NORMAL_PARSER_CLASS);
-            }
-            Object instance = klass.newInstance();
-            Method m = klass.getMethod("getRootNode", InputStream.class);
-
-            return (Node) m.invoke(instance, input);
+            Object parser = getParserInstance(settings);
+            Method m = parser.getClass().getMethod("getRootNode", InputStream.class);
+            return (Node) m.invoke(parser, input);
         } catch (InvocationTargetException e) {
             if (e.getCause() instanceof ParseException) {
                 throw (ParseException)(e.getCause());
@@ -1338,5 +1328,95 @@
             throw new ParseException(R("PBadXML"), e);
         }
     }
+    
 
+     public static Object getParserInstance(ParserSettings settings) throws ClassNotFoundException, IllegalAccessException, InstantiationException {
+        String className;
+        if (settings.isMalformedXmlAllowed()) {
+            className = MALFORMED_PARSER_CLASS;
+            ParseException.setExpected(ParseException.UsedParsers.MALFORMED);
+        } else {
+            className = NORMAL_PARSER_CLASS;
+            ParseException.setExpected(ParseException.UsedParsers.NORMAL);
+        }
+
+        Class<?> klass;
+        Object instance;
+
+        try {
+            klass = Class.forName(className);
+            instance = klass.newInstance();
+            //catch both, for case that tagsoup was removed after build
+        } catch (ClassNotFoundException | NoClassDefFoundError | InstantiationException e) {
+            OutputController.getLogger().log(e);
+            klass = Class.forName(NORMAL_PARSER_CLASS);
+            instance = klass.newInstance();
+        }
+
+        switch (instance.getClass().getName()) {
+            case MALFORMED_PARSER_CLASS:
+                ParseException.setUsed(ParseException.UsedParsers.MALFORMED);
+                break;
+            case NORMAL_PARSER_CLASS:
+                ParseException.setUsed(ParseException.UsedParsers.NORMAL);
+                break;
+        }
+        return instance;
+    }
+
+  private String getOptionalMainClass(Node node) {
+        try {
+            return getMainClass(node, false);
+        } catch (ParseException ex) {
+            //only getRequiredAttribute can throw this
+            //and as there is call to getMainClass  with required false
+            //it is not going to be thrown
+            OutputController.getLogger().log(ex);
+            return null;
+        }
+    }
+
+    private String getMainClass(Node node, boolean required) throws ParseException {
+        String main;
+        if (required) {
+            main = getRequiredAttribute(node, MAINCLASS, null);
+        } else {
+            main = getAttribute(node, MAINCLASS, null);
+        }
+        return cleanMainClassAttribute(main);
+    }
+
+    private String cleanMainClassAttribute(String main) throws ParseException {
+        if (main != null) {
+            Matcher matcher = anyWhiteSpace.matcher(main);
+            boolean found = matcher.find();
+            if (found && !strict) {
+                OutputController.getLogger().log(OutputController.Level.WARNING_ALL, "Warning! main-class contains whitespace - '" + main + "'");
+                main = main.trim();
+                OutputController.getLogger().log(OutputController.Level.WARNING_ALL, "Trimmed - '" + main + "'");
+            }
+            boolean valid = true;
+            if (!Character.isJavaIdentifierStart(main.charAt(0))) {
+                valid = false;
+                OutputController.getLogger().log(OutputController.Level.MESSAGE_DEBUG, "Invlaid char in main-class: '" + main.charAt(0) + "'");
+            }
+            for (int i = 1; i < main.length(); i++) {
+                if (main.charAt(i)=='.'){
+                    //dot connects identifiers
+                    continue;
+                }
+                if (!Character.isJavaIdentifierPart(main.charAt(i))) {
+                    valid = false;
+                    OutputController.getLogger().log(OutputController.Level.MESSAGE_DEBUG, "Invlaid char in main-class: '" + main.charAt(i) + "'");
+                }
+            }
+            if (!valid) {
+                OutputController.getLogger().log(OutputController.Level.WARNING_ALL, "main-class contains invalid characters - '" + main + "'. Check with vendor.");
+                if (strict) {
+                    throw new ParseException("main-class contains invalid characters - '" + main + "'. Check with vendor. You are in strict mode. This is fatal.");
+                }
+            }
+        }
+        return main;
+    }
 }
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/PluginBridge.java
--- a/netx/net/sourceforge/jnlp/PluginBridge.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/PluginBridge.java	Tue Jan 26 15:18:30 2016 +0100
@@ -40,6 +40,7 @@
 import net.sourceforge.jnlp.cache.UpdatePolicy;
 import net.sourceforge.jnlp.runtime.JNLPRuntime;
 import net.sourceforge.jnlp.util.StreamUtils;
+import net.sourceforge.jnlp.util.UrlUtils;
 import net.sourceforge.jnlp.util.logging.OutputController;
 import net.sourceforge.jnlp.util.replacements.BASE64Decoder;
 
@@ -130,7 +131,10 @@
 
                     }.readStream();
                 } else {
-                    jnlpFile = jnlpCreator.create(jnlp, null, defaultSettings, JNLPRuntime.getDefaultUpdatePolicy(), codeBase);
+                    // see http://icedtea.classpath.org/bugzilla/show_bug.cgi?id=2746#c3
+                    URL codebaseRewriter=UrlUtils.ensureSlashTail(UrlUtils.removeFileName(jnlp));
+                    this.codeBase = codebaseRewriter;
+                    jnlpFile = jnlpCreator.create(jnlp, null, defaultSettings, JNLPRuntime.getDefaultUpdatePolicy(), codebaseRewriter);
                     debugJnlp = new StreamProvider() {
 
                         @Override
@@ -224,7 +228,7 @@
 
         if (main.endsWith(".class")) //single class file only
             security = new SecurityDesc(this, SecurityDesc.SANDBOX_PERMISSIONS,
-                                        codebase.getHost());
+                                        codebase);
         else
             security = null;
 
@@ -471,7 +475,7 @@
         } else {
             StringBuilder s = new StringBuilder();
             s.append("<?xml version='1.0' encoding='UTF-8'?>\n"
-                   + "<jnlp codebase='").append(getCodeBase().toString()).append("'>\n")
+                   + "<jnlp codebase='").append(getNotNullProbalbeCodeBase().toString()).append("'>\n")
                     .append("  <information>\n"
                           + "    <title>").append(createJnlpTitle()).append("</title>\n"
                           + "    <vendor>").append(createJnlpVendor()).append("</vendor>\n"
@@ -536,7 +540,7 @@
     }
 
      private String fixCommonIsuses(boolean needSecurity, String orig) {
-        String codebase = getCodeBase().toString();
+        String codebase = getNotNullProbalbeCodeBase().toString();
         return fixCommonIsuses(needSecurity, orig, codebase, createJnlpTitle(), createJnlpVendor());
     }
      
@@ -594,7 +598,7 @@
     private static String getAllPermissionsElement() {
         return "    <all-permissions/>\n";
     }
-    
+
     
     private abstract class StreamProvider {
 
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/SecurityDesc.java
--- a/netx/net/sourceforge/jnlp/SecurityDesc.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/SecurityDesc.java	Tue Jan 26 15:18:30 2016 +0100
@@ -22,6 +22,7 @@
 import java.net.SocketPermission;
 import java.net.URI;
 import java.net.URISyntaxException;
+import java.net.URL;
 import java.security.AllPermission;
 import java.security.CodeSource;
 import java.security.Permission;
@@ -33,6 +34,7 @@
 
 import net.sourceforge.jnlp.config.DeploymentConfiguration;
 import net.sourceforge.jnlp.runtime.JNLPRuntime;
+import net.sourceforge.jnlp.util.UrlUtils;
 import net.sourceforge.jnlp.util.logging.OutputController;
 
 /**
@@ -132,7 +134,7 @@
     private Object type;
 
     /** the download host */
-    private String downloadHost;
+    final private URL downloadHost;
 
     /** whether sandbox applications should get the show window without banner permission */
     private final boolean grantAwtPermissions;
@@ -256,7 +258,7 @@
      * @param type the type of security
      * @param downloadHost the download host (can always connect to)
      */
-    public SecurityDesc(JNLPFile file, RequestedPermissionLevel requestedPermissionLevel, Object type, String downloadHost) {
+    public SecurityDesc(JNLPFile file, RequestedPermissionLevel requestedPermissionLevel, Object type, URL downloadHost) {
         if (file == null) {
             throw new NullJnlpFileException();
         }
@@ -278,7 +280,7 @@
      * @param type the type of security
      * @param downloadHost the download host (can always connect to)
      */
-    public SecurityDesc(JNLPFile file, Object type, String downloadHost) {
+    public SecurityDesc(JNLPFile file, Object type, URL downloadHost) {
         this(file, RequestedPermissionLevel.NONE, type, downloadHost);
     }
 
@@ -375,9 +377,10 @@
             }
         }
 
-        if (downloadHost != null && downloadHost.length() > 0)
-            permissions.add(new SocketPermission(downloadHost,
-                                                 "connect, accept"));
+        if (downloadHost != null && downloadHost.getHost().length() > 0) {
+            permissions.add(new SocketPermission(UrlUtils.getHostAndPort(downloadHost),
+                    "connect, accept"));
+        }
 
         final Collection<Permission> urlPermissions = getUrlPermissions();
         for (final Permission permission : urlPermissions) {
@@ -412,7 +415,7 @@
             }
         }
         try {
-            final URI codebase = file.getCodeBase().toURI().normalize();
+            final URI codebase = file.getNotNullProbalbeCodeBase().toURI().normalize();
             final URI host = getHost(codebase);
             final String codebaseHostUriString = host.toString();
             final String urlPermissionUrlString = appendRecursiveSubdirToCodebaseHostString(codebaseHostUriString);
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/cache/ResourceDownloader.java
--- a/netx/net/sourceforge/jnlp/cache/ResourceDownloader.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/cache/ResourceDownloader.java	Tue Jan 26 15:18:30 2016 +0100
@@ -57,8 +57,8 @@
      * HttpURLConnection.HTTP_OK and null if not.
      * @throws IOException
      */
-    static CodeWithRedirect getUrlResponseCodeWithRedirectonResult(URL url, Map<String, String> requestProperties, ResourceTracker.RequestMethods requestMethod) throws IOException {
-        CodeWithRedirect result = new CodeWithRedirect();
+    static UrlRequestResult getUrlResponseCodeWithRedirectonResult(URL url, Map<String, String> requestProperties, ResourceTracker.RequestMethods requestMethod) throws IOException {
+        UrlRequestResult result = new UrlRequestResult();
         URLConnection connection = ConnectionFactory.getConnectionFactory().openConnection(url);
 
         for (Map.Entry<String, String> property : requestProperties.entrySet()) {
@@ -92,6 +92,9 @@
         }
         ConnectionFactory.getConnectionFactory().disconnect(connection);
 
+        result.lastModified = connection.getLastModified();
+        result.length = connection.getContentLengthLong();
+
         return result;
 
     }
@@ -120,7 +123,7 @@
 
     private void initializeOnlineResource() {
         try {
-            URL finalLocation = findBestUrl(resource);
+            UrlRequestResult finalLocation = findBestUrl(resource);
             if (finalLocation != null) {
                 initializeFromURL(finalLocation);
             } else {
@@ -136,18 +139,25 @@
         }
     }
 
-    private void initializeFromURL(URL location) throws IOException {
+    private void initializeFromURL(UrlRequestResult location) throws IOException {
         CacheEntry entry = new CacheEntry(resource.getLocation(), resource.getRequestVersion());
         entry.lock();
         try {
-            resource.setDownloadLocation(location);
-            URLConnection connection = ConnectionFactory.getConnectionFactory().openConnection(location); // this won't change so should be okay not-synchronized
+            resource.setDownloadLocation(location.URL);
+            URLConnection connection = ConnectionFactory.getConnectionFactory().openConnection(location.URL); // this won't change so should be okay not-synchronized
             connection.addRequestProperty("Accept-Encoding", "pack200-gzip, gzip");
 
             File localFile = CacheUtil.getCacheFile(resource.getLocation(), resource.getDownloadVersion());
-            long size = connection.getContentLengthLong();
+            Long size = location.length;
+            if (size == null) {
+                size = connection.getContentLengthLong();
+            }
+            Long lm = location.lastModified;
+            if (lm == null) {
+                lm = connection.getLastModified();
+            }
 
-            boolean current = CacheUtil.isCurrent(resource.getLocation(), resource.getRequestVersion(), connection.getLastModified()) && resource.getUpdatePolicy() != UpdatePolicy.FORCE;
+            boolean current = CacheUtil.isCurrent(resource.getLocation(), resource.getRequestVersion(), lm) && resource.getUpdatePolicy() != UpdatePolicy.FORCE;
             if (!current) {
                 if (entry.isCached()) {
                     entry.markForDelete();
@@ -168,14 +178,15 @@
                 resource.changeStatus(EnumSet.of(PRECONNECT, CONNECTING), EnumSet.of(CONNECTED, PREDOWNLOAD));
 
                 // check if up-to-date; if so set as downloaded
-                if (current)
+                if (current) {
                     resource.changeStatus(EnumSet.of(PREDOWNLOAD, DOWNLOADING), EnumSet.of(DOWNLOADED));
+                }
             }
 
             // update cache entry
             if (!current) {
-                entry.setRemoteContentLength(connection.getContentLengthLong());
-                entry.setLastModified(connection.getLastModified());
+                entry.setRemoteContentLength(size);
+                entry.setLastModified(lm);
             }
 
             entry.setLastUpdated(System.currentTimeMillis());
@@ -225,14 +236,14 @@
     }
 
     /**
-     * Returns the 'best' valid URL for the given resource.
-     * This first adjusts the file name to take into account file versioning
-     * and packing, if possible.
+     * Returns the 'best' valid URL for the given resource. This first adjusts
+     * the file name to take into account file versioning and packing, if
+     * possible.
      *
      * @param resource the resource
      * @return the best URL, or null if all failed to resolve
      */
-    protected URL findBestUrl(Resource resource) {
+    protected UrlRequestResult findBestUrl(Resource resource) {
         DownloadOptions options = resource.getDownloadOptions();
         if (options == null) {
             options = new DownloadOptions(false, false);
@@ -242,7 +253,6 @@
         OutputController.getLogger().log(OutputController.Level.ERROR_DEBUG, "Finding best URL for: " + resource.getLocation() + " : " + options.toString());
         OutputController.getLogger().log(OutputController.Level.ERROR_DEBUG, "All possible urls for "
                 + resource.toString() + " : " + urls);
-
         for (ResourceTracker.RequestMethods requestMethod : ResourceTracker.RequestMethods.getValidRequestMethods()) {
             for (int i = 0; i < urls.size(); i++) {
                 URL url = urls.get(i);
@@ -250,13 +260,13 @@
                     Map<String, String> requestProperties = new HashMap<>();
                     requestProperties.put("Accept-Encoding", "pack200-gzip, gzip");
 
-                    CodeWithRedirect response = getUrlResponseCodeWithRedirectonResult(url, requestProperties, requestMethod);
-                    if (response.shouldRedirect()){
+                    UrlRequestResult response = getUrlResponseCodeWithRedirectonResult(url, requestProperties, requestMethod);
+                    if (response.shouldRedirect()) {
                         if (response.URL == null) {
                             OutputController.getLogger().log(OutputController.Level.ERROR_DEBUG, "Although " + resource.toString() + " got redirect " + response.result + " code for " + requestMethod + " request for " + url.toExternalForm() + " the target was null. Not following");
                         } else {
-                            OutputController.getLogger().log(OutputController.Level.MESSAGE_DEBUG, "Resource " + resource.toString() + " got redirect " + response.result + " code for " + requestMethod + " request for " + url.toExternalForm() + " adding " + response.URL.toExternalForm()+" to list of possible urls");
-                            if (!JNLPRuntime.isAllowRedirect()){
+                            OutputController.getLogger().log(OutputController.Level.MESSAGE_DEBUG, "Resource " + resource.toString() + " got redirect " + response.result + " code for " + requestMethod + " request for " + url.toExternalForm() + " adding " + response.URL.toExternalForm() + " to list of possible urls");
+                            if (!JNLPRuntime.isAllowRedirect()) {
                                 throw new RedirectionException("The resource " + url.toExternalForm() + " is being redirected (" + response.result + ") to " + response.URL.toExternalForm() + ". This is disabled by default. If you wont to allow it, run javaws with -allowredirect parameter.");
                             }
                             urls.add(response.URL);
@@ -265,7 +275,11 @@
                         OutputController.getLogger().log(OutputController.Level.ERROR_DEBUG, "For " + resource.toString() + " the server returned " + response.result + " code for " + requestMethod + " request for " + url.toExternalForm());
                     } else {
                         OutputController.getLogger().log(OutputController.Level.ERROR_DEBUG, "best url for " + resource.toString() + " is " + url.toString() + " by " + requestMethod);
-                        return url; /* This is the best URL */
+                        if (response.URL == null) {
+                            response.URL = url;
+                        }
+                        return response; /* This is the best URL */
+
                     }
                 } catch (IOException e) {
                     // continue to next candidate
@@ -289,18 +303,17 @@
 
             String contentEncoding = connection.getContentEncoding();
 
-            OutputController.getLogger().log(OutputController.Level.ERROR_DEBUG, "Downloading " + downloadTo + " using " +
-                    downloadFrom + " (encoding : " + contentEncoding + ") ");
+            OutputController.getLogger().log(OutputController.Level.ERROR_DEBUG, "Downloading " + downloadTo + " using "
+                    + downloadFrom + " (encoding : " + contentEncoding + ") ");
 
-            boolean packgz = "pack200-gzip".equals(contentEncoding) ||
-                    downloadFrom.getPath().endsWith(".pack.gz");
+            boolean packgz = "pack200-gzip".equals(contentEncoding)
+                    || downloadFrom.getPath().endsWith(".pack.gz");
             boolean gzip = "gzip".equals(contentEncoding);
 
             // It's important to check packgz first. If a stream is both
             // pack200 and gz encoded, then con.getContentEncoding() could
             // return ".gz", so if we check gzip first, we would end up
             // treating a pack200 file as a jar file.
-
             if (packgz) {
                 downloadPackGzFile(resource, connection, new URL(downloadFrom + ".pack.gz"), downloadTo);
             } else if (gzip) {
@@ -380,7 +393,7 @@
                 resource.incrementTransferred(rlen);
                 out.write(buf, 0, rlen);
             }
-            
+
             in.close();
         }
     }
@@ -393,14 +406,14 @@
         try (GZIPInputStream gzInputStream = new GZIPInputStream(new FileInputStream(CacheUtil
                 .getCacheFile(compressedLocation, version)))) {
             InputStream inputStream = new BufferedInputStream(gzInputStream);
-            
+
             BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(CacheUtil
                     .getCacheFile(uncompressedLocation, version)));
-            
+
             while (-1 != (rlen = inputStream.read(buf))) {
                 outputStream.write(buf, 0, rlen);
             }
-            
+
             outputStream.close();
             inputStream.close();
         }
@@ -412,29 +425,51 @@
         try (GZIPInputStream gzInputStream = new GZIPInputStream(new FileInputStream(CacheUtil
                 .getCacheFile(compressedLocation, version)))) {
             InputStream inputStream = new BufferedInputStream(gzInputStream);
-            
+
             JarOutputStream outputStream = new JarOutputStream(new FileOutputStream(CacheUtil
                     .getCacheFile(uncompressedLocation, version)));
-            
+
             Pack200.Unpacker unpacker = Pack200.newUnpacker();
             unpacker.unpack(inputStream, outputStream);
-            
+
             outputStream.close();
             inputStream.close();
         }
     }
 
     /**
-     * Complex wrapper around return code with utility methods
-     * Default is HTTP_OK
+     * Complex wrapper around url request Contains return code (default is
+     * HTTP_OK), length and last modified
+     *
+     * The storing of redirect target is quite obvious The storing length and
+     * last modified may be not, but appearently
+     * (http://icedtea.classpath.org/bugzilla/show_bug.cgi?id=2591) the url
+     * conenction is not always chaced as expected, and so another request may
+     * be sent when length and lastmodified are checked
+     *
      */
-    private static class CodeWithRedirect {
+    static class UrlRequestResult {
 
         int result = HttpURLConnection.HTTP_OK;
         URL URL;
 
+        Long lastModified;
+        Long length;
+
+        public UrlRequestResult() {
+        }
+
+        public UrlRequestResult(URL URL) {
+            this.URL = URL;
+        }
+
+        URL getURL() {
+            return URL;
+        }
+
         /**
-         *  @return  whether the result code is redirect one. Rigth now 301-303 and 307-308
+         * @return whether the result code is redirect one. Rigth now 301-303
+         * and 307-308
          */
         public boolean shouldRedirect() {
             return (result == 301
@@ -445,11 +480,20 @@
         }
 
         /**
-         * @return  whether the return code is OK one - anything except <200,300)
+         * @return whether the return code is OK one - anything except <200,300)
          */
         public boolean isInvalid() {
             return (result < 200 || result >= 300);
         }
+
+        @Override
+        public String toString() {
+            return ""
+                    + "url: " + (URL == null ? "null" : URL.toExternalForm()) + "; "
+                    + "result:" + result + "; "
+                    + "lastModified: " + (lastModified == null ? "null" : lastModified.toString()) + "; "
+                    + "length: " + length == null ? "null" : length.toString() + "; ";
+        }
     }
 
     private static class RedirectionException extends RuntimeException {
@@ -464,5 +508,4 @@
 
     }
 
-
 }
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/config/Defaults.java
--- a/netx/net/sourceforge/jnlp/config/Defaults.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/config/Defaults.java	Tue Jan 26 15:18:30 2016 +0100
@@ -340,6 +340,16 @@
                         String.valueOf(false)
                 },
                 {
+                        DeploymentConfiguration.KEY_ENABLE_APPLICATION_LOGGING_TOFILE,
+                        BasicValueValidators.getBooleanValidator(),
+                        String.valueOf(false)
+                },
+                 {
+                        DeploymentConfiguration.KEY_ENABLE_LEGACY_LOGBASEDFILELOG,
+                        BasicValueValidators.getBooleanValidator(),
+                        String.valueOf(true)
+                },
+                {
                         DeploymentConfiguration.KEY_ENABLE_LOGGING_TOSTREAMS,
                         BasicValueValidators.getBooleanValidator(),
                         String.valueOf(true)
@@ -430,4 +440,4 @@
 
         return result;
     }
-}
\ No newline at end of file
+}
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/config/DeploymentConfiguration.java
--- a/netx/net/sourceforge/jnlp/config/DeploymentConfiguration.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/config/DeploymentConfiguration.java	Tue Jan 26 15:18:30 2016 +0100
@@ -178,6 +178,8 @@
     public static final String KEY_ENABLE_LOGGING = "deployment.log"; //same as verbose or ICEDTEAPLUGIN_DEBUG=true
     public static final String KEY_ENABLE_LOGGING_HEADERS = "deployment.log.headers"; //will add header OutputContorll.getHeader To all messages
     public static final String KEY_ENABLE_LOGGING_TOFILE = "deployment.log.file";
+    public static final String KEY_ENABLE_APPLICATION_LOGGING_TOFILE ="deployment.log.file.clientapp"; //also client app will log to its separate file
+    public static final String KEY_ENABLE_LEGACY_LOGBASEDFILELOG = "deployment.log.file.legacylog";
     public static final String KEY_ENABLE_LOGGING_TOSTREAMS = "deployment.log.stdstreams";
     public static final String KEY_ENABLE_LOGGING_TOSYSTEMLOG = "deployment.log.system";
     
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/controlpanel/DebuggingPanel.java
--- a/netx/net/sourceforge/jnlp/controlpanel/DebuggingPanel.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/controlpanel/DebuggingPanel.java	Tue Jan 26 15:18:30 2016 +0100
@@ -18,6 +18,7 @@
 
 package net.sourceforge.jnlp.controlpanel;
 
+import java.awt.BorderLayout;
 import java.awt.Component;
 import java.awt.Dimension;
 import java.awt.FlowLayout;
@@ -56,6 +57,8 @@
             DeploymentConfiguration.KEY_ENABLE_LOGGING,
             DeploymentConfiguration.KEY_ENABLE_LOGGING_HEADERS,
             DeploymentConfiguration.KEY_ENABLE_LOGGING_TOFILE,
+            DeploymentConfiguration.KEY_ENABLE_LEGACY_LOGBASEDFILELOG,
+            DeploymentConfiguration.KEY_ENABLE_APPLICATION_LOGGING_TOFILE,
             DeploymentConfiguration.KEY_ENABLE_LOGGING_TOSTREAMS,
             DeploymentConfiguration.KEY_ENABLE_LOGGING_TOSYSTEMLOG
             
@@ -76,6 +79,19 @@
 
         addComponents();
     }
+    
+    
+    private void fileLoggingAct(JCheckBox source, JCheckBox... targets) {
+        if (source.isSelected()) {
+            for (JCheckBox target : targets) {
+                target.setEnabled(true);
+            }
+        } else {
+            for (JCheckBox target : targets) {
+                target.setEnabled(false);
+            }
+        }
+    }
 
     /**
      * Add components to panel.
@@ -119,22 +135,35 @@
             }
         });
 
-        JCheckBox[] debuggingOptions = { 
+        final JCheckBox[] debuggingOptions = { 
                 new JCheckBox(Translator.R("DPEnableLogging")),
                 new JCheckBox(Translator.R("DPEnableHeaders")),
                 new JCheckBox(Translator.R("DPEnableFile")),
+                new JCheckBox(Translator.R("DPEnableLegacyFileLog")),
+                new JCheckBox(Translator.R("DPEnableClientAppFileLogging")),
                 new JCheckBox(Translator.R("DPEnableStds")),
                 new JCheckBox(Translator.R("DPEnableSyslog"))
         };
-        String[] hints = { 
+        
+        debuggingOptions[2].addActionListener(new ActionListener() {
+
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                fileLoggingAct(debuggingOptions[2], debuggingOptions[3], debuggingOptions[4]);
+            }
+
+        });
+        final String[] hints = { 
                 (Translator.R("DPEnableLoggingHint")),
                 (Translator.R("DPEnableHeadersHint")),
                 (Translator.R("DPEnableFileHint", LogConfig.getLogConfig().getIcedteaLogDir())),
+                (Translator.R("DPEnableLegacyFileLogHint")),
+                (Translator.R("DPEnableClientAppFileLoggingHint")),
                 (Translator.R("DPEnableStdsHint")),
                 (Translator.R("DPEnableSyslogHint"))
         };
 
-        ComboItem[] javaConsoleItems = { new ComboItem(Translator.R("DPDisable"), DeploymentConfiguration.CONSOLE_DISABLE),
+        final ComboItem[] javaConsoleItems = { new ComboItem(Translator.R("DPDisable"), DeploymentConfiguration.CONSOLE_DISABLE),
                 new ComboItem(Translator.R("DPHide"), DeploymentConfiguration.CONSOLE_HIDE),
                 new ComboItem(Translator.R("DPShow"), DeploymentConfiguration.CONSOLE_SHOW), 
                 new ComboItem(Translator.R("DPShowPluginOnly"), DeploymentConfiguration.CONSOLE_SHOW_PLUGIN), 
@@ -167,20 +196,30 @@
                 c.gridy++;
             }
 
+            //move  5th and 6th checkbox below  logsDestination
+            if (i == 3 || i == 4) {
+                c.gridx += 1;
+                if (i == 4) {
+                    c.gridy--;
+                }
+            } else {
+                c.gridx = 0;
+            }
             debuggingOptions[i].setSelected(Boolean.parseBoolean(s));
             debuggingOptions[i].setActionCommand(properties[i]);
             debuggingOptions[i].setToolTipText(hints[i]);
             debuggingOptions[i].addItemListener(this);
             add(debuggingOptions[i], c);
 
-              if (i == 2) {
-                 c.gridx++;
-                add(logsDestinationTitle, c);
+            if (i == 2) {
+                c.gridx++;
+                JPanel resetTitlePanel = new JPanel(new BorderLayout(10, 0));
+                resetTitlePanel.add(logsDestinationReset, BorderLayout.LINE_START);
+                resetTitlePanel.add(logsDestinationTitle, BorderLayout.LINE_END);
+                add(resetTitlePanel, c);
                 c.gridx++;
                 add(logsDestination, c);
-                c.gridx++;
-                add(logsDestinationReset, c);
-                c.gridx-=3;
+                c.gridx -= 2;
             }
         }
 
@@ -200,6 +239,7 @@
         c.gridy++;
         c.weighty = 1;
         add(filler, c);
+        fileLoggingAct(debuggingOptions[2], debuggingOptions[3], debuggingOptions[4]);
     }
 
     @Override
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/controlpanel/DesktopShortcutPanel.java
--- a/netx/net/sourceforge/jnlp/controlpanel/DesktopShortcutPanel.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/controlpanel/DesktopShortcutPanel.java	Tue Jan 26 15:18:30 2016 +0100
@@ -1,5 +1,5 @@
 /* DesktopShortcutPanel.java -- Display option for adding desktop shortcut.
-Copyright (C) 2010 Red Hat
+Copyright (C) 2015 Red Hat
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -15,40 +15,42 @@
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  */
-
 package net.sourceforge.jnlp.controlpanel;
 
 import java.awt.Component;
 import java.awt.Dimension;
 import java.awt.GridBagConstraints;
 import java.awt.GridBagLayout;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
 import java.awt.event.ItemEvent;
 import java.awt.event.ItemListener;
 
 import javax.swing.Box;
+import javax.swing.JButton;
 import javax.swing.JComboBox;
 import javax.swing.JLabel;
+import javax.swing.SwingUtilities;
 import net.sourceforge.jnlp.ShortcutDesc;
 
 import net.sourceforge.jnlp.config.DeploymentConfiguration;
+import net.sourceforge.jnlp.controlpanel.desktopintegrationeditor.FreeDesktopIntegrationEditorFrame;
+import net.sourceforge.jnlp.runtime.JNLPRuntime;
 import net.sourceforge.jnlp.runtime.Translator;
 
 /**
  * This class provides the panel that allows the user to set whether they want
  * to create a desktop shortcut for javaws.
- * 
- * @author Andrew Su (asu@redhat.com, andrew.su@utoronto.ca)
- * 
  */
 public class DesktopShortcutPanel extends NamedBorderPanel implements ItemListener {
 
     private final DeploymentConfiguration config;
+    private FreeDesktopIntegrationEditorFrame integrationManagment;
 
     /**
      * Create a new instance of the desktop shortcut settings panel.
-     * 
-     * @param config
-     *            Loaded DeploymentConfiguration file.
+     *
+     * @param config Loaded DeploymentConfiguration file.
      */
     public DesktopShortcutPanel(DeploymentConfiguration config) {
         super(Translator.R("CPHeadDesktopIntegration"), new GridBagLayout());
@@ -57,7 +59,6 @@
         addComponents();
     }
 
-
     public static ComboItem deploymentJavawsShortcutToComboItem(String i) {
         return new ComboItem(ShortcutDesc.deploymentJavawsShortcutToString(i), i);
     }
@@ -69,6 +70,27 @@
         GridBagConstraints c = new GridBagConstraints();
         JLabel description = new JLabel("<html>" + Translator.R("CPDesktopIntegrationDescription") + "<hr /></html>");
         JComboBox<ComboItem> shortcutComboOptions = new JComboBox<>();
+        JButton manageIntegrationsButton = new JButton(Translator.R("CPDesktopIntegrationShowIntegrations"));
+        if (JNLPRuntime.isWindows()) {
+            manageIntegrationsButton.setToolTipText(Translator.R("CPDesktopIntegrationLinuxOnly"));
+            manageIntegrationsButton.setEnabled(false);
+        }
+        manageIntegrationsButton.addActionListener(new ActionListener() {
+
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                SwingUtilities.invokeLater(new Runnable() {
+
+                    @Override
+                    public void run() {
+                        if (integrationManagment == null) {
+                            integrationManagment = new FreeDesktopIntegrationEditorFrame();
+                        }
+                        integrationManagment.setVisible(true);
+                    }
+                });
+            }
+        });
         ComboItem[] items = {deploymentJavawsShortcutToComboItem(ShortcutDesc.CREATE_NEVER),
             deploymentJavawsShortcutToComboItem(ShortcutDesc.CREATE_ALWAYS),
             deploymentJavawsShortcutToComboItem(ShortcutDesc.CREATE_ASK_USER),
@@ -92,6 +114,8 @@
         add(description, c);
         c.gridy = 1;
         add(shortcutComboOptions, c);
+        c.gridy = 2;
+        add(manageIntegrationsButton, c);
 
         // This is to keep it from expanding vertically if resized.
         Component filler = Box.createRigidArea(new Dimension(1, 1));
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/controlpanel/desktopintegrationeditor/Blinker.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/netx/net/sourceforge/jnlp/controlpanel/desktopintegrationeditor/Blinker.java	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,103 @@
+/*   Copyright (C) 2015 Red Hat, Inc.
+
+ This file is part of IcedTea.
+
+ IcedTea is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, version 2.
+
+ IcedTea is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with IcedTea; see the file COPYING.  If not, write to
+ the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301 USA.
+
+ Linking this library statically or dynamically with other modules is
+ making a combined work based on this library.  Thus, the terms and
+ conditions of the GNU General Public License cover the whole
+ combination.
+
+ As a special exception, the copyright holders of this library give you
+ permission to link this library with independent modules to produce an
+ executable, regardless of the license terms of these independent
+ modules, and to copy and distribute the resulting executable under
+ terms of your choice, provided that you also meet, for each linked
+ independent module, the terms and conditions of the license of that
+ module.  An independent module is a module which is not derived from
+ or based on this library.  If you modify this library, you may extend
+ this exception to your version of the library, but you are not
+ obligated to do so.  If you do not wish to do so, delete this
+ exception statement from your version.
+ */
+package net.sourceforge.jnlp.controlpanel.desktopintegrationeditor;
+
+import java.awt.Color;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import javax.swing.JComponent;
+import javax.swing.SwingUtilities;
+import javax.swing.Timer;
+
+public class Blinker {
+
+    private boolean blinking;
+    private final JComponent compToBlink;
+
+    public Blinker(JComponent compToBlink) {
+        this.compToBlink = compToBlink;
+    }
+
+    public void blink() {
+        if (blinking) {
+            return;
+        }
+        blinking = true;
+        Timer t = new Timer(100, new BlinkBody());
+        t.setInitialDelay(0);
+        t.start();
+    }
+
+    class BlinkBody implements ActionListener {
+
+        int counter = 0;
+        Color base;
+        Color invert;
+
+        @Override
+        public void actionPerformed(ActionEvent e) {
+            counter++;
+            if (counter == 1) {
+                base = compToBlink.getBackground();
+                invert = new Color(Math.min(255, base.getRed() * 2), Math.max(0, base.getGreen() / 2), 255 - base.getBlue());
+            }
+            if (counter == 5) {
+                ((Timer) e.getSource()).stop();
+                SwingUtilities.invokeLater(new Runnable() {
+
+                    @Override
+                    public void run() {
+                        compToBlink.setBackground(base);
+                        blinking = false;
+                    }
+                });
+                return;
+            }
+            SwingUtilities.invokeLater(new Runnable() {
+
+                @Override
+                public void run() {
+                    if (compToBlink.getBackground().equals(base)) {
+                        compToBlink.setBackground(invert);
+                    } else {
+                        compToBlink.setBackground(base);
+                    }
+                }
+            });
+        }
+
+    }
+}
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/controlpanel/desktopintegrationeditor/FreeDesktopIntegrationEditorFrame.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/netx/net/sourceforge/jnlp/controlpanel/desktopintegrationeditor/FreeDesktopIntegrationEditorFrame.java	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,509 @@
+/*   Copyright (C) 2015 Red Hat, Inc.
+
+ This file is part of IcedTea.
+
+ IcedTea is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, version 2.
+
+ IcedTea is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with IcedTea; see the file COPYING.  If not, write to
+ the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301 USA.
+
+ Linking this library statically or dynamically with other modules is
+ making a combined work based on this library.  Thus, the terms and
+ conditions of the GNU General Public License cover the whole
+ combination.
+
+ As a special exception, the copyright holders of this library give you
+ permission to link this library with independent modules to produce an
+ executable, regardless of the license terms of these independent
+ modules, and to copy and distribute the resulting executable under
+ terms of your choice, provided that you also meet, for each linked
+ independent module, the terms and conditions of the license of that
+ module.  An independent module is a module which is not derived from
+ or based on this library.  If you modify this library, you may extend
+ this exception to your version of the library, but you are not
+ obligated to do so.  If you do not wish to do so, delete this
+ exception statement from your version.
+ */
+package net.sourceforge.jnlp.controlpanel.desktopintegrationeditor;
+
+import java.awt.BorderLayout;
+import java.awt.GridLayout;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.util.ArrayList;
+import java.util.List;
+import javax.swing.JButton;
+import javax.swing.JCheckBox;
+import javax.swing.JFrame;
+import javax.swing.JLabel;
+import javax.swing.JList;
+import javax.swing.JOptionPane;
+import javax.swing.JPanel;
+import javax.swing.JScrollPane;
+import javax.swing.JSplitPane;
+import javax.swing.JTextPane;
+import javax.swing.ListModel;
+import javax.swing.event.ListSelectionEvent;
+import javax.swing.event.ListSelectionListener;
+import net.sourceforge.jnlp.config.PathsAndFiles;
+import net.sourceforge.jnlp.security.dialogs.SecurityDialogPanel;
+import net.sourceforge.jnlp.util.XDesktopEntry;
+import net.sourceforge.jnlp.util.logging.ConsoleOutputPaneModel;
+
+import static net.sourceforge.jnlp.runtime.Translator.R;
+
+public class FreeDesktopIntegrationEditorFrame extends JFrame {
+
+    //gui
+    private final javax.swing.JLabel title = new JLabel();
+    private final javax.swing.JCheckBox selectRelativeRecordsFromOtherColumns = new JCheckBox();
+    private final javax.swing.JButton removeSelectedButton = new JButton();
+    private final javax.swing.JButton cleanAll = new JButton();
+    private final javax.swing.JButton closeButton = new JButton();
+    private final javax.swing.JButton reloadsListButton = new JButton();
+    private final javax.swing.JButton selectAll = new JButton();
+
+    //important ones
+    private final javax.swing.JList menuList = new JListUtils.CustomRendererJList();
+    private final javax.swing.JList desktopList = new JListUtils.CustomValidatingRendererJList();
+    private final javax.swing.JList generatedList = new JListUtils.CustomRendererJList();
+    private final javax.swing.JList iconsList = new JListUtils.CustomRendererWithIconJList();
+
+    PreviewSelectionJTextPane previewPane = new PreviewSelectionJTextPane(iconsList, menuList, desktopList, generatedList);
+    //gui end
+
+    private final Blinker blinker;
+
+    private void setListeners() {
+        removeSelectedButton.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent evt) {
+                FreeDesktopIntegrationEditorFrame.this.removeSelected();
+            }
+        });
+
+        closeButton.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent evt) {
+                dispose();
+            }
+        });
+
+        reloadsListButton.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent evt) {
+                populateLists();
+            }
+        });
+
+        selectAll.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent evt) {
+                selectAll();
+            }
+        });
+
+        cleanAll.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent evt) {
+                cleanAll();
+            }
+        });
+
+    }
+
+    private void setTexts() {
+        this.setTitle(R("DIMtitle"));
+        closeButton.setText(R("ButClose"));
+        removeSelectedButton.setText(R("DIMremoveSelected"));
+        selectRelativeRecordsFromOtherColumns.setText(R("DIMselectRelativeRecordsFromOtherColumns"));
+        reloadsListButton.setText(R("DIMreloadLists"));
+        selectAll.setText(R("DIMselectAll"));
+        cleanAll.setText(R("DIMclearSelection"));
+        title.setText(SecurityDialogPanel.htmlWrap("<p>" + R("DIMdescription") + "</p>"));
+    }
+
+    private JPanel createMainControls() {
+        JPanel mainControls = new JPanel(new GridLayout(1, 2));
+        mainControls.add(closeButton);
+        mainControls.add(removeSelectedButton);
+        return mainControls;
+    }
+
+    private JPanel createMiddleToolBox() {
+        JPanel middleToolBox = new JPanel(new GridLayout(1, 2));
+        middleToolBox.add(selectRelativeRecordsFromOtherColumns);
+        middleToolBox.add(reloadsListButton);
+        middleToolBox.add(selectAll);
+        middleToolBox.add(cleanAll);
+        return middleToolBox;
+    }
+
+    private JPanel createPreviewPanel(JTextPane previewPane) {
+        JPanel previewPanel = new JPanel(new BorderLayout());
+        JScrollPane jScrollPane2 = new JScrollPane();
+        jScrollPane2.setViewportView(previewPane);
+        previewPanel.add(jScrollPane2, BorderLayout.CENTER);
+        createMiddleToolBox();
+        previewPanel.add(createMiddleToolBox(), BorderLayout.PAGE_START);
+        return previewPanel;
+    }
+
+    private JSplitPane createListsLayout() {
+        JPanel menusPanel = Panels.createMenuPanel(menuList, new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent evt) {
+                selectSomeRelatives(menuList.getSelectedValuesList(), iconsList);
+            }
+        }, new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent evt) {
+                selectSomeRelatives(menuList.getSelectedValuesList(), generatedList);
+            }
+        }
+        );
+        JPanel desktopsPanel = Panels.createDesktopPanel(desktopList, new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent evt) {
+                selectSomeRelatives(desktopList.getSelectedValuesList(), iconsList);
+            }
+        }, new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent evt) {
+                selectSomeRelatives(desktopList.getSelectedValuesList(), generatedList);
+            }
+        }
+        );
+        JPanel iconsPanel = Panels.createIconsPanel(iconsList, new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent evt) {
+                findOrphans(iconsList, allItemsAsFiles(menuList), allItemsAsFiles(desktopList));
+            }
+        });
+        JPanel generatedsPanel = Panels.createGeneratedPanel(generatedList, new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent evt) {
+                findOrphans(generatedList, allItemsAsFiles(menuList), allItemsAsFiles(desktopList));
+            }
+        });
+        return Panels.createQuadroSplit(expectedWidth, menusPanel, desktopsPanel, iconsPanel, generatedsPanel);
+    }
+
+    private void setLayout() {
+        createMainControls();
+        getContentPane().add(createMainControls(), BorderLayout.PAGE_END);
+        JSplitPane splitListsAndPreview = new JSplitPane(JSplitPane.VERTICAL_SPLIT);
+        splitListsAndPreview.setLeftComponent(createListsLayout());
+        splitListsAndPreview.setRightComponent(createPreviewPanel(previewPane));
+        getContentPane().add(splitListsAndPreview, BorderLayout.CENTER);
+        getContentPane().add(title, BorderLayout.PAGE_START);
+        splitListsAndPreview.setDividerLocation(expectedHeight / 2);
+    }
+
+    public static void main(String args[]) {
+
+        java.awt.EventQueue.invokeLater(new Runnable() {
+            @Override
+            public void run() {
+                new FreeDesktopIntegrationEditorFrame().setVisible(true);
+            }
+        });
+    }
+
+    private boolean selecting = false;
+    private final int expectedWidth = 800;
+    private final int expectedHeight = 600;
+
+    public FreeDesktopIntegrationEditorFrame() {
+        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
+        this.setSize(expectedWidth, expectedHeight);
+        populateLists();
+        setTexts();
+        setListeners();
+        setLayout();
+        selectRelativeRecordsFromOtherColumns.setSelected(true);
+
+        ListSelectionListener generatePreviewListener = new GeneratePreviewListener();
+
+        iconsList.addListSelectionListener(generatePreviewListener);
+        desktopList.addListSelectionListener(generatePreviewListener);
+        menuList.addListSelectionListener(generatePreviewListener);
+        generatedList.addListSelectionListener(generatePreviewListener);
+        blinker = new Blinker(selectRelativeRecordsFromOtherColumns);
+
+    }
+
+    private void populateLists() {
+        menuList.setModel(new JListUtils.InfrastructureFileDescriptorListingBasedJListModel(PathsAndFiles.MENUS_DIR));
+        desktopList.setModel(new JListUtils.FileListBasedJListModel(new File(XDesktopEntry.findFreedesktopOrgDesktopPathCatch()), "(?i)^.*\\.desktop$") {
+
+            @Override
+            public String toString() {
+                return R("DIMguessedDesktop");
+            }
+        });
+        iconsList.setModel(new JListUtils.InfrastructureFileDescriptorListingBasedJListModel(PathsAndFiles.ICONS_DIR));
+        generatedList.setModel(new JListUtils.InfrastructureFileDescriptorListingBasedJListModel(PathsAndFiles.GEN_JNLPS_DIR));
+    }
+
+    private void cleanAll() {
+        selecting = true;
+        try {
+            clearAll();
+        } finally {
+            selecting = false;
+        }
+    }
+
+    private void clearAll() {
+        desktopList.clearSelection();
+        menuList.clearSelection();
+        generatedList.clearSelection();
+        iconsList.clearSelection();
+        previewPane.setText(R("DIMselectionPreview"));
+    }
+
+    private void removeSelected() {
+        int a = getTotal(
+                objectListToFileList(iconsList.getSelectedValuesList()),
+                objectListToFileList(menuList.getSelectedValuesList()),
+                objectListToFileList(desktopList.getSelectedValuesList()),
+                objectListToFileList(generatedList.getSelectedValuesList())
+        );
+        if (a <= 0) {
+            return;
+        }
+        int x = JOptionPane.showConfirmDialog(this, R("DIMaskBeforeDelete", a));
+        if (x == JOptionPane.OK_OPTION || x == JOptionPane.YES_OPTION) {
+            removeSelected(
+                    objectListToFileList(iconsList.getSelectedValuesList()),
+                    objectListToFileList(menuList.getSelectedValuesList()),
+                    objectListToFileList(desktopList.getSelectedValuesList()),
+                    objectListToFileList(generatedList.getSelectedValuesList())
+            );
+            populateLists();
+        }
+    }
+
+    private void selectAll() {
+        selecting = true;
+        try {
+            selectAll(menuList);
+            selectAll(desktopList);
+            selectAll(iconsList);
+            selectAll(generatedList);
+        } finally {
+            selecting = false;
+        }
+        previewPane.generatePreview();
+    }
+
+    public List<File> allItemsAsFiles(JList l) {
+        return allItemsAsFiles(l.getModel());
+    }
+
+    public List<File> allItemsAsFiles(ListModel l) {
+        List<File> r = new ArrayList<>(l.getSize());
+        for (int i = 0; i < l.getSize(); i++) {
+            r.add((File) l.getElementAt(i));
+
+        }
+        return r;
+    }
+
+    private List<File> objectListToFileList(List l) {
+        List<File> r = new ArrayList(l.size());
+        for (Object l1 : l) {
+            r.add((File) l1);
+        }
+        return r;
+    }
+
+    private void removeSelected(List<File>... a) {
+        for (List<File> list : a) {
+            for (File file : list) {
+                file.delete();
+
+            }
+        }
+    }
+
+    private int getTotal(List<File>... a) {
+        int i = 0;
+        for (List<File> list : a) {
+            i+=list.size();
+        }
+        return i;
+    }
+
+    private void findOrphans(JList possibleOrphans, List<File>... whereItCanBe) {
+        selecting = true;
+        if (selectRelativeRecordsFromOtherColumns.isSelected()) {
+            clearAll();
+            blinker.blink();
+        }
+        try {
+            possibleOrphans.clearSelection();
+            List<File> l = allItemsAsFiles(possibleOrphans);
+            for (int i = 0; i < l.size(); i++) {
+                File file = l.get(i);
+                boolean found = false;
+                for (List<File> lf : whereItCanBe) {
+                    if (found) {
+                        break;
+                    }
+                    for (File f : lf) {
+                        String s = fileToString(f, false);
+                        if (s.contains(file.getAbsolutePath())) {
+                            found = true;
+                            break;
+                        }
+                    }
+                }
+                if (!found) {
+                   possibleOrphans.addSelectionInterval(i, i);
+                }
+            }
+        } finally {
+            selecting = false;
+        }
+        previewPane.generatePreview();
+    }
+
+    private void selectSomeRelatives(List selected, JList target) {
+        selecting = true;
+        try {
+            selectFileFromShortcuts(selected, target);
+        } finally {
+            selecting = false;
+        }
+        previewPane.generatePreview();
+    }
+
+    private void selectAll(JList list) {
+        int start = 0;
+        int end = list.getModel().getSize() - 1;
+        if (end >= 0) {
+            list.setSelectionInterval(start, end);
+        }
+    }
+
+    private class GeneratePreviewListener implements ListSelectionListener {
+
+        public GeneratePreviewListener() {
+        }
+
+        @Override
+        public void valueChanged(ListSelectionEvent e) {
+            if (selecting) {
+                return;
+            }
+            try {
+                selecting = true;
+                if (selectRelativeRecordsFromOtherColumns.isSelected()) {
+                    blinker.blink();
+                    selectRelatives(e.getSource());
+
+                }
+            } finally {
+                selecting = false;
+            }
+
+            previewPane.generatePreview();
+        }
+    }
+
+    private void selectRelatives(Object source) {
+        if (source instanceof JList) {
+            int[] indexes = ((JList) (source)).getSelectedIndices();
+            clearAll();
+            ((JList) (source)).setSelectedIndices(indexes);
+        }
+
+        for (int x = 1; x <= 3; x++) {
+            //we dont wont recurse, so sending copies in
+            selectShortcutsByFiles(
+                    objectListToFileList(iconsList.getSelectedValuesList()),
+                    objectListToFileList(generatedList.getSelectedValuesList())
+            );
+            selectFilesByShortcuts(
+                    objectListToFileList(menuList.getSelectedValuesList()),
+                    objectListToFileList(desktopList.getSelectedValuesList())
+            );
+        }
+    }
+
+    static String fileToString(File f, boolean escape) {
+        try (BufferedReader bufferedReader = new BufferedReader(new FileReader(f))) {
+
+            StringBuilder sb = new StringBuilder();
+
+            while (true) {
+                String line = bufferedReader.readLine();
+                if (line == null) {
+                    return sb.toString();
+                }
+                if (escape) {
+                    line = ConsoleOutputPaneModel.escapeHtmlForJTextPane(line);
+                }
+                sb.append(line).append("\n");
+            }
+
+        } catch (Exception ex) {
+            return ex.toString();
+        }
+    }
+
+    private void selectShortcutsByFiles(List<File> icons, List<File> jnlps) {
+        selectShortcutsWithFiles(icons, desktopList);
+        selectShortcutsWithFiles(icons, menuList);
+        selectShortcutsWithFiles(jnlps, desktopList);
+        selectShortcutsWithFiles(jnlps, menuList);
+    }
+
+    private void selectFilesByShortcuts(List<File> menu, List<File> desktop) {
+        selectFileFromShortcuts(desktop, iconsList);
+        selectFileFromShortcuts(desktop, generatedList);
+        selectFileFromShortcuts(menu, iconsList);
+        selectFileFromShortcuts(menu, generatedList);
+    }
+
+    private void selectShortcutsWithFiles(List<File> icons, JList list) {
+        for (int i = 0; i < list.getModel().getSize(); i++) {
+            File item = (File) list.getModel().getElementAt(i);
+            String s = fileToString(item, false);
+            for (File icon : icons) {
+                if (s.contains(icon.getAbsolutePath())) {
+                    list.addSelectionInterval(i, i);
+                }
+            }
+
+        }
+    }
+
+    private void selectFileFromShortcuts(List<File> shortcuts, JList files) {
+        for (File shortcut : shortcuts) {
+            String s = fileToString(shortcut, false);
+            for (int i = 0; i < files.getModel().getSize(); i++) {
+                File item = (File) files.getModel().getElementAt(i);
+                if (s.contains(item.getAbsolutePath())) {
+                    files.addSelectionInterval(i, i);
+                }
+
+            }
+        }
+
+    }
+}
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/controlpanel/desktopintegrationeditor/JListUtils.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/netx/net/sourceforge/jnlp/controlpanel/desktopintegrationeditor/JListUtils.java	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,380 @@
+/*   Copyright (C) 2015 Red Hat, Inc.
+
+ This file is part of IcedTea.
+
+ IcedTea is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, version 2.
+
+ IcedTea is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with IcedTea; see the file COPYING.  If not, write to
+ the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301 USA.
+
+ Linking this library statically or dynamically with other modules is
+ making a combined work based on this library.  Thus, the terms and
+ conditions of the GNU General Public License cover the whole
+ combination.
+
+ As a special exception, the copyright holders of this library give you
+ permission to link this library with independent modules to produce an
+ executable, regardless of the license terms of these independent
+ modules, and to copy and distribute the resulting executable under
+ terms of your choice, provided that you also meet, for each linked
+ independent module, the terms and conditions of the license of that
+ module.  An independent module is a module which is not derived from
+ or based on this library.  If you modify this library, you may extend
+ this exception to your version of the library, but you are not
+ obligated to do so.  If you do not wish to do so, delete this
+ exception statement from your version.
+ */
+package net.sourceforge.jnlp.controlpanel.desktopintegrationeditor;
+
+import java.awt.Color;
+import java.awt.Component;
+import java.awt.Image;
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FilenameFilter;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.regex.Pattern;
+import javax.imageio.ImageIO;
+import javax.imageio.stream.ImageInputStream;
+import javax.swing.DefaultListCellRenderer;
+import javax.swing.Icon;
+import javax.swing.ImageIcon;
+import javax.swing.JLabel;
+import javax.swing.JList;
+
+import javax.swing.ListModel;
+import javax.swing.event.ListDataListener;
+import net.sourceforge.jnlp.config.InfrastructureFileDescriptor;
+import net.sourceforge.jnlp.tools.ico.impl.ImageInputStreamIco;
+import net.sourceforge.jnlp.util.XDesktopEntry;
+
+public class JListUtils {
+
+    private static Map<File, Icon> iconCache = new HashMap<>();
+    private static Map<File, String> textFilesCache = new HashMap<>();
+    private static Map<File, Long> stamps = new HashMap<>();
+
+    public static class InfrastructureFileDescriptorListingBasedJListModel extends FileListBasedJListModel {
+
+        private final InfrastructureFileDescriptor source;
+
+        public InfrastructureFileDescriptorListingBasedJListModel(InfrastructureFileDescriptor source, String mask) {
+            super(source.getFile(), mask);
+            this.source = source;
+        }
+
+        public InfrastructureFileDescriptorListingBasedJListModel(InfrastructureFileDescriptor source) {
+            super(source.getFile());
+            this.source = source;
+        }
+
+        public InfrastructureFileDescriptor getSource() {
+            return source;
+        }
+
+        @Override
+        protected File getFile() {
+            return source.getFile();
+        }
+
+        @Override
+        public String toString() {
+            return source.toString();
+        }
+
+    }
+
+    public static class FileListBasedJListModel implements ListModel {
+
+        private final File directory;
+        private File[] list;
+        private final Pattern mask;
+
+        /**
+         * Construct list containing all files from given directory
+         *
+         * @param dir
+         */
+        public FileListBasedJListModel(File dir) {
+            //calling constructor with regex matching every file
+            this(dir, ".*");
+        }
+
+        /**
+         * Construct list containing files from given directory matching regex of given mask, 
+         *
+         * @param dir directory to list
+         * @param mask regex to match files to display
+         */
+        public FileListBasedJListModel(File dir, final String mask) {
+            directory = dir;
+            this.mask = Pattern.compile(mask);
+        }
+
+        protected File getFile() {
+            return directory;
+        }
+
+        @Override
+        public String toString() {
+            return getFile().getAbsolutePath();
+        }
+
+        private File[] populateList() {
+            list = getFile().listFiles(new FilenameFilter() {
+
+                @Override
+                public boolean accept(File dir, String name) {
+                    return mask.matcher(name).matches();
+                }
+            });
+            return list;
+        }
+
+        @Override
+        public int getSize() {
+            if (list == null) {
+                populateList();
+            }
+            return list.length;
+        }
+
+        @Override
+        public Object getElementAt(int index) {
+            if (list == null) {
+                populateList();
+            }
+            return list[index];
+        }
+
+        @Override
+        public void addListDataListener(ListDataListener l) {
+
+        }
+
+        @Override
+        public void removeListDataListener(ListDataListener l) {
+
+        }
+
+    }
+
+    public static class CustomRendererJList extends JList<File> {
+
+        public CustomRendererJList() {
+            this.setCellRenderer(new FileCellRenderer());
+        }
+
+    }
+
+    public static class CustomValidatingRendererJList extends JList<File> {
+
+        public CustomValidatingRendererJList() {
+            this.setCellRenderer(new ValidatingFileCellRenderer());
+        }
+
+    }
+
+    public static class CustomRendererWithIconJList extends JList<File> {
+
+        public CustomRendererWithIconJList() {
+            setCellRenderer(new IconisedCellRenderer());
+        }
+
+    }
+
+    private static class FileCellRenderer extends DefaultListCellRenderer {
+
+        @Override
+        public Component getListCellRendererComponent(
+                JList list, Object value, int index,
+                boolean isSelected, boolean cellHasFocus) {
+
+            File f = (File) value;
+            JLabel label = (JLabel) super.getListCellRendererComponent(
+                    list, value, index, isSelected, cellHasFocus);
+            label.setText(f.getName());
+            return label;
+        }
+    }
+
+    private static class ValidatingFileCellRenderer extends FileCellRenderer {
+
+        @Override
+        public Component getListCellRendererComponent(
+                JList list, Object value, int index,
+                boolean isSelected, boolean cellHasFocus) {
+            JLabel l = (JLabel) super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
+            File f = (File) value;
+            String s = processTextFilesCache(f);
+            if (!isSelected) {
+                if (isJavaws(s)) {
+                    l.setBackground(new Color(0, 200, 0));
+
+                } else if (isBrowser(s)) {
+                    l.setBackground(new Color(100, 150, 0));
+                } else {
+                    l.setBackground(new Color(255, 200, 200));
+                }
+            } else {
+                if (isJavaws(s)) {
+                    l.setForeground(new Color(0, 200, 0));
+
+                } else if (isBrowser(s)) {
+                    l.setForeground(new Color(100, 150, 0));
+                } else {
+                    l.setForeground(new Color(255, 200, 200));
+                }
+            }
+            return l;
+        }
+
+        private boolean isJavaws(String s) {
+            return haveString(s, "javaws");
+        }
+
+        private boolean isBrowser(String s) {
+            String[] browsers = XDesktopEntry.BROWSERS;
+            for (String browser : browsers) {
+                if (haveString(s, browser)) {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        private boolean haveString(String s, String i) {
+            return s.matches("(?sm).*^.*Exec.*=.*" + i + ".*$.*");
+        }
+    }
+
+    private static class IconisedCellRenderer extends DefaultListCellRenderer {
+
+        @Override
+        public Component getListCellRendererComponent(
+                JList list, Object value, int index,
+                boolean isSelected, boolean cellHasFocus) {
+
+            File f = (File) value;
+            JLabel label = (JLabel) super.getListCellRendererComponent(
+                    list, value, index, isSelected, cellHasFocus);
+            label.setIcon(processIconCache(f));
+            label.setText(f.getName());
+            label.setHorizontalTextPosition(JLabel.RIGHT);
+            return label;
+        }
+
+    }
+
+    /**
+     * This method looks to cache whether file F was already read as image.
+     * If not, file is loaded, put to cache and returned
+     * If so, it also check whether it was modified. If so, it is reloaded, replaced in cache and returned.
+     * 
+     * @param f
+     * @return 
+     */
+    private static Icon processIconCache(File f) {
+        Icon i = iconCache.get(f);
+        if (i == null) {
+            i = updateIconCache(f, i);
+        } else {
+            if (f.lastModified() != stamps.get(f)) {
+                i = updateIconCache(f, i);
+            }
+        }
+        return i;
+    }
+
+     /**
+     * This method load Icon from file.
+     * Once file is loaded, it is stored also to cache
+     * Also the time stamp of last modification is stored to cache to allow reloading when changed.
+     * 
+     * @param f file to load, and to provide timestamp of last modification
+     * @return loaded icon or null
+     */
+    private static Icon updateIconCache(File f, Icon i) {
+        i = createImageIcon(f, f.getAbsolutePath());
+        if (i != null) {
+            iconCache.put(f, i);
+            stamps.put(f, f.lastModified());
+        }
+        return i;
+    }
+
+     /**
+     * This method looks to cache whether file F was already read as text file.
+     * If not, file is loaded, and its content is put to cache and returned as String
+     * If so, it also check whether it was modified. If so, it is reloaded, replaced in cache and returned.
+     * 
+     * @param f
+     * @return 
+     */
+    private static String processTextFilesCache(File f) {
+        String s = textFilesCache.get(f);
+        if (s == null) {
+            s = updateTextCache(f, s);
+        } else {
+            if (f.lastModified() != stamps.get(f)) {
+                s = updateTextCache(f, s);
+            }
+        }
+        return s;
+    }
+
+    /**
+     * This method load Text from file.
+     * Once file is loaded, it is stored also to cache
+     * Also the time stamp of last modification is stored to cache to allow reloading when changed.
+     * 
+     * @param f file to load, and to provide timestamp of last modification
+     * @return loaded Text, error message or null
+     */
+    private static String updateTextCache(File f, String s) {
+        s = FreeDesktopIntegrationEditorFrame.fileToString(f, false);
+        if (s != null) {
+            textFilesCache.put(f, s);
+            stamps.put(f, f.lastModified());
+        }
+        return s;
+    }
+
+    /**
+     * Load BufferedImage form file, scale it and converts to icon.
+     * 
+     * @param f file to be loaded
+     * @param description description to be provided
+     * @return icon from file or null if something went wrong
+     */
+    private static ImageIcon createImageIcon(File f, String description) {
+        try {
+            BufferedImage i;
+            try(ImageInputStream is = ImageIO.createImageInputStream(new FileInputStream(f))) {
+                ImageInputStreamIco ico = new ImageInputStreamIco(is);
+                i = ico.getImage(0);
+            } catch (Exception eex) {
+                //not ico
+                i = null;
+            }
+            if (i == null) {
+                i = ImageIO.read(f);
+            }
+            return new ImageIcon(i.getScaledInstance(50, 50, Image.SCALE_SMOOTH));
+        } catch (Exception ex) {
+            //not worthy to log it. No image is there and so be it.
+            return null;
+        }
+    }
+}
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/controlpanel/desktopintegrationeditor/Panels.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/netx/net/sourceforge/jnlp/controlpanel/desktopintegrationeditor/Panels.java	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,152 @@
+/*   Copyright (C) 2015 Red Hat, Inc.
+
+ This file is part of IcedTea.
+
+ IcedTea is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, version 2.
+
+ IcedTea is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with IcedTea; see the file COPYING.  If not, write to
+ the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301 USA.
+
+ Linking this library statically or dynamically with other modules is
+ making a combined work based on this library.  Thus, the terms and
+ conditions of the GNU General Public License cover the whole
+ combination.
+
+ As a special exception, the copyright holders of this library give you
+ permission to link this library with independent modules to produce an
+ executable, regardless of the license terms of these independent
+ modules, and to copy and distribute the resulting executable under
+ terms of your choice, provided that you also meet, for each linked
+ independent module, the terms and conditions of the license of that
+ module.  An independent module is a module which is not derived from
+ or based on this library.  If you modify this library, you may extend
+ this exception to your version of the library, but you are not
+ obligated to do so.  If you do not wish to do so, delete this
+ exception statement from your version.
+ */
+package net.sourceforge.jnlp.controlpanel.desktopintegrationeditor;
+
+import java.awt.BorderLayout;
+import java.awt.event.ActionListener;
+import javax.swing.JButton;
+import javax.swing.JLabel;
+import javax.swing.JList;
+import javax.swing.JPanel;
+import javax.swing.JScrollPane;
+import javax.swing.JSplitPane;
+import net.sourceforge.jnlp.security.dialogs.SecurityDialogPanel;
+
+import static net.sourceforge.jnlp.runtime.Translator.R;
+
+public class Panels {
+
+    public static JPanel createGeneratedPanel(JList list, ActionListener findOrphans) {
+        return createIconsOrGeneratedPanel(list, findOrphans, R("DIMgeneratedJnlps"), bold(R("DIMgeneratedJnlpsTooltip")));
+    }
+
+    public static JPanel createIconsPanel(JList list, ActionListener findOrphans) {
+        return createIconsOrGeneratedPanel(list, findOrphans, R("DIMicons"), bold(R("DIMiconsTooltip")));
+    }
+
+    private static JPanel createIconsOrGeneratedPanel(JList list, ActionListener findOrphans, String title, String tooltip) {
+        JPanel iconsPanel = new JPanel(new BorderLayout());
+        JLabel l = new JLabel(title);
+        l.setToolTipText(createToolTip(tooltip, list));
+        iconsPanel.add(l, BorderLayout.PAGE_START);
+        JScrollPane scrollIcons = new JScrollPane();
+        scrollIcons.setViewportView(list);
+        iconsPanel.add(scrollIcons, BorderLayout.CENTER);
+        JPanel iconsToolPanel = new JPanel(new BorderLayout());
+        JButton findOrphansButton = new JButton(R("DIMorphans"));
+        findOrphansButton.addActionListener(findOrphans);
+        findOrphansButton.setToolTipText(R("DIMorphansTooltip"));
+        iconsToolPanel.add(findOrphansButton, BorderLayout.CENTER);
+        iconsPanel.add(iconsToolPanel, BorderLayout.PAGE_END);
+        return iconsPanel;
+    }
+
+    public static JPanel createMenuPanel(JList list, ActionListener findIcons, ActionListener findGenerated) {
+        return createDesktopOrMenuPanel(list, findIcons, findGenerated, R("DIMmenuItems"), bold(R("DIMmenuItemsTooltip")));
+    }
+
+    public static JPanel createDesktopPanel(JList list, ActionListener findIcons, ActionListener findGenerated) {
+        StringBuilder sb = new StringBuilder();
+        sb.append(R("DIMdesktopItemsTooltipL1")).append("<br>")
+                .append(R("DIMdesktopItemsTooltipL2")).append(":" + "<ul>" + "<li>")
+                .append(R("DIMdesktopItemsTooltipL3")).append("</li>" + "<li>")
+                .append(R("DIMdesktopItemsTooltipL4")).append("</li>" + "<li>")
+                .append(R("DIMdesktopItemsTooltipL5")).append("</li>" + "</ul>")
+                .append(bold(R("DIMdesktopItemsTooltipL6")));
+        return createDesktopOrMenuPanel(list, findIcons, findGenerated, R("DIMdesktopItems"), sb.toString());
+    }
+
+    private static JPanel createDesktopOrMenuPanel(JList list, ActionListener findIcons, ActionListener findGenerated, String title, String tooltip) {
+        JPanel desktopPanel = new JPanel(new BorderLayout());
+        JLabel l = new JLabel(title);
+        l.setToolTipText(createToolTip(tooltip, list));
+        desktopPanel.add(l, BorderLayout.PAGE_START);
+        JScrollPane scrollDesktop = new JScrollPane();
+        scrollDesktop.setViewportView(list);
+        desktopPanel.add(scrollDesktop, BorderLayout.CENTER);
+        JPanel desktopToolPanel = createDesktopOrMenuToolBox(findIcons, findGenerated);
+        desktopPanel.add(desktopToolPanel, BorderLayout.PAGE_END);
+        return desktopPanel;
+    }
+
+    private static String createToolTip(String tooltip, JList list) {
+        if (tooltip != null) {
+            JListUtils.FileListBasedJListModel model = (JListUtils.FileListBasedJListModel) (list.getModel());
+            StringBuilder sb = new StringBuilder();
+            sb.append("<ul><li>")
+                    .append(model.getFile()).append("</li><br>" + "<li>")
+                    .append(model.toString()).append("</li><br>" + "<li>")
+                    .append(tooltip).append("</ul>");
+            String tt = SecurityDialogPanel.htmlWrap(sb.toString());
+            return tt;
+        }
+        return null;
+    }
+
+    private static JPanel createDesktopOrMenuToolBox(ActionListener findIcons, ActionListener findGenerated) {
+        JPanel desktopToolPanel = new JPanel(new BorderLayout());
+        JButton desktopFindGeneratedButton = new JButton(R("DIMgeneratedButton"));
+        desktopFindGeneratedButton.setToolTipText(R("DIMgeneratedButtonTooltip"));
+        desktopFindGeneratedButton.addActionListener(findGenerated);
+        JButton desktopFindIconsButton = new JButton(R("DIMiconsButton"));
+        desktopFindIconsButton.setToolTipText(R("DIMiconsButtonTooltip"));
+        desktopFindIconsButton.addActionListener(findIcons);
+        desktopToolPanel.add(desktopFindGeneratedButton, BorderLayout.LINE_END);
+        desktopToolPanel.add(desktopFindIconsButton, BorderLayout.LINE_START);
+        return desktopToolPanel;
+    }
+
+    static JSplitPane createQuadroSplit(int width, JPanel menusPanel, JPanel desktopsPanel, JPanel iconsPanel, JPanel generatedsPanel) {
+        JSplitPane splitAllAndGenerated = new JSplitPane();
+        JSplitPane splitIconsAndLists = new JSplitPane();
+        JSplitPane splitLists = new JSplitPane();
+        splitLists.setLeftComponent(menusPanel);
+        splitLists.setRightComponent(desktopsPanel);
+        splitIconsAndLists.setRightComponent(splitLists);
+        splitIconsAndLists.setLeftComponent(iconsPanel);
+        splitAllAndGenerated.setLeftComponent(splitIconsAndLists);
+        splitAllAndGenerated.setRightComponent(generatedsPanel);
+        splitAllAndGenerated.setDividerLocation(width / 5 * 4);
+        splitIconsAndLists.setDividerLocation(width / 4);
+        splitLists.setDividerLocation(width / 4);
+        return splitAllAndGenerated;
+    }
+
+    private static String bold(String s) {
+        return "<b>" + s + "</b>";
+    }
+
+}
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/controlpanel/desktopintegrationeditor/PreviewSelectionJTextPane.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/netx/net/sourceforge/jnlp/controlpanel/desktopintegrationeditor/PreviewSelectionJTextPane.java	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,155 @@
+/*   Copyright (C) 2015 Red Hat, Inc.
+
+ This file is part of IcedTea.
+
+ IcedTea is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, version 2.
+
+ IcedTea is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with IcedTea; see the file COPYING.  If not, write to
+ the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301 USA.
+
+ Linking this library statically or dynamically with other modules is
+ making a combined work based on this library.  Thus, the terms and
+ conditions of the GNU General Public License cover the whole
+ combination.
+
+ As a special exception, the copyright holders of this library give you
+ permission to link this library with independent modules to produce an
+ executable, regardless of the license terms of these independent
+ modules, and to copy and distribute the resulting executable under
+ terms of your choice, provided that you also meet, for each linked
+ independent module, the terms and conditions of the license of that
+ module.  An independent module is a module which is not derived from
+ or based on this library.  If you modify this library, you may extend
+ this exception to your version of the library, but you are not
+ obligated to do so.  If you do not wish to do so, delete this
+ exception statement from your version.
+ */
+package net.sourceforge.jnlp.controlpanel.desktopintegrationeditor;
+
+import java.io.File;
+import java.util.List;
+import javax.swing.JList;
+import javax.swing.JTextPane;
+import javax.swing.text.html.HTMLEditorKit;
+import net.sourceforge.jnlp.util.logging.OutputController;
+
+import static net.sourceforge.jnlp.runtime.Translator.R;
+
+public class PreviewSelectionJTextPane extends JTextPane {
+
+    private final JList iconsList;
+    private final JList menuList;
+    private final JList desktopList;
+    private final JList generatedList;
+
+    public PreviewSelectionJTextPane(JList iconsList, JList menuList, JList desktopList, JList generatedList) {
+        this.iconsList = iconsList;
+        this.menuList = menuList;
+        this.desktopList = desktopList;
+        this.generatedList = generatedList;
+        this.setEditorKit(new HTMLEditorKit());
+        this.setEditable(false);
+    }
+
+    private StringBuilder getMenus() {
+        return getTextFiles(menuList.getSelectedValuesList());
+    }
+
+    private StringBuilder getDesktops() {
+        return getTextFiles(desktopList.getSelectedValuesList());
+    }
+
+    private StringBuilder getGenerated() {
+        return getTextFiles(generatedList.getSelectedValuesList());
+    }
+
+    private StringBuilder getHeader(boolean i, boolean d, boolean m, boolean g) {
+        StringBuilder sb = new StringBuilder();
+        if (i || d || m || g) {
+            sb.append("<tr>");
+        }
+        if (i) {
+            sb.append("<th>").append(R("DIMicons")).append(":</th>");
+        }
+        if (d) {
+            sb.append("<th>").append(R("DIMdesktopItems")).append(":</th>");
+        }
+        if (m) {
+            sb.append("<th>").append(R("DIMmenuItems")).append(":</th>");
+        }
+        if (g) {
+            sb.append("<th>").append(R("DIMgeneratedJnlps")).append(":</th>");
+        }
+
+        if (i || d || m || g) {
+            sb.append("</tr>");
+        }
+        return sb;
+    }
+
+    public void generatePreview() {
+        try {
+            StringBuilder sb = new StringBuilder("<html><table>");
+            sb.append(getHeader(iconsList.getSelectedIndices().length > 0,
+                    menuList.getSelectedIndices().length > 0,
+                    desktopList.getSelectedIndices().length > 0,
+                    generatedList.getSelectedIndices().length > 0)).append("<tr>");
+            if (iconsList.getSelectedIndices().length > 0) {
+                sb.append("<td>").append(getIcons()).append("</td>");
+            }
+            if (menuList.getSelectedIndices().length > 0) {
+                sb.append("<td>").append(getMenus()).append("</td>");
+            }
+            if (desktopList.getSelectedIndices().length > 0) {
+                sb.append("<td>").append(getDesktops()).append("</td>");
+            }
+            if (generatedList.getSelectedIndices().length > 0) {
+                sb.append("<td>").append(getGenerated()).append("</td>");
+            }
+            sb.append("</tr></table></html>");
+            this.setText(sb.toString());
+
+        } catch (Exception ex) {
+            OutputController.getLogger().log(ex);
+        }
+
+    }
+
+    private StringBuilder getIcons() {
+        StringBuilder s = new StringBuilder();
+        try {
+            List l = iconsList.getSelectedValuesList();
+            for (Object l1 : l) {
+                File f = (File) l1;
+                s.append("<small>").append(f.getAbsolutePath()).append("</small><br>");
+                s.append("<img src='").append(f.toURI().toURL()).append("'></img><br>");
+
+            }
+        } catch (Exception ex) {
+            OutputController.getLogger().log(ex);
+        }
+        return s;
+    }
+
+    private StringBuilder getTextFiles(List selectedValuesList) {
+        StringBuilder s = new StringBuilder();
+        for (Object i : selectedValuesList) {
+            File f = (File) i;
+            s.append("<small>").append(f.getAbsolutePath()).append("</small><br>");
+            s.append("<pre>").append(FreeDesktopIntegrationEditorFrame.fileToString(f, true)).append("</pre><br>");
+
+        }
+        return s;
+
+    }
+
+}
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/resources/Messages.properties
--- a/netx/net/sourceforge/jnlp/resources/Messages.properties	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/resources/Messages.properties	Tue Jan 26 15:18:30 2016 +0100
@@ -559,6 +559,8 @@
 CPSecurityDescription=Use this to configure security settings.
 CPDebuggingDescription=Enable options here to help with debugging
 CPDesktopIntegrationDescription=Set whether or not to allow creation of desktop shortcut.
+CPDesktopIntegrationShowIntegrations=Show desktop and menu integrations window
+CPDesktopIntegrationLinuxOnly=Desktop integration manager available only for Linux. Sorry
 CPJVMPluginArguments=Set JVM arguments for plugin.
 CPJVMitwExec=Set JVM for IcedTea-Web \u2014 working best with OpenJDK
 CPJVMitwExecValidation=Validate JVM for IcedTea-Web
@@ -580,8 +582,8 @@
 CPJVMnoRtJar=Error, the directory you chose does not contain lib/rt.jar
 CPJVMrtJar=Ok, the directory you chose contains lib/rt.jar.
 CPJVMPluginAllowTTValidation=Validate JRE immediately
-CPJVMNotokMessage1=You have entered invalid JDK value <u>({0})</u> with following error message:
-CPJVMNotokMessage2=You might be seeing this message because: <blockquote> * Some validity tests have not been passed<br/> * Non-OpenJDK is detected</blockquote>With invalid JDK IcedTea-Web will probably not be able to start.<br/>You will have to modify or remove <u>{0}</u> property in your configuration file <u>{1}</u>. <br/>You should try to search for OpenJDK in your system or be sure you know what you are doing.
+CPJVMNotokMessage1=You have entered invalid JDK value: <ul><li><span color=''purple''>{0}</span></li></ul> with following error message:
+CPJVMNotokMessage2=You might be seeing this message because: <blockquote> * Some validity tests have not been passed<br/> * Non-OpenJDK is detected</blockquote>With invalid JDK IcedTea-Web will probably not be able to start.<br/><span color=''orange''>If it will break</span>, you have to modify or remove <u>{0}</u> property in your configuration file:  <ul><li><span color=''blue''>{1}</span></li></ul> You should  <span color=''green''><i>trust yours admin</i></span> or at least try to search for OpenJDK in your system or be sure you know what you are doing.
 CPJVMconfirmInvalidJdkTitle=Confirm invalid JDK
 CPJVMconfirmReset=Reset to default?
 CPPolicyDetail=View or edit your user-level Java Policy File. This allows you to grant or deny runtime permissions to applets regardless of the standard security sandboxing rules.
@@ -649,6 +651,10 @@
 DPEnableHeaders=Enable headers
 DPEnableHeadersHint=When this switch is on, each logged message have header with additional information like user, place in code  and time
 DPEnableFile=Enable logging to file
+DPEnableLegacyFileLog=Use java.util.logging instead of direct file writing
+DPEnableClientAppFileLogging=Fork client applications  outputs also to file
+DPEnableLegacyFileLogHint=java.util.logging is know to deadlock rarely when used on applications with custom logging extensions
+DPEnableClientAppFileLoggingHint=Logging of client apps is known to sometimes not work with java.util.logging on
 CPFilesLogsDestDir=File logs directory
 CPFilesLogsDestDirResert=Reset to default
 DPEnableFileHint=output messages will be saved to file in your {0}  directory
@@ -967,6 +973,37 @@
 CVCPColPath=Path
 CVCPColName=Name
 
+# Control Panel - desktop integration manager
+DIMtitle=IcedTea-Web Shortcut Manager
+DIMremoveSelected=Remove selected
+DIMselectRelativeRecordsFromOtherColumns=Select related records
+DIMreloadLists=Reload
+DIMselectAll=Select all
+DIMclearSelection=Deselect all
+DIMdescription=Manage the shorctuts and resources (cached images, etc) IcedTea-Web created for desktop integration
+DIMguessedDesktop=Desktop folder as well guessed as possible.
+DIMselectionPreview=Selection preview
+DIMaskBeforeDelete=Are you sure you want to delete {0} files?
+DIMgeneratedJnlps=Generated JNLPs
+DIMgeneratedJnlpsTooltip=All files in this list should be generated by IcedTea-Web!
+DIMicons=Icons
+DIMiconsTooltip=All files in this list should be icons cached by IcedTea-Web!
+DIMorphans=orphans
+DIMorphansTooltip=Will select all items which are not listed in any shortcut.
+DIMmenuItems=Menu Items
+DIMmenuItemsTooltip=All shortcuts in this list should be generated by IcedTea-Web!
+DIMdesktopItems=Desktop Items
+DIMdesktopItemsTooltipL1=Not all your shortcuts on your Desktop were generated by IcedTea-Web!
+DIMdesktopItemsTooltipL2=For your convenience:
+DIMdesktopItemsTooltipL3=red items were probably not generated by IcedTea-Web
+DIMdesktopItemsTooltipL4=dark green items are browser shortcuts, so they were probably generated by IcedTea-Web
+DIMdesktopItemsTooltipL5=green items are javaws shortcuts, so they were very likely generated by IcedTea-Web
+DIMdesktopItemsTooltipL6=In all cases, be careful what you delete, and verify connections with `select related records` mode
+DIMgeneratedButton=generated
+DIMgeneratedButtonTooltip=Will select related generated stuff.
+DIMiconsButton=icons
+DIMiconsButtonTooltip=Will select related cached icons.
+
 # Control Panel - Misc.
 CPJRESupport=IcedTea-Web currently does not support the use of multiple JREs.
 CPInvalidPort=Invalid port number given.\n[Valid port numbers are 1-65535]
@@ -1064,6 +1101,12 @@
 FILEopera64=Location of plugin library for global purposes  on opera compliant browser, 64-bit systems.
 FILEopera32=Location of plugin library for global purposes  on opera compliant browser, 32-bit systems.
 
+TAGSOUPtail=You may have missing tagsoup installation or your ITW was not built against it. Check your installation and/or consult distribution.
+TAGSOUPnotUsed"You are not using Malformed parser. If you have set {0}, remove it. Or...
+TAGSOUPbroken=Broken Malformed parser.
+TAGSOUPhtmlNotUsed=Tagsoup''s html2xml cleaning is Disabled. Remove {0}. Parsing will probably fail.
+TAGSOUPhtmlBroken=Tagsoup''s html2xml cleaning not loaded. Install tagsoup (and build ITW against). Parsing will probably fail.
+
 FILEcache=Contains cached runtime entries.
 FILErecentlyUsed=Additional information about items in cache
 FILEappdata=Contains saved application data.
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/resources/Messages_cs.properties
--- a/netx/net/sourceforge/jnlp/resources/Messages_cs.properties	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/resources/Messages_cs.properties	Tue Jan 26 15:18:30 2016 +0100
@@ -537,8 +537,8 @@
 CPJVMnoRtJar=Chyba: adres\u00e1\u0159, kter\u00fd jste vybrali, neobsahuje podadres\u00e1\u0159 a soubor \u201elib/rt.jar\u201c.
 CPJVMrtJar=OK, adres\u00e1\u0159, kter\u00fd jste vybrali, obsahuje podadres\u00e1\u0159 a soubor \u201elib/rt.jar\u201c.
 CPJVMPluginAllowTTValidation=Ov\u011b\u0159it prost\u0159ed\u00ed JRE ihned
-CPJVMNotokMessage1=Zadali jste neplatnou hodnotu <u>({0})</u> prost\u0159ed\u00ed JDK. Chybov\u00e1 zpr\u00e1va:
-CPJVMNotokMessage2=Tuto zpr\u00e1vu vid\u00edte pravd\u011bpodobn\u011b proto\u017ee: <blockquote> * V\u00e1\u0161 syst\u00e9m nepro\u0161el n\u011bkter\u00fdm z ov\u011b\u0159ovac\u00edch test\u016f<br/> * Bylo detekov\u00e1no jin\u00e9 prost\u0159ed\u00ed ne\u017e OpenJDK</blockquote>S neplatn\u00fdm prost\u0159ed\u00edm JDK nebude se pravd\u011bpodobn\u011b nebude aplikace IcedTea-Web schopna spustit.<br/>Budete muset upravit nebo odstranit vlastnost <u>{0}</u> ve va\u0161em konfigura\u010dn\u00edm souboru <u>{1}</u>. <br/> M\u011bli byste ve sv\u00e9m syst\u00e9mu nal\u00e9zt prost\u0159ed\u00ed OpenJDK, nebo byste m\u011bli dob\u0159e v\u011bd\u011bt, co d\u011bl\u00e1te.
+CPJVMNotokMessage1=Zadali jste neplatnou hodnotu: <ul><li><span color=''purple''>{0}</span></li></ul>  prost\u0159ed\u00ed JDK. Chybov\u00e1 zpr\u00e1va:
+CPJVMNotokMessage2=Tuto zpr\u00e1vu vid\u00edte pravd\u011bpodobn\u011b proto\u017ee: <blockquote> * V\u00e1\u0161 syst\u00e9m nepro\u0161el n\u011bkter\u00fdm z ov\u011b\u0159ovac\u00edch test\u016f<br/> * Bylo detekov\u00e1no jin\u00e9 prost\u0159ed\u00ed ne\u017e OpenJDK</blockquote>S neplatn\u00fdm prost\u0159ed\u00edm JDK nebude se pravd\u011bpodobn\u011b nebude aplikace IcedTea-Web schopna spustit.<br/><span color=''orange''>Pokud se ITW rozbije</span>, pudete muset upravit nebo odstranit vlastnost  <ul><li><span color=''blue''>{1}</span></li></ul> ve va\u0161em konfigura\u010dn\u00edm souboru <u>{1}</u>. <br/> <span color=''green''><i>Rad\u011bji v\u011b\u0159te sv\u00e9mu adminovi, </i></span> nebo aleso\u0148 ve sv\u00e9m syst\u00e9mu najd\u011bte prost\u0159ed\u00ed OpenJDK, nebo byste m\u011bli dob\u0159e v\u011bd\u011bt, co d\u011bl\u00e1te.
 CPJVMconfirmInvalidJdkTitle=Potvrzen\u00ed neplatn\u00e9ho prost\u0159ed\u00ed JDK
 CPJVMconfirmReset=Obnovit v\u00fdchoz\u00ed nastaven\u00ed?
 CPPolicyDetail=Zobrazen\u00ed nebo upravov\u00e1n\u00ed va\u0161eho u\u017eivatelsk\u00e9ho souboru se z\u00e1sadami prost\u0159ed\u00ed Java: Toto nastaven\u00ed v\u00e1m umo\u017en\u00ed ud\u011blit nebo odep\u0159\u00edt opr\u00e1vn\u011bn\u00ed modulu runtime pro aplet bez ohledu na standardn\u00ed bezpe\u010dnostn\u00ed pravidla pro pr\u00e1ci v izolovan\u00e9m prostoru (sandbox).
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/resources/Messages_de.properties
--- a/netx/net/sourceforge/jnlp/resources/Messages_de.properties	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/resources/Messages_de.properties	Tue Jan 26 15:18:30 2016 +0100
@@ -578,8 +578,8 @@
 CPJVMnoRtJar=Fehler: Das gew\u00e4hlte Verzeichnis enth\u00e4lt lib/rt.jar nicht.
 CPJVMrtJar=Das Verzeichnis enth\u00e4lt lib/rt.jar.
 CPJVMPluginAllowTTValidation=JRE sofort pr\u00fcfen
-CPJVMNotokMessage1=Es wurde der ung\u00fcltige JDK-Wert <u>({0})</u> mit folgender Fehlermeldung eingegeben:
-CPJVMNotokMessage2=M\u00f6gliche Gr\u00fcnde f\u00fcr diese Meldung sind:<blockquote> * Einige Pr\u00fcftests wurden nicht bestanden<br/> * Es wurde kein OpenJDK erkannt</blockquote>Wegen eines ungeeigneten JDKs wird IcedTea-Web wahrscheinlich nicht starten k\u00f6nnen.<br/>Die Eigenschaft <u>{0}</u> in der Konfigurationsdatei <u>{1}</u> m\u00fcsste angepasst oder entfernt werden.<br/>Es wird empfohlen nach OpenJDK auf diesem System zu suchen.
+CPJVMNotokMessage1=Es wurde der ung\u00fcltige JDK-Wert  <ul><li><span color=''purple''>{0}</span></li></ul> mit folgender Fehlermeldung eingegeben:
+CPJVMNotokMessage2=M\u00f6gliche Gr\u00fcnde f\u00fcr diese Meldung sind:<blockquote> * Einige Pr\u00fcftests wurden nicht bestanden<br/> * Es wurde kein OpenJDK erkannt</blockquote>Wegen eines ungeeigneten JDKs wird IcedTea-Web wahrscheinlich nicht starten k\u00f6nnen.<br/>Die Eigenschaft <u>{0}</u> in der Konfigurationsdatei  <ul><li><span color=''blue''>{1}</span></li></ul> m\u00fcsste angepasst oder entfernt werden.<br/>Es wird empfohlen nach OpenJDK auf diesem System zu suchen.
 CPJVMconfirmInvalidJdkTitle=Ungeeignetes JDK
 CPJVMconfirmReset=Auf Standard zur\u00fccksetzen?
 CPPolicyDetail=Die Java-Richtliniendatei des aktuellen Benutzers anschauen und bearbeiten.<br/>Dies erlaubt Laufzeitberechtigungen an Applets zu gew\u00e4hren oder abzulehnen, unabh\u00e4ngig von den Sandbox-Standardsicherheitsregeln.
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/resources/Messages_pl.properties
--- a/netx/net/sourceforge/jnlp/resources/Messages_pl.properties	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/resources/Messages_pl.properties	Tue Jan 26 15:18:30 2016 +0100
@@ -423,8 +423,8 @@
 CPJVMnoRtJar=B\u0142\u0105d: Wybrana \u015bcie\u017cka nie zawiera lib/rt.jar.
 CPJVMrtJar=Wybrana \u015bcie\u017cka zawiera lib/rt.jar.
 CPJVMPluginAllowTTValidation=Sprawd\u017a JRE bezzw\u0142ocznie
-CPJVMNotokMessage1=Wprowadzono nieprawid\u0142ow\u0105 warto\u015b\u0107 JDK <u>({0})</u> z nast\u0119puj\u0105cym komunikatem o b\u0142\u0119dzie:
-CPJVMNotokMessage2=Przyczyn\u0105 tego komunikatu mog\u0105 by\u0107:<blockquote> * Nie zaliczono niekt\u00f3rych sprawdzian\u00f3w<br/> * Wykryto inny ni\u017c OpenJDK</blockquote>Ze wzgl\u0119du na nieprawid\u0142owy JDK IcedTea-Web prawdopodobnie nie b\u0119dzie w stanie wystartowa\u0107.<br/>Trzeba b\u0119dzie dostosowa\u0107 lub usun\u0105\u0107 w\u0142a\u015bciwo\u015b\u0107 \u201e<u>{0}</u>\u201d w pliku konfiguracyjnym \u201e<u>{1}</u>\u201d.<br/>Przeszukaj system za OpenJDK.
+CPJVMNotokMessage1=Wprowadzono nieprawid\u0142ow\u0105 warto\u015b\u0107 JDK  <ul><li><span color=''purple''>{0}</span></li></ul> z nast\u0119puj\u0105cym komunikatem o b\u0142\u0119dzie:
+CPJVMNotokMessage2=Przyczyn\u0105 tego komunikatu mog\u0105 by\u0107:<blockquote> * Nie zaliczono niekt\u00f3rych sprawdzian\u00f3w<br/> * Wykryto inny ni\u017c OpenJDK</blockquote>Ze wzgl\u0119du na nieprawid\u0142owy JDK IcedTea-Web prawdopodobnie nie b\u0119dzie w stanie wystartowa\u0107.<br/>Trzeba b\u0119dzie dostosowa\u0107 lub usun\u0105\u0107 w\u0142a\u015bciwo\u015b\u0107 \u201e<u>{0}</u>\u201d w pliku konfiguracyjnym  <ul><li><span color=''blue''>{1}</span></li></ul><br/>Przeszukaj system za OpenJDK.
 CPJVMconfirmInvalidJdkTitle=Nieprawid\u0142owy JDK
 CPJVMconfirmReset=Przywr\u00f3ci\u0107 stan domy\u015blny?
 CPPolicyDetail=Przegl\u0105daj i edytuj plik u\u017cytkownika wytycznej Java. Pozwala na udzielanie lub odmawianie praw applet-om, niezale\u017cnie od standardowych regu\u0142 bezpiecze\u0144stwa piaskownicy.
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/runtime/JNLPClassLoader.java
--- a/netx/net/sourceforge/jnlp/runtime/JNLPClassLoader.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/runtime/JNLPClassLoader.java	Tue Jan 26 15:18:30 2016 +0100
@@ -318,7 +318,7 @@
 
     private void setSecurity() throws LaunchException {
         URL codebase = UrlUtils.guessCodeBase(file);
-        this.security = securityDelegate.getClassLoaderSecurity(codebase.getHost());
+        this.security = securityDelegate.getClassLoaderSecurity(codebase);
     }
 
     /**
@@ -754,7 +754,7 @@
             validJars.add(jarDesc);
             final URL codebase = getJnlpFileCodebase();
 
-            final SecurityDesc jarSecurity = securityDelegate.getCodebaseSecurityDesc(jarDesc, codebase.getHost());
+            final SecurityDesc jarSecurity = securityDelegate.getCodebaseSecurityDesc(jarDesc, codebase);
             if (jarSecurity.getSecurityType().equals(SecurityDesc.SANDBOX_PERMISSIONS)) {
                 containsUnsignedJar = true;
             } else {
@@ -778,7 +778,7 @@
 
         for (JARDesc jarDesc : validJars) {
             final URL codebase = getJnlpFileCodebase();
-            final SecurityDesc jarSecurity = securityDelegate.getCodebaseSecurityDesc(jarDesc, codebase.getHost());
+            final SecurityDesc jarSecurity = securityDelegate.getCodebaseSecurityDesc(jarDesc, codebase);
             jarLocationSecurityMap.put(jarDesc.getLocation(), jarSecurity);
         }
 
@@ -1188,7 +1188,7 @@
 
             // Class from host X should be allowed to connect to host X
             if (cs.getLocation() != null && cs.getLocation().getHost().length() > 0)
-                result.add(new SocketPermission(cs.getLocation().getHost(),
+                result.add(new SocketPermission(UrlUtils.getHostAndPort(cs.getLocation()),
                         "connect, accept"));
 
             return result;
@@ -1302,7 +1302,7 @@
                                             codebase = file.getResources().getMainJAR().getLocation();
                                         }
                                         
-                                        final SecurityDesc jarSecurity = securityDelegate.getJarPermissions(codebase.getHost());
+                                        final SecurityDesc jarSecurity = securityDelegate.getJarPermissions(codebase);
                                         
                                         try {
                                             URL fileURL = new URL("file://" + extractedJarLocation);
@@ -1630,7 +1630,7 @@
 
                     checkTrustWithUser();
 
-                    final SecurityDesc security = securityDelegate.getJarPermissions(file.getCodeBase().getHost());
+                    final SecurityDesc security = securityDelegate.getJarPermissions(file.getCodeBase());
 
                     jarLocationSecurityMap.put(remoteURL, security);
 
@@ -2162,7 +2162,7 @@
         if (foundLoader != null)
             approved = true;
 
-        else if (ref.toString().startsWith(file.getCodeBase().toString()))
+        else if (ref.toString().startsWith(file.getNotNullProbalbeCodeBase().toString()))
             approved = true;
         else if (SecurityDesc.ALL_PERMISSIONS.equals(security.getSecurityType()))
             approved = true;
@@ -2249,7 +2249,7 @@
         // Permissions for all remote hosting urls
         synchronized (jarLocationSecurityMap) {
             for (URL u : jarLocationSecurityMap.keySet()) {
-                permissions.add(new SocketPermission(u.getHost(),
+                    permissions.add(new SocketPermission(UrlUtils.getHostAndPort(u),
                         "connect, accept"));
             }
         }
@@ -2257,7 +2257,7 @@
         // Permissions for codebase urls (if there is a loader)
         if (codeBaseLoader != null) {
             for (URL u : codeBaseLoader.getURLs()) {
-                permissions.add(new SocketPermission(u.getHost(),
+                permissions.add(new SocketPermission(UrlUtils.getHostAndPort(u),
                         "connect, accept"));
             }
         }
@@ -2290,11 +2290,11 @@
 
         public boolean userPromptedForSandbox();
 
-        public SecurityDesc getCodebaseSecurityDesc(final JARDesc jarDesc, final String codebaseHost);
-
-        public SecurityDesc getClassLoaderSecurity(final String codebaseHost) throws LaunchException;
-
-        public SecurityDesc getJarPermissions(final String codebaseHost);
+        public SecurityDesc getCodebaseSecurityDesc(final JARDesc jarDesc, final URL codebaseHost);
+
+        public SecurityDesc getClassLoaderSecurity(final URL codebaseHost) throws LaunchException;
+
+        public SecurityDesc getJarPermissions(final URL codebaseHost);
 
         public void promptUserOnPartialSigning() throws LaunchException;
 
@@ -2331,7 +2331,7 @@
         }
 
         @Override
-        public SecurityDesc getCodebaseSecurityDesc(final JARDesc jarDesc, final String codebaseHost) {
+        public SecurityDesc getCodebaseSecurityDesc(final JARDesc jarDesc, final URL codebaseHost) {
             if (runInSandbox) {
                 return new SecurityDesc(classLoader.file,
                         SecurityDesc.SANDBOX_PERMISSIONS,
@@ -2361,7 +2361,7 @@
         }
 
         @Override
-        public SecurityDesc getClassLoaderSecurity(final String codebaseHost) throws LaunchException {
+        public SecurityDesc getClassLoaderSecurity(final URL codebaseHost) throws LaunchException {
             if (isPluginApplet()) {
                 if (!runInSandbox && classLoader.getSigning()) {
                     return new SecurityDesc(classLoader.file,
@@ -2403,7 +2403,7 @@
         }
 
         @Override
-        public SecurityDesc getJarPermissions(final String codebaseHost) {
+        public SecurityDesc getJarPermissions(final URL codebaseHost) {
             if (!runInSandbox && classLoader.jcv.isFullySigned()) {
                 // Already trust application, nested jar should be given
                 return new SecurityDesc(classLoader.file,
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/runtime/JNLPRuntime.java
--- a/netx/net/sourceforge/jnlp/runtime/JNLPRuntime.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/runtime/JNLPRuntime.java	Tue Jan 26 15:18:30 2016 +0100
@@ -67,6 +67,7 @@
 import net.sourceforge.jnlp.security.SecurityDialogMessageHandler;
 import net.sourceforge.jnlp.security.SecurityUtil;
 import net.sourceforge.jnlp.services.XServiceManagerStub;
+import net.sourceforge.jnlp.util.BasicExceptionDialog;
 import net.sourceforge.jnlp.util.FileUtils;
 import net.sourceforge.jnlp.util.logging.JavaConsole;
 import net.sourceforge.jnlp.util.logging.LogConfig;
@@ -880,7 +881,14 @@
     }
 
     public static void exit(int i) {
-        OutputController.getLogger().close();
+        try {
+            OutputController.getLogger().close();
+            while (BasicExceptionDialog.areShown()){
+                Thread.sleep(100);
+            }
+        } catch (Exception ex) {
+            //to late
+        }
         System.exit(i);
     }
 
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/runtime/ManifestAttributesChecker.java
--- a/netx/net/sourceforge/jnlp/runtime/ManifestAttributesChecker.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/runtime/ManifestAttributesChecker.java	Tue Jan 26 15:18:30 2016 +0100
@@ -282,7 +282,7 @@
                 throw new LaunchException("Your Extended applets security is at 'Very high', and this application is missing the 'permissions' attribute in manifest. This is fatal");
             }
             if (itwSecurityLevel == AppletSecurityLevel.ASK_UNSIGNED) {
-                final boolean userApproved = SecurityDialogs.showMissingPermissionsAttributeDialogue(file.getTitle(), file.getCodeBase());
+                final boolean userApproved = SecurityDialogs.showMissingPermissionsAttributeDialogue(file.getTitle(), file.getNotNullProbalbeCodeBase().toExternalForm());
                 if (!userApproved) {
                     throw new LaunchException("Your Extended applets security is at 'high' and this application is missing the 'permissions' attribute in manifest. And you have refused to run it.");
                 } else {
@@ -407,7 +407,7 @@
             att = file.getManifestsAttributes().getApplicationLibraryAllowableCodebase();
         }
         if (att == null) {
-            final boolean userApproved = SecurityDialogs.showMissingALACAttributePanel(file.getTitle(), documentBase, usedUrls);
+            final boolean userApproved = SecurityDialogs.showMissingALACAttributePanel(file.getTitle(), file.getNotNullProbalbeCodeBase(), usedUrls);
             if (!userApproved) {
                 throw new LaunchException("The application uses non-codebase resources, has no Application-Library-Allowable-Codebase Attribute, and was blocked from running by the user");
             } else {
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/runtime/html/AppletExtractor.java
--- a/netx/net/sourceforge/jnlp/runtime/html/AppletExtractor.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/runtime/html/AppletExtractor.java	Tue Jan 26 15:18:30 2016 +0100
@@ -46,10 +46,12 @@
 import javax.xml.parsers.ParserConfigurationException;
 import net.sourceforge.jnlp.JNLPFile;
 import net.sourceforge.jnlp.OptionsDefinitions;
+import net.sourceforge.jnlp.ParseException;
 import net.sourceforge.jnlp.Parser;
 import net.sourceforge.jnlp.ParserSettings;
 import net.sourceforge.jnlp.cache.UpdatePolicy;
 import net.sourceforge.jnlp.runtime.JNLPRuntime;
+import net.sourceforge.jnlp.runtime.Translator;
 import net.sourceforge.jnlp.util.logging.OutputController;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
@@ -88,14 +90,14 @@
     private InputStream cleanStreamIfPossible(InputStream is) {
         try {
             if (ps != null && ps.isMalformedXmlAllowed()){
-                Class<?> klass = Class.forName(Parser.MALFORMED_PARSER_CLASS);
-                Method m = klass.getMethod("xmlizeInputStream", InputStream.class);
+                Object parser = Parser.getParserInstance(ps);
+                Method m = parser.getClass().getMethod("xmlizeInputStream", InputStream.class);
                 return (InputStream) m.invoke(null, is);
             } else {
-                OutputController.getLogger().log(OutputController.Level.WARNING_DEBUG, "Tagsoup's html2xml cleaning is Disabled. Remove "+OptionsDefinitions.OPTIONS.XML.option+". Parsing will probably fail.");    
+                OutputController.getLogger().log(OutputController.Level.WARNING_ALL, Translator.R("TAGSOUPhtmlNotUsed", OptionsDefinitions.OPTIONS.XML.option));    
             }
         } catch (Exception ex) {
-            OutputController.getLogger().log(OutputController.Level.WARNING_DEBUG, "Tagsoup's html2xml cleaning not loaded. Install tagsoup. Parsing will probably fail.");
+            OutputController.getLogger().log(OutputController.Level.WARNING_ALL, Translator.R("TAGSOUPhtmlBroken"));
             OutputController.getLogger().log(ex);
         }
         return is;
@@ -104,7 +106,9 @@
     public List<Element> findAppletsOnPage() {
         try{
         return findAppletsOnPageImpl(openDocument(cleanStreamIfPossible(JNLPFile.openURL(html, null, UpdatePolicy.ALWAYS))));
-        }catch (IOException | SAXException | ParserConfigurationException ex){
+        } catch (SAXException sex) {
+            throw new RuntimeException(new ParseException(sex));
+        } catch (IOException | ParserConfigurationException ex) {
             throw new RuntimeException(ex);
         }
     }
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/security/SecurityDialogs.java
--- a/netx/net/sourceforge/jnlp/security/SecurityDialogs.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/security/SecurityDialogs.java	Tue Jan 26 15:18:30 2016 +0100
@@ -441,7 +441,7 @@
         }
     }
 
-     public static boolean showMissingPermissionsAttributeDialogue(String title, URL codeBase) {
+     public static boolean showMissingPermissionsAttributeDialogue(String title, String codeBase) {
 
          if (!shouldPromptUser()) {
              if (JNLPRuntime.isTrustAll()) {
@@ -453,7 +453,7 @@
 
          SecurityDialogMessage message = new SecurityDialogMessage();
          message.dialogType = DialogType.UNSIGNED_EAS_NO_PERMISSIONS_WARNING;
-         message.extras = new Object[]{title, codeBase.toExternalForm()};
+         message.extras = new Object[]{title, codeBase};
          Object selectedValue = getUserResponse(message);
          return SecurityDialogs.getIntegerResponseAsBoolean(selectedValue);
     }
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/security/appletextendedsecurity/UnsignedAppletTrustConfirmation.java
--- a/netx/net/sourceforge/jnlp/security/appletextendedsecurity/UnsignedAppletTrustConfirmation.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/security/appletextendedsecurity/UnsignedAppletTrustConfirmation.java	Tue Jan 26 15:18:30 2016 +0100
@@ -36,7 +36,6 @@
 
 package net.sourceforge.jnlp.security.appletextendedsecurity;
 
-import java.net.MalformedURLException;
 import static net.sourceforge.jnlp.runtime.Translator.R;
 
 import java.net.URL;
@@ -49,8 +48,8 @@
 import net.sourceforge.jnlp.JNLPFile;
 import net.sourceforge.jnlp.LaunchException;
 import net.sourceforge.jnlp.PluginBridge;
+import net.sourceforge.jnlp.runtime.JNLPClassLoader.SecurityDelegate;
 import net.sourceforge.jnlp.runtime.JNLPRuntime;
-import net.sourceforge.jnlp.runtime.JNLPClassLoader.SecurityDelegate;
 import net.sourceforge.jnlp.security.dialogs.apptrustwarningpanel.AppTrustWarningPanel.AppSigningWarningAction;
 import net.sourceforge.jnlp.security.CertVerifier;
 import net.sourceforge.jnlp.security.SecurityDialogs;
@@ -111,8 +110,8 @@
     private static UnsignedAppletActionEntry getMatchingItem(UnsignedAppletActionStorage actionStorage, JNLPFile file, int id) {
         return actionStorage.getMatchingItem(
                 UrlUtils.normalizeUrlAndStripParams(file.getSourceLocation(), true /* encode local files */).toString(), 
-                UrlUtils.normalizeUrlAndStripParams(file.getCodeBase(), true /* encode local files */).toString(), 
-                toRelativePaths(getJars(file), file.getCodeBase().toString()), id);
+                UrlUtils.normalizeUrlAndStripParams(file.getNotNullProbalbeCodeBase(), true /* encode local files */).toString(), 
+                toRelativePaths(getJars(file), file.getNotNullProbalbeCodeBase().toExternalForm()), id);
     }
 
     /* Extract the archives as relative paths */
@@ -135,17 +134,17 @@
         try {
             UnsignedAppletActionEntry oldEntry = getMatchingItem(userActionStorage, file, id);
 
-            URL codebase = UrlUtils.normalizeUrlAndStripParams(file.getCodeBase(), true /* encode local files */);
+            URL codebase = UrlUtils.normalizeUrlAndStripParams(file.getNotNullProbalbeCodeBase(), true /* encode local files */);
             URL documentbase = UrlUtils.normalizeUrlAndStripParams(file.getSourceLocation(), true /* encode local files */);
 
             /* Else, create a new entry */
             UrlRegEx codebaseRegex = UrlRegEx.quote(codebase.toExternalForm());
-            UrlRegEx documentbaseRegex = UrlRegEx.quoteAndStar(stripFile(documentbase)); // Match any from codebase and sourceFile "base"
+            UrlRegEx documentbaseRegex = UrlRegEx.quoteAndStar(UrlUtils.stripFile(documentbase)); // Match any from codebase and sourceFile "base"
             List<String> archiveMatches = null; // Match any from codebase
 
             if (!rememberForCodeBase) { 
                 documentbaseRegex = UrlRegEx.quote(documentbase.toExternalForm()); // Match only this applet
-                archiveMatches = toRelativePaths(getJars(file), file.getCodeBase().toString()); // Match only this applet
+                archiveMatches = toRelativePaths(getJars(file), file.getNotNullProbalbeCodeBase().toString()); // Match only this applet
             }
             
             /* Update, if entry exists */
@@ -278,48 +277,4 @@
 
     }
 
-    static String stripFile(URL documentbase) {
-        //whenused in generation of regec, the trailing slash is very important
-        //see the result between http:/some.url/path.* and http:/some.url/path/.*
-        return ensureSlashTail(stripFileImp(documentbase));
-    }
-    
-    private static String stripFileImp(URL documentbase) {
-        try {
-            String normalized = UrlUtils.normalizeUrlAndStripParams(documentbase).toExternalForm().trim();
-            if (normalized.endsWith("/") || normalized.endsWith("\\")) {
-                return normalized;
-            }
-            URL middleway = new URL(normalized);
-            String file = middleway.getFile();
-            int i = Math.max(file.lastIndexOf('/'), file.lastIndexOf('\\'));
-            if (i<0){
-                return normalized;
-            }
-            String parent = file.substring(0, i+1);
-            String stripped = normalized.replace(file, parent);
-            return stripped;
-        } catch (Exception ex) {
-            OutputController.getLogger().log(ex);
-            return documentbase.toExternalForm();
-        }
-
-    }
-
-    private static String ensureSlashTail(String s) {
-        if (s.endsWith("/")) {
-            return s;
-        }
-        if (s.endsWith("\\")) {
-            return s;
-        }
-        if (s.contains("/")) {
-            return s + "/";
-        }
-        if (s.contains("\\")) {
-            return s + "\\";
-        }
-        return s + "/";
-    }
-
 }
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/security/dialogs/CertsInfoPane.java
--- a/netx/net/sourceforge/jnlp/security/dialogs/CertsInfoPane.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/security/dialogs/CertsInfoPane.java	Tue Jan 26 15:18:30 2016 +0100
@@ -43,8 +43,15 @@
 import java.security.cert.CertPath;
 import java.security.cert.X509Certificate;
 import java.security.MessageDigest;
+/**
+ * Do not remove this two unused imports, nor expands its "*" call.
+ * It is workaround to allow itw to run on jdk8 and older and also on jdk9 and newer
+ */
 
-import sun.misc.HexDumpEncoder;
+// jdk8 is using sun.misc.HexDumpEncoder, 
+import sun.misc.*;
+// jdk9 is using sun.security.util.HexDumpEncoder
+import sun.security.util.*;
 import sun.security.x509.*;
 import javax.swing.*;
 import javax.swing.event.*;
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/security/dialogs/SecurityDialogPanel.java
--- a/netx/net/sourceforge/jnlp/security/dialogs/SecurityDialogPanel.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/security/dialogs/SecurityDialogPanel.java	Tue Jan 26 15:18:30 2016 +0100
@@ -71,7 +71,7 @@
     /**
      * Needed to get word wrap working in JLabels.
      */
-    protected String htmlWrap(String s) {
+    public  static String htmlWrap(String s) {
         return "<html>" + s + "</html>";
     }
 
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/security/dialogs/TemporaryPermissionsButton.java
--- a/netx/net/sourceforge/jnlp/security/dialogs/TemporaryPermissionsButton.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/security/dialogs/TemporaryPermissionsButton.java	Tue Jan 26 15:18:30 2016 +0100
@@ -174,7 +174,7 @@
                 policyEditorWindow.asWindow().repaint();
             }
             policyEditorWindow.setModalityType(ModalityType.DOCUMENT_MODAL);
-            policyEditorWindow.getPolicyEditor().addNewCodebase(file.getCodeBase().toString());
+            policyEditorWindow.getPolicyEditor().addNewCodebase(file.getNotNullProbalbeCodeBase().toString());
             policyEditorWindow.asWindow().setVisible(true);
             menu.setVisible(false);
         }
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/security/dialogs/apptrustwarningpanel/PartiallySignedAppTrustWarningPanel.java
--- a/netx/net/sourceforge/jnlp/security/dialogs/apptrustwarningpanel/PartiallySignedAppTrustWarningPanel.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/security/dialogs/apptrustwarningpanel/PartiallySignedAppTrustWarningPanel.java	Tue Jan 26 15:18:30 2016 +0100
@@ -100,7 +100,7 @@
 
         try {
             if (file instanceof PluginBridge) {
-                from = file.getCodeBase().toExternalForm();
+                from = file.getNotNullProbalbeCodeBase().toExternalForm();
             } else {
                 from = file.getInformation().getHomepage().toExternalForm();
             }
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/security/package-info.java
--- a/netx/net/sourceforge/jnlp/security/package-info.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/security/package-info.java	Tue Jan 26 15:18:30 2016 +0100
@@ -32,6 +32,7 @@
 statement from your version.*/
 /**
  *<pre>
+{@code
         ITW-thread(s)               | dialogs-thread                                                                                                                                  X
                                     |                                                                                                                                                 X
    presteps in SecurtyDialogs       |                                                                                                                                                 X
@@ -75,7 +76,7 @@
             |                       |                                                                                                                                                 X
    continue accordingly             |                                                                                                                                                 X
                                                                                                                                                                                       X
-
+}
  *</pre>
  */
 package net.sourceforge.jnlp.security;
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/security/policyeditor/PolicyEditorPermissions.java
--- a/netx/net/sourceforge/jnlp/security/policyeditor/PolicyEditorPermissions.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/security/policyeditor/PolicyEditorPermissions.java	Tue Jan 26 15:18:30 2016 +0100
@@ -193,6 +193,11 @@
             return false;
         }
 
+        /**
+         * Return title for policy extended by drop-down mark.
+         *
+         * @return title with down-pointing arrow
+         */
         public String getTitle() {
             return title + " ˇ";
         }
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/tools/ico/impl/IcoException.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/netx/net/sourceforge/jnlp/tools/ico/impl/IcoException.java	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,46 @@
+/*
+ Copyright (C) 2015 Red Hat, Inc.
+
+ This file is part of IcedTea.
+
+ IcedTea is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+
+ IcedTea is distributed in the hope that it will be useful, but
+ WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with IcedTea; see the file COPYING.  If not, write to the
+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301 USA.
+
+ Linking this library statically or dynamically with other modules is
+ making a combined work based on this library.  Thus, the terms and
+ conditions of the GNU General Public License cover the whole
+ combination.
+
+ As a special exception, the copyright holders of this library give you
+ permission to link this library with independent modules to produce an
+ executable, regardless of the license terms of these independent
+ modules, and to copy and distribute the resulting executable under
+ terms of your choice, provided that you also meet, for each linked
+ independent module, the terms and conditions of the license of that
+ module.  An independent module is a module which is not derived from
+ or based on this library.  If you modify this library, you may extend
+ this exception to your version of the library, but you are not
+ obligated to do so.  If you do not wish to do so, delete this
+ exception statement from your version. */
+package net.sourceforge.jnlp.tools.ico.impl;
+
+
+class IcoException extends Exception {
+
+    public IcoException(String string) {
+        super(string);
+    }
+
+}
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/tools/ico/impl/IcoHeader.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/netx/net/sourceforge/jnlp/tools/ico/impl/IcoHeader.java	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,87 @@
+/*
+ Copyright (C) 2015 Red Hat, Inc.
+
+ This file is part of IcedTea.
+
+ IcedTea is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+
+ IcedTea is distributed in the hope that it will be useful, but
+ WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with IcedTea; see the file COPYING.  If not, write to the
+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301 USA.
+
+ Linking this library statically or dynamically with other modules is
+ making a combined work based on this library.  Thus, the terms and
+ conditions of the GNU General Public License cover the whole
+ combination.
+
+ As a special exception, the copyright holders of this library give you
+ permission to link this library with independent modules to produce an
+ executable, regardless of the license terms of these independent
+ modules, and to copy and distribute the resulting executable under
+ terms of your choice, provided that you also meet, for each linked
+ independent module, the terms and conditions of the license of that
+ module.  An independent module is a module which is not derived from
+ or based on this library.  If you modify this library, you may extend
+ this exception to your version of the library, but you are not
+ obligated to do so.  If you do not wish to do so, delete this
+ exception statement from your version. */
+package net.sourceforge.jnlp.tools.ico.impl;
+
+import java.io.IOException;
+import java.nio.ByteOrder;
+import java.util.ArrayList;
+import java.util.List;
+import javax.imageio.stream.ImageInputStream;
+
+/**
+ * http://www.daubnet.com/en/file-format-ico
+ */
+public class IcoHeader {
+
+    private final int reserved; //0
+    private final int type; //should be 1 (0 is for cusrsor?)
+    final int countOfIcons;
+    final List<IcoHeaderEntry> entries; //size 16*countOfIcons bytes
+    private final ByteOrder originalOrder;
+
+    public IcoHeader(ImageInputStream src) throws IOException, IcoException {
+        originalOrder = src.getByteOrder();
+        try {
+            src.setByteOrder(ByteOrder.LITTLE_ENDIAN);
+            reserved = src.readUnsignedShort();
+            type = src.readUnsignedShort();
+            isIco();
+            countOfIcons = src.readUnsignedShort();
+            entries = new ArrayList<>(countOfIcons);
+            for (int x = 0; x < countOfIcons; x++) {
+                entries.add(new IcoHeaderEntry(src));
+            }
+        } finally {
+            src.setByteOrder(originalOrder);
+        }
+    }
+
+    private void isIco() throws IcoException {
+        if (reserved != 0 || (type != 1)) {
+            throw new IcoException("Invalid header. Expected 0 and 1, got " + reserved + " and " + type);
+        }
+    }
+
+    public List<IcoHeaderEntry> getEntries() {
+        return entries;
+    }
+
+    public int getCountOfIcons() {
+        return countOfIcons;
+    }
+
+}
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/tools/ico/impl/IcoHeaderEntry.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/netx/net/sourceforge/jnlp/tools/ico/impl/IcoHeaderEntry.java	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,143 @@
+package net.sourceforge.jnlp.tools.ico.impl;
+
+/*
+ Copyright (C) 2015 Red Hat, Inc.
+
+ This file is part of IcedTea.
+
+ IcedTea is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+
+ IcedTea is distributed in the hope that it will be useful, but
+ WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with IcedTea; see the file COPYING.  If not, write to the
+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301 USA.
+
+ Linking this library statically or dynamically with other modules is
+ making a combined work based on this library.  Thus, the terms and
+ conditions of the GNU General Public License cover the whole
+ combination.
+
+ As a special exception, the copyright holders of this library give you
+ permission to link this library with independent modules to produce an
+ executable, regardless of the license terms of these independent
+ modules, and to copy and distribute the resulting executable under
+ terms of your choice, provided that you also meet, for each linked
+ independent module, the terms and conditions of the license of that
+ module.  An independent module is a module which is not derived from
+ or based on this library.  If you modify this library, you may extend
+ this exception to your version of the library, but you are not
+ obligated to do so.  If you do not wish to do so, delete this
+ exception statement from your version. */
+import java.io.IOException;
+import javax.imageio.stream.ImageInputStream;
+
+public class IcoHeaderEntry {
+
+    private int width;
+    private int height;
+    private int colorCount;
+    private final int reserved;
+    private final int planes; //should be 1 but  I met quite a lot of  0
+    private final int bitCount;
+    private final int sizeInBytes; // InfoHeader + ANDbitmap + XORbitmap
+    private final int fileOffset; //FilePos, where InfoHeader starts
+
+    public IcoHeaderEntry(ImageInputStream src) throws IOException, IcoException {
+        width = src.read();
+        height = src.read();
+        colorCount = src.read();
+        // sentence "Number of Colors (2,16, 0=256) " is form doubnet
+        //unluckily, both  0==0 and 0==256 does exists
+        //going with doubnet by default
+        if (colorCount == 0) {
+            colorCount = 256;
+        }
+        reserved = src.read();
+        planes = src.readUnsignedShort();
+        isIcoHeader();
+        bitCount = src.readUnsignedShort();
+        sizeInBytes = src.readInt();
+        fileOffset = src.readInt();
+    }
+
+    private IcoHeaderEntry(int width, int height, int colorCount, int planes, int bitCount, int sizeInBytes, int fileOffset) {
+        this.width = width;
+        this.height = height;
+        this.colorCount = colorCount;
+        this.reserved = 0;
+        this.planes = planes;
+        this.bitCount = bitCount;
+        this.sizeInBytes = sizeInBytes;
+        this.fileOffset = fileOffset;
+    }
+
+    private IcoHeaderEntry provideMonochromeHeader() {
+        //each bit in byte stores 8 pixels values
+        return new IcoHeaderEntry(width, height, 1, planes, 1, width * height / 8, fileOffset + sizeInBytes);
+    }
+
+    private void isIcoHeader() throws IcoException {
+        if (reserved != 0 || (planes != 1 && planes != 0)) {
+            throw new IcoException("Invalid header. Expected 0 and 1(0?), got " + reserved + " and " + planes);
+        }
+    }
+
+    /**
+     * @return the colorCount
+     */
+    int getColorCount() {
+        return colorCount;
+    }
+
+    /**
+     * @param colorCount the colorCount to set
+     */
+    void setColorCount(int colorCount) {
+        this.colorCount = colorCount;
+    }
+
+    /**
+     * @return the width
+     */
+    public int getWidth() {
+        return width;
+    }
+
+    /**
+     * @param width the width to set
+     */
+    void setWidth(int width) {
+        this.width = width;
+    }
+
+    /**
+     * @return the height
+     */
+    public int getHeight() {
+        return height;
+    }
+
+    /**
+     * @param height the height to set
+     */
+    void setHeight(int height) {
+        this.height = height;
+    }
+
+    int getSizeInBytes() {
+        return sizeInBytes;
+    }
+
+    int getFileOffset() {
+        return fileOffset;
+    }
+
+}
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/tools/ico/impl/ImageInputStreamIco.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/netx/net/sourceforge/jnlp/tools/ico/impl/ImageInputStreamIco.java	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,170 @@
+/*
+ Copyright (C) 2015 Red Hat, Inc.
+
+ This file is part of IcedTea.
+
+ IcedTea is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+
+ IcedTea is distributed in the hope that it will be useful, but
+ WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with IcedTea; see the file COPYING.  If not, write to the
+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301 USA.
+
+ Linking this library statically or dynamically with other modules is
+ making a combined work based on this library.  Thus, the terms and
+ conditions of the GNU General Public License cover the whole
+ combination.
+
+ As a special exception, the copyright holders of this library give you
+ permission to link this library with independent modules to produce an
+ executable, regardless of the license terms of these independent
+ modules, and to copy and distribute the resulting executable under
+ terms of your choice, provided that you also meet, for each linked
+ independent module, the terms and conditions of the license of that
+ module.  An independent module is a module which is not derived from
+ or based on this library.  If you modify this library, you may extend
+ this exception to your version of the library, but you are not
+ obligated to do so.  If you do not wish to do so, delete this
+ exception statement from your version. */
+package net.sourceforge.jnlp.tools.ico.impl;
+
+import java.awt.image.BufferedImage;
+import java.io.ByteArrayInputStream;
+import java.io.EOFException;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import javax.imageio.ImageIO;
+import javax.imageio.stream.ImageInputStream;
+
+public class ImageInputStreamIco {
+
+    private final IcoHeader header;
+    private final List<BufferedImage> images; //size 16*countOfIcons bytes
+
+    public IcoHeader getHeader() {
+        return header;
+    }
+
+    public BufferedImage getImage(int i) {
+        return images.get(i);
+    }
+
+    public ImageInputStreamIco(ImageInputStream src) throws IOException, IcoException {
+        this.header = new IcoHeader(src);
+        images = new ArrayList<>(header.countOfIcons);
+        for (IcoHeaderEntry e : header.entries) {
+            BufferedImage image = readImage(e, src);
+            images.add(image);
+        }
+    }
+
+    private static void readMask(IcoHeaderEntry e, ImageInputStream src1) throws IOException {
+        //acording to spec, behind img bytes, should be another bytes, with AND bitmap.Hoewer, I had not found them.
+        //however, that means, that transaprency is lost... But bit offsets mathces.. so...
+        //IcoHeader.IcoHeaderEntry q = e.provideMonochromeHeader();
+        //src1.getStreamPosition();
+        //byte[] mask = new byte[q.sizeInBytes];
+        //src1.readFully(mask);
+    }
+
+    private static BufferedImage readImage(IcoHeaderEntry e, ImageInputStream src1) throws IOException {
+        BufferedImage image;
+        byte[] img = new byte[e.getSizeInBytes()];
+        if (src1.getStreamPosition() != e.getFileOffset()) {
+            //I had never seen this thrown, Still, is it worthy to tempt it, or rather read and die later?
+            //throw new IOException("Stream position do nto match expected position. Bmp(or png) will read wrongly");
+        }
+        src1.readFully(img);
+        try {
+            image = parse(img, e);
+            //readMask(e, src1);
+        } catch (EOFException ex) {
+            //some icons do not honour that 0 is 256. Retrying
+            if (e.getColorCount() != 0) {
+                e.setColorCount(0);
+                image = parse(img, e);
+                //readMask(e, src1);
+            } else {
+                throw ex;
+            }
+        }
+        return image;
+    }
+
+    private static BufferedImage parse(byte[] img, IcoHeaderEntry e) throws IOException {
+        ByteArrayInputStream bis = new ByteArrayInputStream(img);
+        BufferedImage image = null;
+        try {
+            image = ImageIO.read(bis);
+        } catch (Exception ex) {
+            //not png
+        }
+        if (image != null) {
+            fixSizesInHeader(e, image);
+            return image;
+        }
+        //bmp
+        img = prefixByFakeHeader(img, e);
+        bis = new ByteArrayInputStream(img);
+        //dont try catch this one. you will break it
+        image = ImageIO.read(bis);
+
+        return image;
+    }
+
+    private static void fixSizesInHeader(IcoHeaderEntry e, BufferedImage image) {
+        //may happen for png
+        if (e.getWidth() == 0) {
+            e.setWidth(image.getWidth());
+        }
+        if (e.getHeight() == 0) {
+            e.setHeight(image.getHeight());
+        }
+    }
+
+    private static byte[] prefixByFakeHeader(final byte[] origArray, IcoHeaderEntry e) {
+        int fakingArray = 14;
+        byte[] img = new byte[fakingArray + e.getSizeInBytes()];
+        for (int i = 0; i < origArray.length; i++) {
+            byte p = origArray[i];
+            img[i + 14] = p;
+
+        }
+        //fake header
+        //http://www.daubnet.com/en/file-format-bmp
+        int size = e.getSizeInBytes() + fakingArray;
+        img[0] = 'B';
+        img[1] = 'M';
+        img[2] = (byte) (size & 0xFF);
+        img[3] = (byte) ((size >> 8) & 0xFF);
+        img[4] = (byte) ((size >> 16) & 0xFF);
+        img[5] = (byte) ((size >> 24) & 0xFF);
+        img[6] = 0;
+        img[7] = 0;
+        img[8] = 0;
+        img[9] = 0;
+        int ofset = fakingArray + 40 + 4 * e.getColorCount();
+        img[10] = (byte) (ofset & 0xFF);
+        img[11] = (byte) ((ofset >> 8) & 0xFF);
+        img[12] = (byte) ((ofset >> 16) & 0xFF);
+        img[13] = (byte) ((ofset >> 24) & 0xFF);
+        //ico is storing height as height of XOR + height of AND bitmaps
+        //that is 2 x hight. Bitmap expects only height of single image
+        int tmpHeight = e.getHeight();
+        img[fakingArray + 4/*size*/ + 4/*width*/] = (byte) (tmpHeight & 0xFF);
+        img[fakingArray + 4/*size*/ + 4/*width*/ + 1] = (byte) ((tmpHeight >> 8) & 0xFF);
+        img[fakingArray + 4/*size*/ + 4/*width*/ + 2] = (byte) ((tmpHeight >> 16) & 0xFF);
+        img[fakingArray + 4/*size*/ + 4/*width*/ + 3] = (byte) ((tmpHeight >> 24) & 0xFF);
+        return img;
+    }
+
+}
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/util/BasicExceptionDialog.java
--- a/netx/net/sourceforge/jnlp/util/BasicExceptionDialog.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/util/BasicExceptionDialog.java	Tue Jan 26 15:18:30 2016 +0100
@@ -45,6 +45,7 @@
 import java.awt.Dimension;
 import java.awt.event.ActionEvent;
 import java.awt.event.ActionListener;
+import java.util.concurrent.atomic.AtomicInteger;
 
 import javax.swing.BorderFactory;
 import javax.swing.BoxLayout;
@@ -65,6 +66,7 @@
  */
 public class BasicExceptionDialog {
 
+    private static final AtomicInteger dialogInstancess = new AtomicInteger();
 
     /**
      * Must be invoked from the Swing EDT.
@@ -144,6 +146,7 @@
         ScreenFinder.centerWindowsToCurrentScreen(errorDialog);
         errorDialog.setVisible(true);
         errorDialog.dispose();
+        BasicExceptionDialog.willBeHidden();
     }
 
      public static JButton getShowButton(final Component parent) {
@@ -191,4 +194,17 @@
         });
         return clearAllButton;
     }
+
+    private synchronized static int willBeHidden() {
+        return dialogInstancess.decrementAndGet();
+    }
+
+    //must be called out of EDT, otherise -- will happen before ++
+    public synchronized static int  willBeShown() {
+        return dialogInstancess.incrementAndGet();
+    }
+    
+    public synchronized static boolean areShown() {
+        return dialogInstancess.intValue() > 0;
+    }
 }
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/util/UrlUtils.java
--- a/netx/net/sourceforge/jnlp/util/UrlUtils.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/util/UrlUtils.java	Tue Jan 26 15:18:30 2016 +0100
@@ -52,6 +52,9 @@
     private static final String UTF8 = "utf-8";
 
     public static URL normalizeUrlAndStripParams(URL url, boolean encodeFileUrls) {
+        if (url == null) {
+            return null;
+        }
         try {
             String[] urlParts = url.toString().split("\\?");
             URL strippedUrl = new URL(urlParts[0]); 
@@ -165,6 +168,9 @@
      * @return  src without file
      */
     public static URL removeFileName(final URL src) {
+        if (src == null) {
+            return src;
+        }
         URL nsrc = normalizeUrlAndStripParams(src);
         String s = nsrc.getPath();
         int i1 = s.lastIndexOf("/");
@@ -332,7 +338,77 @@
         }
     }
     
+    public static int getSanitizedPort(final URL u) {
+        if (u.getPort() < 0) {
+            return u.getDefaultPort();
+        }
+        return u.getPort();
+    }
 
+    public static int getPort(final URL url) {
+        return getSanitizedPort(url);
+    }
 
+    public static String getHostAndPort(final URL url) {
+        return url.getHost() + ":" + getSanitizedPort(url);
+    }
+    
+    public static URL ensureSlashTail(URL u) {
+        if (u == null) {
+            return null;
+        }
+        String s = ensureSlashTail(u.toExternalForm());
+        try {
+            return new URL(s);
+        } catch (MalformedURLException ex) {
+            OutputController.getLogger().log(ex);
+            return u;
+        }
+
+    }
+
+    public static String ensureSlashTail(String s) {
+        if (s.endsWith("/")) {
+            return s;
+        }
+        if (s.endsWith("\\")) {
+            return s;
+        }
+        if (s.contains("/")) {
+            return s + "/";
+        }
+        if (s.contains("\\")) {
+            return s + "\\";
+        }
+        return s + "/";
+    }
+
+    public static String stripFile(URL documentbase) {
+        //whenused in generation of regec, the trailing slash is very important
+        //see the result between http:/some.url/path.* and http:/some.url/path/.*
+        return UrlUtils.ensureSlashTail(stripFileImp(documentbase));
+    }
+
+    private static String stripFileImp(URL documentbase) {
+        try {
+            String normalized = UrlUtils.normalizeUrlAndStripParams(documentbase).toExternalForm().trim();
+            if (normalized.endsWith("/") || normalized.endsWith("\\")) {
+                return normalized;
+            }
+            URL middleway = new URL(normalized);
+            String file = middleway.getFile();
+            int i = Math.max(file.lastIndexOf('/'), file.lastIndexOf('\\'));
+            if (i < 0) {
+                return normalized;
+            }
+            String parent = file.substring(0, i + 1);
+            String stripped = normalized.replace(file, parent);
+            return stripped;
+        } catch (Exception ex) {
+            OutputController.getLogger().log(ex);
+            return documentbase.toExternalForm();
+        }
+
+    }
 
 }
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/util/XDesktopEntry.java
--- a/netx/net/sourceforge/jnlp/util/XDesktopEntry.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/util/XDesktopEntry.java	Tue Jan 26 15:18:30 2016 +0100
@@ -148,7 +148,7 @@
 
         }
         if (file.getInformation().getVendor() != null) {
-            fileContents += "Vendor=" + sanitize(file.getInformation().getVendor()) + "\n";
+            fileContents += "X-Vendor=" + sanitize(file.getInformation().getVendor()) + "\n";
         }
 
         if (JNLPRuntime.isWebstartApplication()) {
@@ -531,7 +531,7 @@
         return fPath;
     }
 
-    private static String findFreedesktopOrgDesktopPathCatch() {
+    public static String findFreedesktopOrgDesktopPathCatch() {
         try {
             return findFreedesktopOrgDesktopPath();
         } catch (Exception ex) {
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/util/logging/ConsoleOutputPaneModel.java
--- a/netx/net/sourceforge/jnlp/util/logging/ConsoleOutputPaneModel.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/util/logging/ConsoleOutputPaneModel.java	Tue Jan 26 15:18:30 2016 +0100
@@ -205,11 +205,7 @@
             }
             String line = (createLine(messageWithHeader));
             if (mark) {
-                line = line.replaceAll("<", "&lt;");
-                line = line.replaceAll(">", "&gt;");
-                line = line.replaceAll("\n", "<br/>\n");
-                line = line.replaceAll("  ", "&nbsp; ");//small trick, html is reducting row of spaces to single space. This handles it and stimm allow line wrap
-                line = line.replaceAll("\t", "&nbsp;&nbsp;&nbsp;&nbsp;");
+                line = escapeHtmlForJTextPane(line);
             }
             sb.append(line);
             if (mark) {
@@ -229,6 +225,15 @@
 
     }
 
+    public static String escapeHtmlForJTextPane(String line) {
+        line = line.replaceAll("<", "&lt;")
+                .replaceAll(">", "&gt;")
+                .replaceAll("\n", "<br/>\n")
+                .replaceAll("  ", "&nbsp; ")//small trick, html is reducting row of spaces to single space. This handles it and stimm allow line wrap
+                .replaceAll("\t", "&nbsp;&nbsp;&nbsp;&nbsp;");
+        return line;
+    }
+
     String createLine(MessageWithHeader m) {
         StringBuilder sb = new StringBuilder();
         if (showHeaders) {
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/util/logging/FileLog.java
--- a/netx/net/sourceforge/jnlp/util/logging/FileLog.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/util/logging/FileLog.java	Tue Jan 26 15:18:30 2016 +0100
@@ -36,81 +36,74 @@
  exception statement from your version. */
 package net.sourceforge.jnlp.util.logging;
 
-import java.io.File;
-import java.io.IOException;
 import java.text.SimpleDateFormat;
 import java.util.Date;
-import java.util.logging.FileHandler;
-import java.util.logging.Formatter;
-import java.util.logging.Level;
-import java.util.logging.LogRecord;
-import java.util.logging.Logger;
-import net.sourceforge.jnlp.util.FileUtils;
+import net.sourceforge.jnlp.util.docprovider.TextsProvider;
+import net.sourceforge.jnlp.util.logging.filelogs.LogBasedFileLog;
+import net.sourceforge.jnlp.util.logging.filelogs.WriterBasedFileLog;
 import net.sourceforge.jnlp.util.logging.headers.Header;
 
 /**
- * This class writes log information to file.
+ * This class is utility and factory around file logs.
  */
-public final class FileLog implements SingleStreamLogger {
-    private static SimpleDateFormat fileLogNameFormatter = new SimpleDateFormat("yyyy-MM-dd_HH:mm:ss.S");
-    /**"Tue Nov 19 09:43:50 CET 2013"*/
-    private static SimpleDateFormat pluginSharedFormatter = new SimpleDateFormat("EEE MMM dd HH:mm:ss ZZZ yyyy");
+public final class FileLog  {
 
-    private final Logger impl;
-    private final FileHandler fh;
-    private static final String defaultloggerName = "IcedTea-Web file-logger";
-
-    public FileLog() {
-        this(false);
+    public static Header getHeadlineHeader() {
+        return new Header(OutputController.Level.WARNING_ALL, Thread.currentThread().getStackTrace(), Thread.currentThread(), false);
     }
     
-     public FileLog(boolean append) {
-        this(defaultloggerName, LogConfig.getLogConfig().getIcedteaLogDir() + "itw-javantx-" + getStamp() + ".log", append);
+    private static final class SingleStreamLoggerImpl implements SingleStreamLogger {
+
+        public SingleStreamLoggerImpl() {
+        }
+
+        @Override
+        public void log(String s) {
+            //dummy
+        }
+
+        @Override
+        public void close() {
+            //dummy
+        }
     }
 
+    public static final SimpleDateFormat fileLogNameFormatter = new SimpleDateFormat("yyyy-MM-dd_HH:mm:ss.S");
+    /**"Tue Nov 19 09:43:50 CET 2013"*/
+    public static final SimpleDateFormat pluginSharedFormatter = new SimpleDateFormat("EEE MMM dd HH:mm:ss ZZZ yyyy");
+    public static final String defaultloggerName = TextsProvider.ITW + " file-logger";
 
-     
-    public FileLog(String fileName, boolean append) {
-        this(fileName, fileName, append);
+
+    public static SingleStreamLogger createFileLog() {
+        return createFileLog("javantx");
     }
-     
-    public FileLog(String loggerName, String fileName, boolean append) {
-       try {
-           File futureFile = new File(fileName);
-           if (!futureFile.exists()) {
-               FileUtils.createRestrictedFile(futureFile, true);
-           }
-           fh = new FileHandler(fileName, append);
-           fh.setFormatter(new Formatter() {
-               @Override
-               public String format(LogRecord record) {
-                   return record.getMessage() + "\n";
-               }
-           });
-           impl = Logger.getLogger(loggerName);
-           impl.setLevel(Level.ALL);
-           impl.addHandler(fh);
-           log(new Header(OutputController.Level.WARNING_ALL, Thread.currentThread().getStackTrace(), Thread.currentThread(), false).toString());
-       } catch (IOException e) {
-           throw new RuntimeException(e);
-       }
+    
+    public static SingleStreamLogger createAppFileLog() {
+        return createFileLog("clienta");
+    }
+    
+    private static SingleStreamLogger createFileLog(String id) {
+        SingleStreamLogger s;
+        try {
+            if (LogConfig.getLogConfig().isLegacyLogBasedFileLog()) {
+                s = new LogBasedFileLog(defaultloggerName, getFileName(id), false);
+            } else {
+                s = new WriterBasedFileLog(defaultloggerName, getFileName(id), false);
+            }
+        } catch (Exception ex) {
+            //we do not wont to block whole logging just because initialization error in "new FileLog()"
+            OutputController.getLogger().log(ex);
+            s = new SingleStreamLoggerImpl();
+        }
+        return s;
     }
 
-    /**
-     * Log the String to file.
-     *
-     * @param s {@link Exception} that was thrown.
-     */
-    @Override
-    public synchronized void log(String s) {
-        impl.log(Level.FINE, s);
+    private static String getFileName(String id) {
+        return LogConfig.getLogConfig().getIcedteaLogDir() + "itw-"+id+"-" + getStamp() + ".log";
     }
     
-    public void close() {
-        fh.close();
-    }
-
-    private static String getStamp() {
+  
+    public static String getStamp() {
         return fileLogNameFormatter.format(new Date());
     }
 
@@ -121,4 +114,5 @@
     public static SimpleDateFormat getPluginSharedFormatter() {
         return pluginSharedFormatter;
     }
+
 }
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/util/logging/LogConfig.java
--- a/netx/net/sourceforge/jnlp/util/logging/LogConfig.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/util/logging/LogConfig.java	Tue Jan 26 15:18:30 2016 +0100
@@ -52,32 +52,36 @@
     private boolean enableLogging;
     private boolean enableHeaders;
     private boolean logToFile;
+    private boolean logClientAppToFile;
     private boolean logToStreams;
     private boolean logToSysLog;
-    
+    private boolean legacyLogaAsedFileLog;
+
     private LogConfig() {
-            DeploymentConfiguration config = JNLPRuntime.getConfiguration();
-            // Check whether logging and tracing is enabled.
-            enableLogging = Boolean.parseBoolean(config.getProperty(DeploymentConfiguration.KEY_ENABLE_LOGGING));
-            //enagle disable headers
-            enableHeaders = Boolean.parseBoolean(config.getProperty(DeploymentConfiguration.KEY_ENABLE_LOGGING_HEADERS));
-            //enable/disable individual channels
-            logToFile = Boolean.parseBoolean(config.getProperty(DeploymentConfiguration.KEY_ENABLE_LOGGING_TOFILE));
-            logToStreams = Boolean.parseBoolean(config.getProperty(DeploymentConfiguration.KEY_ENABLE_LOGGING_TOSTREAMS));
-            logToSysLog = Boolean.parseBoolean(config.getProperty(DeploymentConfiguration.KEY_ENABLE_LOGGING_TOSYSTEMLOG));
+        DeploymentConfiguration config = JNLPRuntime.getConfiguration();
+        // Check whether logging and tracing is enabled.
+        enableLogging = Boolean.parseBoolean(config.getProperty(DeploymentConfiguration.KEY_ENABLE_LOGGING));
+        //enagle disable headers
+        enableHeaders = Boolean.parseBoolean(config.getProperty(DeploymentConfiguration.KEY_ENABLE_LOGGING_HEADERS));
+        //enable/disable individual channels
+        logToFile = Boolean.parseBoolean(config.getProperty(DeploymentConfiguration.KEY_ENABLE_LOGGING_TOFILE));
+        logToStreams = Boolean.parseBoolean(config.getProperty(DeploymentConfiguration.KEY_ENABLE_LOGGING_TOSTREAMS));
+        logToSysLog = Boolean.parseBoolean(config.getProperty(DeploymentConfiguration.KEY_ENABLE_LOGGING_TOSYSTEMLOG));
+        legacyLogaAsedFileLog = Boolean.parseBoolean(config.getProperty(DeploymentConfiguration.KEY_ENABLE_LEGACY_LOGBASEDFILELOG));
+        logClientAppToFile = Boolean.parseBoolean(config.getProperty(DeploymentConfiguration.KEY_ENABLE_APPLICATION_LOGGING_TOFILE));
 
-            // Get log directory, create it if it doesn't exist. If unable to create and doesn't exist, don't log.
-            icedteaLogDir = PathsAndFiles.LOG_DIR.getFullPath();
-            if (icedteaLogDir != null) {
-                File f = new File(icedteaLogDir);
-                if (f.isDirectory() || f.mkdirs()) {
-                    icedteaLogDir += File.separator;
-                } else {
-                    enableLogging = false;
-                }
+        // Get log directory, create it if it doesn't exist. If unable to create and doesn't exist, don't log.
+        icedteaLogDir = PathsAndFiles.LOG_DIR.getFullPath();
+        if (icedteaLogDir != null) {
+            File f = new File(icedteaLogDir);
+            if (f.isDirectory() || f.mkdirs()) {
+                icedteaLogDir += File.separator;
             } else {
                 enableLogging = false;
             }
+        } else {
+            enableLogging = false;
+        }
     }
 
     private static class LogConfigHolder {
@@ -91,9 +95,11 @@
         return LogConfigHolder.INSTANCE;
     }
 
-    /** For testing only: throw away the previous config */
+    /**
+     * For testing only: throw away the previous config
+     */
     static synchronized void resetLogConfig() {
-            LogConfigHolder.INSTANCE = new LogConfig();
+        LogConfigHolder.INSTANCE = new LogConfig();
     }
 
     public String getIcedteaLogDir() {
@@ -119,11 +125,8 @@
     public boolean isEnableHeaders() {
         return enableHeaders;
     }
-    
-    
-    
+
     //package private setters for testing
-
     void setEnableHeaders(boolean enableHeaders) {
         this.enableHeaders = enableHeaders;
     }
@@ -151,5 +154,21 @@
     boolean isLogToConsole() {
         return JavaConsole.isEnabled();
     }
-    
+
+    boolean isLegacyLogBasedFileLog() {
+        return legacyLogaAsedFileLog;
+    }
+
+    boolean setLegacyLogBasedFileLog(boolean b) {
+        return legacyLogaAsedFileLog = b;
+    }
+
+    void serLogToFileForClientApp(boolean b) {
+        logClientAppToFile = b;
+    }
+
+    boolean isLogToFileForClientApp() {
+        return logClientAppToFile;
+    }
+
 }
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/util/logging/OutputController.java
--- a/netx/net/sourceforge/jnlp/util/logging/OutputController.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/util/logging/OutputController.java	Tue Jan 26 15:18:30 2016 +0100
@@ -102,8 +102,8 @@
     private static final String NULL_OBJECT = "Trying to log null object";
     private PrintStreamLogger outLog;
     private PrintStreamLogger errLog;
-    private List<MessageWithHeader> messageQue = new LinkedList<MessageWithHeader>();
-    private MessageQueConsumer messageQueConsumer = new MessageQueConsumer();
+    private final List<MessageWithHeader> messageQue = new LinkedList<>();
+    private final MessageQueConsumer messageQueConsumer = new MessageQueConsumer();
     Thread consumerThread;
 
     //bounded to instance
@@ -134,7 +134,7 @@
         }
     }
     
-    public void close() {
+    public void close() throws Exception {
         flush();
         if (LogConfig.getLogConfig().isLogToFile()){
             getFileLog().close();
@@ -150,6 +150,9 @@
         }
         //clients app's messages are reprinted only to console
         if (s.getHeader().isClientApp){
+            if (LogConfig.getLogConfig().isLogToFile() && LogConfig.getLogConfig().isLogToFileForClientApp()) {
+                getAppFileLog().log(proceedHeader(s));
+            }
             return;
         }
         if (!JNLPRuntime.isDebug() && (s.getHeader().level == Level.MESSAGE_DEBUG
@@ -159,14 +162,7 @@
             //must be here to prevent deadlock, casued by exception form jnlpruntime, loggers or configs themselves
             return;
         }
-        String message = s.getMessage();
-        if (LogConfig.getLogConfig().isEnableHeaders()) {
-            if (message.contains("\n")) {
-                message = s.getHeader().toString() + "\n" + message;
-            } else {
-                message = s.getHeader().toString() + " " + message;
-            }
-        }
+        String message = proceedHeader(s);
         if (LogConfig.getLogConfig().isLogToStreams()) {
             if (s.getHeader().level.isOutput()) {
                 outLog.log(message);
@@ -189,6 +185,18 @@
 
     }
 
+    private String proceedHeader(MessageWithHeader s) {
+        String message = s.getMessage();
+        if (LogConfig.getLogConfig().isEnableHeaders()) {
+            if (message.contains("\n")) {
+                message = s.getHeader().toString() + "\n" + message;
+            } else {
+                message = s.getHeader().toString() + " " + message;
+            }
+        }
+        return message;
+    }
+
     private OutputController() {
         this(System.out, System.err);
     }
@@ -333,11 +341,24 @@
         
         //https://en.wikipedia.org/wiki/Double-checked_locking#Usage_in_Java
         //https://en.wikipedia.org/wiki/Initialization_on_demand_holder_idiom
-        private static volatile FileLog INSTANCE = new FileLog();
+        private static volatile SingleStreamLogger INSTANCE = FileLog.createFileLog();
     }
-    private FileLog getFileLog() {
+
+    private SingleStreamLogger getFileLog() {
         return FileLogHolder.INSTANCE;
     }
+    
+    
+    private static class AppFileLogHolder {
+        
+        //https://en.wikipedia.org/wiki/Double-checked_locking#Usage_in_Java
+        //https://en.wikipedia.org/wiki/Initialization_on_demand_holder_idiom
+        private static volatile SingleStreamLogger INSTANCE = FileLog.createAppFileLog();
+    }
+
+    private SingleStreamLogger getAppFileLog() {
+        return AppFileLogHolder.INSTANCE;
+    }
 
     private static class SystemLogHolder {
 
@@ -394,9 +415,13 @@
         this.errLog = errLog;
     }
 
-    void setFileLog(FileLog fileLog) {
+    void setFileLog(SingleStreamLogger fileLog) {
         FileLogHolder.INSTANCE = fileLog;
     }
+    
+    void setAppFileLog(SingleStreamLogger fileLog) {
+        AppFileLogHolder.INSTANCE = fileLog;
+    }
 
     void setOutLog(PrintStreamLogger outLog) {
         this.outLog = outLog;
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/util/logging/PrintStreamLogger.java
--- a/netx/net/sourceforge/jnlp/util/logging/PrintStreamLogger.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/util/logging/PrintStreamLogger.java	Tue Jan 26 15:18:30 2016 +0100
@@ -58,11 +58,10 @@
     public void setStream(PrintStream stream) {
         this.stream = stream;
     }
-    
-    
- 
-    
-      
 
+    @Override
+    public void close() {
+        stream.flush();
+    }
 
 }
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/util/logging/SingleStreamLogger.java
--- a/netx/net/sourceforge/jnlp/util/logging/SingleStreamLogger.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/util/logging/SingleStreamLogger.java	Tue Jan 26 15:18:30 2016 +0100
@@ -36,11 +36,11 @@
 
 package net.sourceforge.jnlp.util.logging;
 
-public interface SingleStreamLogger {
- 
-    
-     
-      public  void log(String s);
+public interface SingleStreamLogger extends AutoCloseable {
 
+    public void log(String s);
+
+    @Override
+    public void close() throws Exception;
 
 }
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/util/logging/UnixSystemLog.java
--- a/netx/net/sourceforge/jnlp/util/logging/UnixSystemLog.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/util/logging/UnixSystemLog.java	Tue Jan 26 15:18:30 2016 +0100
@@ -63,6 +63,11 @@
             OutputController.getLogger().log(ex);
         }
     }
-    
+
+    @Override
+    public void close() {
+        //nope
+    }
+
 
 }
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/util/logging/WinSystemLog.java
--- a/netx/net/sourceforge/jnlp/util/logging/WinSystemLog.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/util/logging/WinSystemLog.java	Tue Jan 26 15:18:30 2016 +0100
@@ -49,9 +49,10 @@
     public void log(String s) {
      //not yet implemented   
     }
- 
-    
       
-
+    @Override
+    public void close() {
+        //nope
+    }
 
 }
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/util/logging/filelogs/LogBasedFileLog.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/netx/net/sourceforge/jnlp/util/logging/filelogs/LogBasedFileLog.java	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,101 @@
+/*
+ Copyright (C) 2011, 2013 Red Hat, Inc.
+
+ This file is part of IcedTea.
+
+ IcedTea is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+
+ IcedTea is distributed in the hope that it will be useful, but
+ WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with IcedTea; see the file COPYING.  If not, write to the
+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301 USA.
+
+ Linking this library statically or dynamically with other modules is
+ making a combined work based on this library.  Thus, the terms and
+ conditions of the GNU General Public License cover the whole
+ combination.
+
+ As a special exception, the copyright holders of this library give you
+ permission to link this library with independent modules to produce an
+ executable, regardless of the license terms of these independent
+ modules, and to copy and distribute the resulting executable under
+ terms of your choice, provided that you also meet, for each linked
+ independent module, the terms and conditions of the license of that
+ module.  An independent module is a module which is not derived from
+ or based on this library.  If you modify this library, you may extend
+ this exception to your version of the library, but you are not
+ obligated to do so.  If you do not wish to do so, delete this
+ exception statement from your version. */
+package net.sourceforge.jnlp.util.logging.filelogs;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.logging.FileHandler;
+import java.util.logging.Formatter;
+import java.util.logging.Level;
+import java.util.logging.LogRecord;
+import java.util.logging.Logger;
+import net.sourceforge.jnlp.util.FileUtils;
+import net.sourceforge.jnlp.util.logging.FileLog;
+import net.sourceforge.jnlp.util.logging.SingleStreamLogger;
+
+/**
+ * This class writes log information to file.
+ */
+public final class LogBasedFileLog implements SingleStreamLogger {
+
+    //really instance bounded
+    private final Logger impl;
+    private final FileHandler fh;
+
+    // testing constructor 
+    public LogBasedFileLog(String fileName, boolean append) {
+        this(fileName, fileName, append);
+    }
+
+    public LogBasedFileLog(String loggerName, String fileName, boolean append) {
+        try {
+            File futureFile = new File(fileName);
+            if (!futureFile.exists()) {
+                FileUtils.createRestrictedFile(futureFile, true);
+            }
+            fh = new FileHandler(fileName, append);
+            fh.setFormatter(new Formatter() {
+                @Override
+                public String format(LogRecord record) {
+                    return record.getMessage() + "\n";
+                }
+            });
+            impl = Logger.getLogger(loggerName);
+            impl.setLevel(Level.ALL);
+            impl.addHandler(fh);
+            log(FileLog.getHeadlineHeader().toString() + " log-based impl.");
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    /**
+     * Log the String to file.
+     *
+     * @param s {@link Exception} that was thrown.
+     */
+    @Override
+    public synchronized void log(String s) {
+        impl.log(Level.FINE, s);
+    }
+
+    @Override
+    public void close() {
+        fh.close();
+    }
+
+}
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/util/logging/filelogs/WriterBasedFileLog.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/netx/net/sourceforge/jnlp/util/logging/filelogs/WriterBasedFileLog.java	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,100 @@
+/*
+ Copyright (C) 2011, 2013 Red Hat, Inc.
+
+ This file is part of IcedTea.
+
+ IcedTea is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+
+ IcedTea is distributed in the hope that it will be useful, but
+ WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with IcedTea; see the file COPYING.  If not, write to the
+ Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301 USA.
+
+ Linking this library statically or dynamically with other modules is
+ making a combined work based on this library.  Thus, the terms and
+ conditions of the GNU General Public License cover the whole
+ combination.
+
+ As a special exception, the copyright holders of this library give you
+ permission to link this library with independent modules to produce an
+ executable, regardless of the license terms of these independent
+ modules, and to copy and distribute the resulting executable under
+ terms of your choice, provided that you also meet, for each linked
+ independent module, the terms and conditions of the license of that
+ module.  An independent module is a module which is not derived from
+ or based on this library.  If you modify this library, you may extend
+ this exception to your version of the library, but you are not
+ obligated to do so.  If you do not wish to do so, delete this
+ exception statement from your version. */
+package net.sourceforge.jnlp.util.logging.filelogs;
+
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+import net.sourceforge.jnlp.util.FileUtils;
+import net.sourceforge.jnlp.util.logging.FileLog;
+import net.sourceforge.jnlp.util.logging.SingleStreamLogger;
+
+/**
+ * This class writes log information to file.
+ */
+public final class WriterBasedFileLog implements SingleStreamLogger {
+
+    private final BufferedWriter bw;
+
+    public WriterBasedFileLog(String fileName, boolean append) {
+        this(fileName, fileName, append);
+    }
+
+    public WriterBasedFileLog(String loggerName, String fileName, boolean append) {
+        try {
+            File futureFile = new File(fileName);
+            if (!futureFile.exists()) {
+                FileUtils.createRestrictedFile(futureFile, true);
+            }
+            bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(fileName), append), "UTF-8"));
+            log(FileLog.getHeadlineHeader().toString() + " writer-based impl.");
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    /**
+     * Log the String to file.
+     *
+     * @param s {@link Exception} that was thrown.
+     */
+    @Override
+    public synchronized void log(String s) {
+        try {
+            bw.write(s);
+            if (!s.endsWith("\n")) {
+                bw.newLine();
+            }
+            bw.flush();
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public void close() throws IOException {
+        try {
+            bw.flush();
+        } finally {
+            bw.close();
+        }
+
+    }
+
+}
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/jnlp/util/logging/headers/PluginMessage.java
--- a/netx/net/sourceforge/jnlp/util/logging/headers/PluginMessage.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/jnlp/util/logging/headers/PluginMessage.java	Tue Jan 26 15:18:30 2016 +0100
@@ -38,7 +38,6 @@
 package net.sourceforge.jnlp.util.logging.headers;
 
 import java.util.Date;
-import net.sourceforge.jnlp.util.logging.FileLog;
 import net.sourceforge.jnlp.util.logging.OutputController;
 
 public class PluginMessage  implements MessageWithHeader{
diff -r ba6519dd5e79 -r 263e152a6084 netx/net/sourceforge/nanoxml/XMLElement.java
--- a/netx/net/sourceforge/nanoxml/XMLElement.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/net/sourceforge/nanoxml/XMLElement.java	Tue Jan 26 15:18:30 2016 +0100
@@ -195,6 +195,11 @@
      * Character read too much for the comment remover.
      */
     private char sanitizeCharReadTooMuch;
+    
+   /**
+     * Whether the BOM header appeared
+     */
+    private boolean BOM = false;
 
     /**
      * The reader provided by the caller of the parse method.
@@ -494,7 +499,7 @@
         this.parserLineNr = startingLineNr;
 
         for (;;) {
-            char ch = this.scanWhitespace();
+            char ch = this.scanLeadingWhitespace();
 
             if (ch != '<') {
                 throw this.expectedInput("<", ch);
@@ -584,24 +589,50 @@
         }
     }
 
+    private boolean isRegularWhiteSpace(char ch) {
+        switch (ch) {
+            case ' ':
+            case '\t':
+            case '\n':
+            case '\r':
+                return true;
+            default:
+                return false;
+        }
+    }
+    
     /**
      * This method scans an identifier from the current reader.
      *
      * @return the next character following the whitespace.
      * @throws java.io.IOException if something goes wrong
      */
-    protected char scanWhitespace()
+    private char scanWhitespace()
             throws IOException {
-        for (;;) {
+        while(true) {
             char ch = this.readChar();
-            switch (ch) {
-                case ' ':
-                case '\t':
-                case '\n':
-                case '\r':
-                    break;
-                default:
-                    return ch;
+            if (!isRegularWhiteSpace(ch)) {
+                return ch;
+            }
+        }
+    }
+     /**
+     * This method scans an leading identifier from the current reader.
+     * 
+     * UNlike scanWhitespace, it skipps also BOM
+     *
+     * @return the next character following the whitespace.
+     * @throws java.io.IOException if something goes wrong
+     */
+    private char scanLeadingWhitespace()
+            throws IOException {
+        while(true) {
+            char ch = this.readChar();
+            //this is BOM , not space
+            if (ch == '﻿') {
+                BOM = true;
+            } else if (!isRegularWhiteSpace(ch)) {
+                return ch;
             }
         }
     }
@@ -621,18 +652,17 @@
      */
     protected char scanWhitespace(StringBuffer result)
             throws IOException {
-        for (;;) {
+        while (true) {
             char ch = this.readChar();
-            switch (ch) {
-                case ' ':
-                case '\t':
-                case '\n':
-                    result.append(ch);
-                    break;
-                case '\r':
-                    break;
-                default:
-                    return ch;
+            if (!isRegularWhiteSpace(ch)) {
+                return ch;
+            } else {
+                switch (ch) {
+                    case ' ':
+                    case '\t':
+                    case '\n':
+                        result.append(ch);
+                }
             }
         }
     }
@@ -1297,4 +1327,11 @@
 
         }
     }
+
+    public boolean isBOM() {
+        return BOM;
+    }
+    
+    
+    
 }
diff -r ba6519dd5e79 -r 263e152a6084 netx/sun/applet/AppletViewerPanelAccess.java
--- a/netx/sun/applet/AppletViewerPanelAccess.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/netx/sun/applet/AppletViewerPanelAccess.java	Tue Jan 26 15:18:30 2016 +0100
@@ -41,6 +41,7 @@
 import java.util.Hashtable;
 import java.util.Map;
 import net.sourceforge.jnlp.NetxPanel;
+import net.sourceforge.jnlp.util.logging.OutputController;
 
 public abstract class AppletViewerPanelAccess extends AppletViewerPanel {
 
@@ -132,4 +133,36 @@
 
     abstract protected void ourRunLoader();
 
+    /**
+     * jdk9 removed doInit.
+     * http://hg.openjdk.java.net/jdk9/jdk9/jdk/rev/2b680924a73f This is way how
+     * to set it in older jdks and still compile on jdk9+
+     *
+     * @param a value to set to doInit if it exists
+     */
+    protected void setDoInitIfExists(boolean a) {
+        //doInit = a;
+        try {
+            Class c = this.getClass();
+            Field fs = null;
+            while (c != null) {
+                if (AppletPanel.class.equals(c)) {
+                    fs = c.getDeclaredField("doInit");
+                    break;
+                }
+                //known location is NetxPanel->AppeltViwerPannelAccess->AppletViwerPanel->AppletPanel
+                c = c.getSuperclass();
+            }
+            if (fs == null) {
+                throw new NoSuchFieldException("AppletPanel not found.");
+            }
+            fs.setAccessible(true);
+            fs.set(this, a);
+        } catch (IllegalAccessException | IllegalArgumentException | NoSuchFieldException | SecurityException ex) {
+            OutputController.getLogger().log("Can't get/set doInit. Runing on JDK9 or higher?");
+            OutputController.getLogger().log(ex);
+        }
+
+    }
+
 }
diff -r ba6519dd5e79 -r 263e152a6084 plugin/icedteanp/IcedTeaNPPlugin.cc
--- a/plugin/icedteanp/IcedTeaNPPlugin.cc	Fri Sep 11 14:57:30 2015 +0200
+++ b/plugin/icedteanp/IcedTeaNPPlugin.cc	Tue Jan 26 15:18:30 2016 +0100
@@ -241,13 +241,14 @@
 static guint appletviewer_watch_id = -1;
 
 bool debug_initiated = false;
+bool file_logs_initiated = false;
 int plugin_debug = getenv ("ICEDTEAPLUGIN_DEBUG") != NULL;
 bool plugin_debug_headers = false;
 bool plugin_debug_to_file = false ;
 bool plugin_debug_to_streams = true ;
 bool plugin_debug_to_system = false;
 bool plugin_debug_to_console = true;
-FILE *  plugin_file_log;
+FILE *  plugin_file_log = NULL;
 std::string plugin_file_log_name;
 
 int plugin_debug_suspend = (getenv("ICEDTEAPLUGIN_DEBUG") != NULL) &&
@@ -1153,13 +1154,13 @@
   if (g_str_has_prefix(parts[1], "PluginProxyInfo"))
   {
     gchar* proxy = NULL;
-    uint32_t len;
+    uint32_t len = 0;
 
     gchar* decoded_url = (gchar*) calloc(strlen(parts[4]) + 1, sizeof(gchar));
     IcedTeaPluginUtilities::decodeURL(parts[4], &decoded_url);
     PLUGIN_DEBUG("parts[0]=%s, parts[1]=%s, reference, parts[3]=%s, parts[4]=%s -- decoded_url=%s\n", parts[0], parts[1], parts[3], parts[4], decoded_url);
 
-    gchar* proxy_info;
+    gchar* proxy_info = NULL;
 
     proxy_info = g_strconcat ("plugin PluginProxyInfo reference ", parts[3], " ", NULL);
     if (get_proxy_info(decoded_url, &proxy, &len) == NPERR_NO_ERROR)
@@ -1330,10 +1331,16 @@
   }
   if (browser_functions.getvalueforurl)
   {
-
+      NPError err;
       // As in get_cookie_info, we use the first active instance
       gpointer instance=getFirstInTableInstance(instance_to_id_map);
-      browser_functions.getvalueforurl((NPP) instance, NPNURLVProxy, siteAddr, proxy, len);
+      err = browser_functions.getvalueforurl((NPP) instance, NPNURLVProxy, siteAddr, proxy, len);
+
+      if (err != NPERR_NO_ERROR) 
+      {
+        *proxy = (char *) malloc(sizeof **proxy * 7);
+        *len = g_strlcpy(*proxy, "DIRECT", 7);
+      }
   } else
   {
       return NPERR_GENERIC_ERROR;
diff -r ba6519dd5e79 -r 263e152a6084 plugin/icedteanp/IcedTeaNPPlugin.h
--- a/plugin/icedteanp/IcedTeaNPPlugin.h	Fri Sep 11 14:57:30 2015 +0200
+++ b/plugin/icedteanp/IcedTeaNPPlugin.h	Tue Jan 26 15:18:30 2016 +0100
@@ -117,6 +117,7 @@
 
 // debug switches
 extern bool debug_initiated;
+extern bool file_logs_initiated;
 extern int plugin_debug;
 extern bool plugin_debug_headers;
 extern bool plugin_debug_to_file;
diff -r ba6519dd5e79 -r 263e152a6084 plugin/icedteanp/IcedTeaParseProperties.cc
--- a/plugin/icedteanp/IcedTeaParseProperties.cc	Fri Sep 11 14:57:30 2015 +0200
+++ b/plugin/icedteanp/IcedTeaParseProperties.cc	Tue Jan 26 15:18:30 2016 +0100
@@ -95,6 +95,7 @@
 	int l = c.length();
 	dest = c.substr(i+1, l-i);
 	IcedTeaPluginUtilities::trim(dest);
+	IcedTeaPluginUtilities::unescape(dest);
 	return true;
 }
 
diff -r ba6519dd5e79 -r 263e152a6084 plugin/icedteanp/IcedTeaPluginUtils.cc
--- a/plugin/icedteanp/IcedTeaPluginUtils.cc	Fri Sep 11 14:57:30 2015 +0200
+++ b/plugin/icedteanp/IcedTeaPluginUtils.cc	Tue Jan 26 15:18:30 2016 +0100
@@ -1148,6 +1148,55 @@
 	str = str.substr(start, end - start + 1);
 }
 
+/*Unescape various escaped chars like \\ -> \ or \= -> =  or \: -> , \t -> TAB ,  \n -> NwLine\*/
+
+/* examples
+ *  \\= -> \=
+ *  \=  -> =
+ *  \\  -> \
+ *  \e  -> \e
+ *  \:  -> :
+ *  \   -> \
+ *  \\  ->  \
+ */
+void IcedTeaPluginUtilities::unescape(std::string& str) {
+    std::string result = "";
+    int len = str.length();
+    for (unsigned int i = 0; i < len; i++) {
+        bool processed = false;
+        char c1 = str[i];
+        if (c1 == '\\') {
+            if (i < len - 1) {
+                char c2 = str[i + 1];
+                if (c2 == '=' || c2 == '\\' || c2 == ':') {
+                    result += c2;
+                    i++;
+                    processed = true;
+                }
+                if (c2 == 't') {
+                    result += '\t';
+                    i++;
+                    processed = true;
+                }
+                if (c2 == 'n') {
+                    result += '\n';
+                    i++;
+                    processed = true;
+                }
+                if (c2 == 'r') {
+                    result += '\r';
+                    i++;
+                    processed = true;
+                }
+            }
+        }
+        if (!processed) {
+            result += c1;
+        }
+    }
+    str = result;
+}
+
 std::string IcedTeaPluginUtilities::NPIdentifierAsString(NPIdentifier id) {
     NPUTF8* cstr = browser_functions.utf8fromidentifier(id);
     if (cstr == NULL) {
diff -r ba6519dd5e79 -r 263e152a6084 plugin/icedteanp/IcedTeaPluginUtils.h
--- a/plugin/icedteanp/IcedTeaPluginUtils.h	Fri Sep 11 14:57:30 2015 +0200
+++ b/plugin/icedteanp/IcedTeaPluginUtils.h	Tue Jan 26 15:18:30 2016 +0100
@@ -86,6 +86,7 @@
       plugin_debug_to_console = is_java_console_enabled();                    \
       if (plugin_debug_to_file) {                                             \
            IcedTeaPluginUtilities::initFileLog();                             \
+           file_logs_initiated = true;                                        \
       }                                                                       \
       if (plugin_debug_to_console) {                                          \
           /*initialisation done during jvm startup*/                          \
@@ -134,7 +135,7 @@
         snprintf(ldebug_message, MESSAGE_SIZE, "%s%s", ldebug_header, ldebug_body); \
         fprintf  (stdout, "%s", ldebug_message);\
       }                                \
-      if (plugin_debug_to_file) {      \
+      if (plugin_debug_to_file && file_logs_initiated) {      \
         snprintf(ldebug_message, MESSAGE_SIZE, "%s%s", ldebug_header, ldebug_body);   \
         fprintf (plugin_file_log, "%s", ldebug_message);   \
         fflush(plugin_file_log);       \
@@ -180,7 +181,7 @@
       snprintf(ldebug_message, MESSAGE_SIZE, "%s%s", ldebug_header, ldebug_body); \
       fprintf  (stderr, "%s", ldebug_message);                                    \
     }                                  \
-    if (plugin_debug_to_file) {        \
+    if (plugin_debug_to_file && file_logs_initiated) {        \
       snprintf(ldebug_message, MESSAGE_SIZE, "%s%s", ldebug_header, ldebug_body); \
       fprintf (plugin_file_log, "%s", ldebug_message);   \
       fflush(plugin_file_log);         \
@@ -430,6 +431,8 @@
 
         /*cutting whitespaces from end and start of string*/
         static void trim(std::string& str);
+        /*Unescape various escaped chars like \\ -> \ or \= -> =  or \: -> \*/
+        static void unescape(std::string& str);
         static bool file_exists(std::string filename);
         static bool is_directory(std::string filename);
         //file-loggers helpers
diff -r ba6519dd5e79 -r 263e152a6084 plugin/icedteanp/java/sun/applet/PluginAppletViewer.java
--- a/plugin/icedteanp/java/sun/applet/PluginAppletViewer.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/plugin/icedteanp/java/sun/applet/PluginAppletViewer.java	Tue Jan 26 15:18:30 2016 +0100
@@ -113,6 +113,7 @@
 import net.sourceforge.jnlp.splashscreen.SplashController;
 import net.sourceforge.jnlp.splashscreen.SplashPanel;
 import net.sourceforge.jnlp.splashscreen.SplashUtils;
+import net.sourceforge.jnlp.util.UrlUtils;
 import net.sourceforge.jnlp.util.logging.OutputController;
 import sun.awt.AppContext;
 import sun.awt.SunToolkit;
@@ -887,7 +888,7 @@
     public Applet getApplet(String name) {
         name = name.toLowerCase();
         SocketPermission panelSp =
-                new SocketPermission(panel.getCodeBase().getHost(), "connect");
+                new SocketPermission(UrlUtils.getHostAndPort(panel.getCodeBase()), "connect");
         synchronized(appletPanels) {
             for (Enumeration<NetxPanel> e = appletPanels.elements(); e.hasMoreElements();) {
                 AppletPanel p = e.nextElement();
@@ -899,7 +900,7 @@
                         p.getDocumentBase().equals(panel.getDocumentBase())) {
 
                     SocketPermission sp =
-                        new SocketPermission(p.getCodeBase().getHost(), "connect");
+                        new SocketPermission(UrlUtils.getHostAndPort(p.getCodeBase()), "connect");
 
                     if (panelSp.implies(sp)) {
                         return p.applet;
@@ -918,7 +919,7 @@
     public Enumeration<Applet> getApplets() {
         Vector<Applet> v = new Vector<Applet>();
         SocketPermission panelSp =
-                new SocketPermission(panel.getCodeBase().getHost(), "connect");
+                new SocketPermission(UrlUtils.getHostAndPort(panel.getCodeBase()), "connect");
 
         synchronized(appletPanels) {
             for (Enumeration<NetxPanel> e = appletPanels.elements(); e.hasMoreElements();) {
@@ -926,7 +927,7 @@
                 if (p.getDocumentBase().equals(panel.getDocumentBase())) {
 
                     SocketPermission sp =
-                        new SocketPermission(p.getCodeBase().getHost(), "connect");
+                        new SocketPermission(UrlUtils.getHostAndPort(p.getCodeBase()), "connect");
                     if (panelSp.implies(sp)) {
                         v.addElement(p.applet);
                     }
diff -r ba6519dd5e79 -r 263e152a6084 policyeditor.desktop.in
--- a/policyeditor.desktop.in	Fri Sep 11 14:57:30 2015 +0200
+++ b/policyeditor.desktop.in	Tue Jan 26 15:18:30 2016 +0100
@@ -1,5 +1,6 @@
 [Desktop Entry]
 Name=IcedTea-Web Policy Editor
+GenericName=Policy Tool 
 Comment=Edit Java Applet policy and permission settings
 Exec=PATH_TO_POLICYEDITOR
 Icon=javaws
diff -r ba6519dd5e79 -r 263e152a6084 tests/cpp-unit-tests/IcedTeaParsePropertiesTest.cc
--- a/tests/cpp-unit-tests/IcedTeaParsePropertiesTest.cc	Fri Sep 11 14:57:30 2015 +0200
+++ b/tests/cpp-unit-tests/IcedTeaParsePropertiesTest.cc	Tue Jan 26 15:18:30 2016 +0100
@@ -119,6 +119,11 @@
 	a = get_property_value("better.key but errornous value  ",dest);
 	CHECK_EQUAL("", dest);
 	CHECK_EQUAL(a, false);
+
+	dest = string("");
+	a = get_property_value("key=nice\\=value=\\\\=with\\tescapes",dest);
+	CHECK_EQUAL("nice=value=\\=with\tescapes", dest);
+	CHECK_EQUAL(a, true);
 }
 
 TEST(starts_with) {
diff -r ba6519dd5e79 -r 263e152a6084 tests/cpp-unit-tests/IcedTeaPluginUtilsTest.cc
--- a/tests/cpp-unit-tests/IcedTeaPluginUtilsTest.cc	Fri Sep 11 14:57:30 2015 +0200
+++ b/tests/cpp-unit-tests/IcedTeaPluginUtilsTest.cc	Tue Jan 26 15:18:30 2016 +0100
@@ -115,6 +115,29 @@
 	CHECK_EQUAL("te \n stX", toBeTrimmed3);
 }
 
+TEST(unescape1) {
+	std::string toBeEscaped = std::string("he\\\\=llo\\=my=boy\\\\ who :liv\\es in\\: space \\ and \\\\likes\\");
+    /*he\\=llo\=my=boy\\ who :liv\es in\: space \ and \\likes\  */ 
+	IcedTeaPluginUtilities::unescape(toBeEscaped);
+    /* \\= -> \= , \= -> = ,  \\ -> \ , \e -> \e ,  \: -> : ,  \ -> \ ,  \\ -> \*/
+    /*he\=llo=my=boy\ who :liv\es in: space \ and \likes\  */ 
+	CHECK_EQUAL("he\\=llo=my=boy\\ who :liv\\es in: space \\ and \\likes\\", toBeEscaped);
+}
+
+TEST(unescape2) {
+	std::string toBeEscaped = std::string("w1\\tw2\\\\tw3\\nw4\\\\nw5\\=");
+    /*w1\tw2\\tw3\nw4\\nw5\=*/ 
+	IcedTeaPluginUtilities::unescape(toBeEscaped);
+    /*w1TABw2\tw3NWLINEw4\nw5=*/
+	CHECK_EQUAL("w1\tw2\\tw3\nw4\\nw5=", toBeEscaped);
+}
+
+TEST(unescape3) {
+	std::string toBeEscaped = std::string("w1\\rw2\\\\rw3=");
+    IcedTeaPluginUtilities::unescape(toBeEscaped);
+	CHECK_EQUAL("w1\rw2\\rw3=", toBeEscaped);
+}
+
 
 /* Creates a temporary file with the specified contents */
 static std::string temporary_file(const std::string& contents) {
diff -r ba6519dd5e79 -r 263e152a6084 tests/junit-runner/JunitLikeXmlOutputListener.java
--- a/tests/junit-runner/JunitLikeXmlOutputListener.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/tests/junit-runner/JunitLikeXmlOutputListener.java	Tue Jan 26 15:18:30 2016 +0100
@@ -424,6 +424,8 @@
 
         String distro = "http://mail.openjdk.java.net/pipermail/distro-pkg-dev/";
         String openjdk = "http://mail.openjdk.java.net/pipermail/";
+        String pushHead = "http://icedtea.classpath.org/hg/";
+        String pushBranch = "http://icedtea.classpath.org/hg/release/";
         if (string.startsWith(distro)) {
             r[0] = "distro-pkg";
             return r;
@@ -432,6 +434,14 @@
             r[0] = "openjdk";
             return r;
         }
+        if (string.startsWith(pushBranch)) {
+            r[0] = "push (branch)";
+            return r;
+        }
+        if (string.startsWith(pushHead)) {
+            r[0] = "push (head)";
+            return r;
+        }
         return r;
 
     }
@@ -459,5 +469,11 @@
 
         q = createBug("http://lists.fedoraproject.org/pipermail/chinese/2012-January/008868.html");
         System.out.println(q[0] + " : " + q[1]);
+        
+        q = createBug("http://icedtea.classpath.org/hg/icedtea-web/rev/22b7becd48a7");
+        System.out.println(q[0] + " : " + q[1]);
+        
+        q = createBug("http://icedtea.classpath.org/hg/release/icedtea-web-1.6/rev/0d9faf51357d");
+        System.out.println(q[0] + " : " + q[1]);
     }
 }
diff -r ba6519dd5e79 -r 263e152a6084 tests/netx/unit/net/sourceforge/jnlp/ParserMalformedXml.java
--- a/tests/netx/unit/net/sourceforge/jnlp/ParserMalformedXml.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/tests/netx/unit/net/sourceforge/jnlp/ParserMalformedXml.java	Tue Jan 26 15:18:30 2016 +0100
@@ -42,7 +42,10 @@
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.IOException;
+import net.sourceforge.jnlp.annotations.Bug;
 import net.sourceforge.jnlp.annotations.KnownToFail;
+import net.sourceforge.jnlp.util.FileUtils;
+import org.junit.Assert;
 
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -105,5 +108,21 @@
         String malformedJnlp = originalJnlp.replace("'jnlp.jnlp'", "jnlp.jnlp");
         Parser.getRootNode(new ByteArrayInputStream(malformedJnlp.getBytes()), new ParserSettings(false, true, false));
     }
+    
+    
+    @Bug(id = "PR2690")
+    @Test
+    public void testXmlBomTagSoupOff() throws ParseException {
+        InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream("net/sourceforge/jnlp/templates/EFBBBF.jnlp");
+        Assert.assertNotNull(is);
+        Parser.getRootNode(is, new ParserSettings(false, true, false));
+    }
+
+    @Test
+    public void testXmlBomTagSoupOn() throws ParseException {
+        InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream("net/sourceforge/jnlp/templates/EFBBBF.jnlp");
+        Assert.assertNotNull(is);
+        Parser.getRootNode(is, new ParserSettings(false, true, true));
+    }
 
 }
diff -r ba6519dd5e79 -r 263e152a6084 tests/netx/unit/net/sourceforge/jnlp/ParserTest.java
--- a/tests/netx/unit/net/sourceforge/jnlp/ParserTest.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/tests/netx/unit/net/sourceforge/jnlp/ParserTest.java	Tue Jan 26 15:18:30 2016 +0100
@@ -44,12 +44,13 @@
 import java.util.Locale;
 
 import net.sourceforge.jnlp.mock.MockJNLPFile;
+import net.sourceforge.jnlp.util.logging.NoStdOutErrTest;
 
 import org.junit.Assert;
 import org.junit.Test;
 
 /** Test various corner cases of the parser */
-public class ParserTest {
+public class ParserTest extends NoStdOutErrTest {
 
     private static final String LANG = "en";
     private static final String COUNTRY = "CA";
@@ -59,6 +60,8 @@
     private static final Locale ALL_LOCALE = new Locale(LANG, COUNTRY, VARIANT);
 
     ParserSettings defaultParser=new ParserSettings();
+    ParserSettings strictParser=new ParserSettings(true, true, true);
+    
     @Test(expected = MissingInformationException.class)
     public void testMissingInfoFullLocale() throws ParseException {
         String data = "<jnlp></jnlp>\n";
@@ -1439,4 +1442,193 @@
         Assert.assertEquals(true, eex != null);
         Assert.assertEquals(true, eex instanceof ParseException);
     }
+    
+    
+    @Test
+    public void testNullMainClassApplication() throws Exception {
+        String data = "<?xml version=\"1.0\"?>\n"
+                + "<jnlp codebase=\"http://someNotExistingUrl.com\"  >\n"
+                + "<application-desc>\n"
+                + "</application-desc>\n"
+                + "</jnlp>";
+
+        Node root1 = Parser.getRootNode(new ByteArrayInputStream(data.getBytes()), defaultParser);
+        Assert.assertEquals("Root name is not jnlp", "jnlp", root1.getNodeName());
+        MockJNLPFile file1 = new MockJNLPFile(LANG_LOCALE);
+        Parser parser1 = new Parser(file1, null, root1, defaultParser, null);
+        String main1 = parser1.getLauncher(root1).getMainClass();
+        Assert.assertEquals(null, main1);
+        
+        //strict also ok
+        Node root2 = Parser.getRootNode(new ByteArrayInputStream(data.getBytes()), strictParser);
+        Assert.assertEquals("Root name is not jnlp", "jnlp", root2.getNodeName());
+        MockJNLPFile file2 = new MockJNLPFile(LANG_LOCALE);
+        Parser parser2 = new Parser(file2, null, root2, defaultParser, null);
+        String main2 = parser2.getLauncher(root2).getMainClass();
+        Assert.assertEquals(null, main2);
+
+    }
+    
+    @Test
+    public void testNullMainClassInstaller() throws Exception {
+        String data = "<?xml version=\"1.0\"?>\n"
+                + "<jnlp codebase=\"http://someNotExistingUrl.com\"  >\n"
+                + "<installer-desc>\n"
+                + "</installer-desc>\n"
+                + "</jnlp>";
+
+        Node root1 = Parser.getRootNode(new ByteArrayInputStream(data.getBytes()), defaultParser);
+        Assert.assertEquals("Root name is not jnlp", "jnlp", root1.getNodeName());
+        MockJNLPFile file1 = new MockJNLPFile(LANG_LOCALE);
+        Parser parser1 = new Parser(file1, null, root1, defaultParser, null);
+        String main1 = parser1.getLauncher(root1).getMainClass();
+        Assert.assertEquals(null, main1);
+        
+        //strict also ok
+        Node root2 = Parser.getRootNode(new ByteArrayInputStream(data.getBytes()), strictParser);
+        Assert.assertEquals("Root name is not jnlp", "jnlp", root2.getNodeName());
+        MockJNLPFile file2 = new MockJNLPFile(LANG_LOCALE);
+        Parser parser2 = new Parser(file2, null, root2, strictParser, null);
+        String main2 = parser2.getLauncher(root2).getMainClass();
+        Assert.assertEquals(null, main2);
+
+    }
+    
+      @Test(expected = ParseException.class)
+    public void testNullMainClassApplet() throws Exception {
+        String data = "<?xml version=\"1.0\"?>\n"
+                + "<jnlp codebase=\"http://someNotExistingUrl.com\"  >\n"
+                + "<applet-desc>\n"
+                + "</applet-desc>\n"
+                + "</jnlp>";
+
+        Node root1 = Parser.getRootNode(new ByteArrayInputStream(data.getBytes()), defaultParser);
+        Assert.assertEquals("Root name is not jnlp", "jnlp", root1.getNodeName());
+        MockJNLPFile file1 = new MockJNLPFile(LANG_LOCALE);
+        Parser parser1 = new Parser(file1, null, root1, defaultParser, null);
+        parser1.getLauncher(root1).getMainClass();
+        //both throw
+    }
+    
+    
+    @Test
+    public void testOkMainClassApplication() throws Exception {
+        String data = "<?xml version=\"1.0\"?>\n"
+                + "<jnlp codebase=\"http://someNotExistingUrl.com\"  >\n"
+                + "<application-desc main-class=\"some.main.class\">\n"
+                + "</application-desc>\n"
+                + "</jnlp>";
+
+        Node root1 = Parser.getRootNode(new ByteArrayInputStream(data.getBytes()), defaultParser);
+        Assert.assertEquals("Root name is not jnlp", "jnlp", root1.getNodeName());
+        MockJNLPFile file1 = new MockJNLPFile(LANG_LOCALE);
+        Parser parser1 = new Parser(file1, null, root1, defaultParser, null);
+        String main1 = parser1.getLauncher(root1).getMainClass();
+        Assert.assertEquals("some.main.class", main1);
+        
+        //strict also ok
+        Node root2 = Parser.getRootNode(new ByteArrayInputStream(data.getBytes()), strictParser);
+        Assert.assertEquals("Root name is not jnlp", "jnlp", root2.getNodeName());
+        MockJNLPFile file2 = new MockJNLPFile(LANG_LOCALE);
+        Parser parser2 = new Parser(file2, null, root2, strictParser, null);
+        String main2 = parser2.getLauncher(root2).getMainClass();
+        Assert.assertEquals("some.main.class", main2);
+
+    }
+    
+    
+     @Test(expected = ParseException.class)
+    public void testNeedToBeTrimmed1MainClassApplication() throws Exception {
+        String data = "<?xml version=\"1.0\"?>\n"
+                + "<jnlp codebase=\"http://someNotExistingUrl.com\"  >\n"
+                + "<application-desc main-class=\"  some.main.class  \">\n"
+                + "</application-desc>\n"
+                + "</jnlp>";
+
+        Node root1 = Parser.getRootNode(new ByteArrayInputStream(data.getBytes()), defaultParser);
+        Assert.assertEquals("Root name is not jnlp", "jnlp", root1.getNodeName());
+        MockJNLPFile file1 = new MockJNLPFile(LANG_LOCALE);
+        Parser parser1 = new Parser(file1, null, root1, defaultParser, null);
+        String main1 = parser1.getLauncher(root1).getMainClass();
+        Assert.assertEquals("some.main.class", main1);
+        
+        //strict throws
+        Node root2 = Parser.getRootNode(new ByteArrayInputStream(data.getBytes()), strictParser);
+        Assert.assertEquals("Root name is not jnlp", "jnlp", root2.getNodeName());
+        MockJNLPFile file2 = new MockJNLPFile(LANG_LOCALE);
+        Parser parser2 = new Parser(file2, null, root2, strictParser, null);
+        parser2.getLauncher(root2).getMainClass();
+
+    }
+    
+    @Test(expected = ParseException.class)
+    public void testNeedToBeTrimmed2MainClassApplication() throws Exception {
+        String data = "<?xml version=\"1.0\"?>\n"
+                + "<jnlp codebase=\"http://someNotExistingUrl.com\"  >\n"
+                + "<application-desc main-class=\"\nsome.main.class\t\">\n"
+                + "</application-desc>\n"
+                + "</jnlp>";
+
+        Node root1 = Parser.getRootNode(new ByteArrayInputStream(data.getBytes()), defaultParser);
+        Assert.assertEquals("Root name is not jnlp", "jnlp", root1.getNodeName());
+        MockJNLPFile file1 = new MockJNLPFile(LANG_LOCALE);
+        Parser parser1 = new Parser(file1, null, root1, defaultParser, null);
+        String main1 = parser1.getLauncher(root1).getMainClass();
+        Assert.assertEquals("some.main.class", main1);
+        
+        //strict throws
+        Node root2 = Parser.getRootNode(new ByteArrayInputStream(data.getBytes()), strictParser);
+        Assert.assertEquals("Root name is not jnlp", "jnlp", root2.getNodeName());
+        MockJNLPFile file2 = new MockJNLPFile(LANG_LOCALE);
+        Parser parser2 = new Parser(file2, null, root2, strictParser, null);
+        parser2.getLauncher(root2).getMainClass();
+
+    }
+    
+    @Test(expected = ParseException.class)
+    public void testSpacesInsidePersistedMainClassApplication() throws Exception {
+        String data = "<?xml version=\"1.0\"?>\n"
+                + "<jnlp codebase=\"http://someNotExistingUrl.com\"  >\n"
+                + "<application-desc main-class=\"\nsom e.main .class\t\">\n"
+                + "</application-desc>\n"
+                + "</jnlp>";
+
+        Node root1 = Parser.getRootNode(new ByteArrayInputStream(data.getBytes()), defaultParser);
+        Assert.assertEquals("Root name is not jnlp", "jnlp", root1.getNodeName());
+        MockJNLPFile file1 = new MockJNLPFile(LANG_LOCALE);
+        Parser parser1 = new Parser(file1, null, root1, defaultParser, null);
+        String main1 = parser1.getLauncher(root1).getMainClass();
+        Assert.assertEquals("som e.main .class", main1);
+        
+        //strict throws
+        Node root2 = Parser.getRootNode(new ByteArrayInputStream(data.getBytes()), strictParser);
+        Assert.assertEquals("Root name is not jnlp", "jnlp", root2.getNodeName());
+        MockJNLPFile file2 = new MockJNLPFile(LANG_LOCALE);
+        Parser parser2 = new Parser(file2, null, root2, strictParser, null);
+        parser2.getLauncher(root2).getMainClass();
+    }
+    
+    @Test(expected = ParseException.class)
+    public void testSpacesAroundDots() throws Exception {
+        String data = "<?xml version=\"1.0\"?>\n"
+                + "<jnlp codebase=\"http://someNotExistingUrl.com\"  >\n"
+                + "<application-desc main-class=\"\nsome\t.\nanother . main\t.class. here\t\">\n"
+                + "</application-desc>\n"
+                + "</jnlp>";
+
+        Node root1 = Parser.getRootNode(new ByteArrayInputStream(data.getBytes()), defaultParser);
+        Assert.assertEquals("Root name is not jnlp", "jnlp", root1.getNodeName());
+        MockJNLPFile file1 = new MockJNLPFile(LANG_LOCALE);
+        Parser parser1 = new Parser(file1, null, root1, defaultParser, null);
+        String main1 = parser1.getLauncher(root1).getMainClass();
+        Assert.assertEquals("some . another . main .class. here", main1);
+        
+        //strict throws
+        Node root2 = Parser.getRootNode(new ByteArrayInputStream(data.getBytes()), strictParser);
+        Assert.assertEquals("Root name is not jnlp", "jnlp", root2.getNodeName());
+        MockJNLPFile file2 = new MockJNLPFile(LANG_LOCALE);
+        Parser parser2 = new Parser(file2, null, root2, strictParser, null);
+        parser2.getLauncher(root2).getMainClass();
+    }
+
 }
diff -r ba6519dd5e79 -r 263e152a6084 tests/netx/unit/net/sourceforge/jnlp/PluginBridgeTest.java
--- a/tests/netx/unit/net/sourceforge/jnlp/PluginBridgeTest.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/tests/netx/unit/net/sourceforge/jnlp/PluginBridgeTest.java	Tue Jan 26 15:18:30 2016 +0100
@@ -520,7 +520,5 @@
         String fixed = fixCommonIssues(source, true);
         checkIssuesFixed(fixed, true, false);
     }
-    
-    
 
 }
diff -r ba6519dd5e79 -r 263e152a6084 tests/netx/unit/net/sourceforge/jnlp/SecurityDescTest.java
--- a/tests/netx/unit/net/sourceforge/jnlp/SecurityDescTest.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/tests/netx/unit/net/sourceforge/jnlp/SecurityDescTest.java	Tue Jan 26 15:18:30 2016 +0100
@@ -48,7 +48,7 @@
     public void testNotNullJnlpFile() throws Exception {
         Throwable t = null;
         try {
-            new SecurityDesc(new DummyJNLPFile(), SecurityDesc.SANDBOX_PERMISSIONS, "hey!");
+            new SecurityDesc(new DummyJNLPFile(), SecurityDesc.SANDBOX_PERMISSIONS, null);
         } catch (Exception ex) {
             t = ex;
         }
@@ -57,7 +57,7 @@
 
     @Test(expected = NullPointerException.class)
     public void testNullJnlpFile() throws Exception {
-        new SecurityDesc(null, SecurityDesc.SANDBOX_PERMISSIONS, "hey!");
+        new SecurityDesc(null, SecurityDesc.SANDBOX_PERMISSIONS, null);
     }
 
     @Test
diff -r ba6519dd5e79 -r 263e152a6084 tests/netx/unit/net/sourceforge/jnlp/cache/ResourceDownloaderTest.java
--- a/tests/netx/unit/net/sourceforge/jnlp/cache/ResourceDownloaderTest.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/tests/netx/unit/net/sourceforge/jnlp/cache/ResourceDownloaderTest.java	Tue Jan 26 15:18:30 2016 +0100
@@ -19,7 +19,6 @@
 import java.util.jar.Pack200;
 import java.util.zip.GZIPOutputStream;
 
-
 import org.junit.AfterClass;
 import org.junit.Assert;
 import org.junit.BeforeClass;
@@ -35,7 +34,7 @@
 import net.sourceforge.jnlp.util.logging.NoStdOutErrTest;
 import net.sourceforge.jnlp.util.logging.OutputController;
 
-public class ResourceDownloaderTest extends NoStdOutErrTest{
+public class ResourceDownloaderTest extends NoStdOutErrTest {
 
     public static ServerLauncher testServer;
     public static ServerLauncher testServerWithBrokenHead;
@@ -78,7 +77,6 @@
         OutputController.getLogger().setOut(new PrintStream(currentErrorStream));
         OutputController.getLogger().setErr(new PrintStream(currentErrorStream));
 
-
     }
 
     @AfterClass
@@ -130,7 +128,8 @@
         redirectErr();
         try {
             File f = File.createTempFile(nameStub1, nameStub2);
-            int i = ResourceDownloader.getUrlResponseCode(testServer.getUrl(f.getName()), new HashMap<String, String>(), ResourceTracker.RequestMethods.HEAD);            Assert.assertEquals(HttpURLConnection.HTTP_OK, i);
+            int i = ResourceDownloader.getUrlResponseCode(testServer.getUrl(f.getName()), new HashMap<String, String>(), ResourceTracker.RequestMethods.HEAD);
+            Assert.assertEquals(HttpURLConnection.HTTP_OK, i);
             f.delete();
             i = ResourceDownloader.getUrlResponseCode(testServer.getUrl(f.getName()), new HashMap<String, String>(), ResourceTracker.RequestMethods.HEAD);
             Assert.assertEquals(HttpURLConnection.HTTP_NOT_FOUND, i);
@@ -227,30 +226,29 @@
             Resource r2 = Resource.getResource(testServerWithBrokenHead.getUrl(fileForServerWithoutHeader.getName()), null, UpdatePolicy.NEVER);
             Resource r3 = Resource.getResource(testServer.getUrl(versionedFileForServerWithHeader.getName()), new Version("1.0"), UpdatePolicy.NEVER);
             Resource r4 = Resource.getResource(testServerWithBrokenHead.getUrl(versionedFileForServerWithoutHeader.getName()), new Version("1.0"), UpdatePolicy.NEVER);
-            assertOnServerWithHeader(resourceDownloader.findBestUrl(r1));
-            assertVersionedOneOnServerWithHeader(resourceDownloader.findBestUrl(r3));
-            assertOnServerWithoutHeader(resourceDownloader.findBestUrl(r2));
-            assertVersionedOneOnServerWithoutHeader(resourceDownloader.findBestUrl(r4));
+            assertOnServerWithHeader(resourceDownloader.findBestUrl(r1).getURL());
+            assertVersionedOneOnServerWithHeader(resourceDownloader.findBestUrl(r3).URL);
+            assertOnServerWithoutHeader(resourceDownloader.findBestUrl(r2).URL);
+            assertVersionedOneOnServerWithoutHeader(resourceDownloader.findBestUrl(r4).URL);
 
             fileForServerWithHeader.delete();
             Assert.assertNull(resourceDownloader.findBestUrl(r1));
-            assertVersionedOneOnServerWithHeader(resourceDownloader.findBestUrl(r3));
-            assertOnServerWithoutHeader(resourceDownloader.findBestUrl(r2));
-            assertVersionedOneOnServerWithoutHeader(resourceDownloader.findBestUrl(r4));
+            assertVersionedOneOnServerWithHeader(resourceDownloader.findBestUrl(r3).URL);
+            assertOnServerWithoutHeader(resourceDownloader.findBestUrl(r2).URL);
+            assertVersionedOneOnServerWithoutHeader(resourceDownloader.findBestUrl(r4).URL);
 
             versionedFileForServerWithHeader.delete();
             Assert.assertNull(resourceDownloader.findBestUrl(r1));
             Assert.assertNull(resourceDownloader.findBestUrl(r3));
-            assertOnServerWithoutHeader(resourceDownloader.findBestUrl(r2));
-            assertVersionedOneOnServerWithoutHeader(resourceDownloader.findBestUrl(r4));
+            assertOnServerWithoutHeader(resourceDownloader.findBestUrl(r2).URL);
+            assertVersionedOneOnServerWithoutHeader(resourceDownloader.findBestUrl(r4).URL);
 
             versionedFileForServerWithoutHeader.delete();
             Assert.assertNull(resourceDownloader.findBestUrl(r1));
             Assert.assertNull(resourceDownloader.findBestUrl(r3));
-            assertOnServerWithoutHeader(resourceDownloader.findBestUrl(r2));
+            assertOnServerWithoutHeader(resourceDownloader.findBestUrl(r2).URL);
             Assert.assertNull(resourceDownloader.findBestUrl(r4));
 
-
             fileForServerWithoutHeader.delete();
             Assert.assertNull(resourceDownloader.findBestUrl(r1));
             Assert.assertNull(resourceDownloader.findBestUrl(r3));
@@ -283,6 +281,7 @@
         assertPort(u, testServer.getPort());
         assertVersion(u);
     }
+
     private void assertCommonComponentsOfUrl(URL u) {
         Assert.assertTrue(u.getProtocol().equals("http"));
         Assert.assertTrue(u.getHost().equals("localhost"));
@@ -311,7 +310,7 @@
         redirectErrBack();
 
         cacheDir = PathsAndFiles.CACHE_DIR.getFullPath();
-       PathsAndFiles.CACHE_DIR.setValue(System.getProperty("java.io.tmpdir") + File.separator + "tempcache");
+        PathsAndFiles.CACHE_DIR.setValue(System.getProperty("java.io.tmpdir") + File.separator + "tempcache");
     }
 
     @AfterClass
diff -r ba6519dd5e79 -r 263e152a6084 tests/netx/unit/net/sourceforge/jnlp/runtime/CodeBaseClassLoaderTest.java
--- a/tests/netx/unit/net/sourceforge/jnlp/runtime/CodeBaseClassLoaderTest.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/tests/netx/unit/net/sourceforge/jnlp/runtime/CodeBaseClassLoaderTest.java	Tue Jan 26 15:18:30 2016 +0100
@@ -42,13 +42,10 @@
 
 import java.lang.reflect.Field;
 import java.net.URL;
-import java.util.Locale;
 
 import net.sourceforge.jnlp.JNLPFile;
 import net.sourceforge.jnlp.NullJnlpFileException;
-import net.sourceforge.jnlp.ResourcesDesc;
 import net.sourceforge.jnlp.SecurityDesc;
-import net.sourceforge.jnlp.SecurityDescTest;
 import net.sourceforge.jnlp.ServerAccess;
 import net.sourceforge.jnlp.runtime.JNLPClassLoader.CodeBaseClassLoader;
 import net.sourceforge.jnlp.annotations.Bug;
@@ -66,16 +63,21 @@
 public class CodeBaseClassLoaderTest extends NoStdOutErrTest {
 
     private static AppletSecurityLevel level;
+    private static String macStatus;
 
     @BeforeClass
     public static void setPermissions() {
         level = AppletStartupSecuritySettings.getInstance().getSecurityLevel();
+        macStatus = JNLPRuntime.getConfiguration().getProperty(DeploymentConfiguration.KEY_ENABLE_MANIFEST_ATTRIBUTES_CHECK);
         JNLPRuntime.getConfiguration().setProperty(DeploymentConfiguration.KEY_SECURITY_LEVEL, AppletSecurityLevel.ALLOW_UNSIGNED.toChars());
+        JNLPRuntime.getConfiguration().setProperty(DeploymentConfiguration.KEY_ENABLE_MANIFEST_ATTRIBUTES_CHECK, ManifestAttributesChecker.MANIFEST_ATTRIBUTES_CHECK.NONE.toString());
+        
     }
 
     @AfterClass
     public static void resetPermissions() {
         JNLPRuntime.getConfiguration().setProperty(DeploymentConfiguration.KEY_SECURITY_LEVEL, level.toChars());
+        JNLPRuntime.getConfiguration().setProperty(DeploymentConfiguration.KEY_ENABLE_MANIFEST_ATTRIBUTES_CHECK, macStatus);
     }
 
     private static final String isWSA = "isWebstartApplication";
diff -r ba6519dd5e79 -r 263e152a6084 tests/netx/unit/net/sourceforge/jnlp/security/appletextendedsecurity/UnsignedAppletTrustConfirmationTest.java
--- a/tests/netx/unit/net/sourceforge/jnlp/security/appletextendedsecurity/UnsignedAppletTrustConfirmationTest.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/tests/netx/unit/net/sourceforge/jnlp/security/appletextendedsecurity/UnsignedAppletTrustConfirmationTest.java	Tue Jan 26 15:18:30 2016 +0100
@@ -55,6 +55,7 @@
 import net.sourceforge.jnlp.security.appletextendedsecurity.impl.UnsignedAppletActionStorageImpl;
 import net.sourceforge.jnlp.security.dialogs.apptrustwarningpanel.UnsignedAppletTrustWarningPanel;
 import net.sourceforge.jnlp.util.FileUtils;
+import net.sourceforge.jnlp.util.UrlUtils;
 import org.junit.AfterClass;
 import org.junit.Assert;
 import org.junit.BeforeClass;
@@ -168,28 +169,28 @@
     @Test
     public void testSripFile() throws Exception {
         String sample = "http://aa.bb/";
-        String result = UnsignedAppletTrustConfirmation.stripFile(new URL(sample));
+        String result = UrlUtils.stripFile(new URL(sample));
         assertEquals(sample, result);
         sample = "http://aa.bb";
-        result = UnsignedAppletTrustConfirmation.stripFile(new URL(sample));
+        result = UrlUtils.stripFile(new URL(sample));
         assertEquals(sample + "/", result);
         sample = "http://aa.bb/";
-        result = UnsignedAppletTrustConfirmation.stripFile(new URL(sample + "cc"));
+        result = UrlUtils.stripFile(new URL(sample + "cc"));
         assertEquals(sample, result);
         sample = "http://aa.bb/cc/";
-        result = UnsignedAppletTrustConfirmation.stripFile(new URL(sample));
+        result = UrlUtils.stripFile(new URL(sample));
         assertEquals(sample, result);
         sample = "http://aa.bb/some/complicated/";
-        result = UnsignedAppletTrustConfirmation.stripFile(new URL(sample + "some"));
+        result = UrlUtils.stripFile(new URL(sample + "some"));
         assertEquals(sample, result);
         sample = "http://aa.bb/some/complicated/some/";
-        result = UnsignedAppletTrustConfirmation.stripFile(new URL(sample));
+        result = UrlUtils.stripFile(new URL(sample));
         assertEquals(sample, result);
         sample = "http://aa.bb/some/";
-        result = UnsignedAppletTrustConfirmation.stripFile(new URL(sample + "strange?a=b"));
+        result = UrlUtils.stripFile(new URL(sample + "strange?a=b"));
         assertEquals(sample, result);
         sample = "http://aa.bb/some/strange/";
-        result = UnsignedAppletTrustConfirmation.stripFile(new URL(sample + "?a=b"));
+        result = UrlUtils.stripFile(new URL(sample + "?a=b"));
         assertEquals(sample, result);
         
     }
diff -r ba6519dd5e79 -r 263e152a6084 tests/netx/unit/net/sourceforge/jnlp/security/dialogs/apptrustwarningpanel/AppTrustWarningPanelTest.java
--- a/tests/netx/unit/net/sourceforge/jnlp/security/dialogs/apptrustwarningpanel/AppTrustWarningPanelTest.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/tests/netx/unit/net/sourceforge/jnlp/security/dialogs/apptrustwarningpanel/AppTrustWarningPanelTest.java	Tue Jan 26 15:18:30 2016 +0100
@@ -14,6 +14,7 @@
 import net.sourceforge.jnlp.PluginParameters;
 import net.sourceforge.jnlp.browsertesting.browsers.firefox.FirefoxProfilesOperator;
 import net.sourceforge.jnlp.config.PathsAndFiles;
+import net.sourceforge.jnlp.security.dialogs.SecurityDialogPanel;
 import org.junit.AfterClass;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -138,7 +139,7 @@
     public void testHtmlWrap() throws Exception {
         final String testText = "This is some text";
         final String expectedResult = "<html>This is some text</html>";
-        final String actualResult = UnsignedAppletTrustWarningPanel.htmlWrap(testText);
+        final String actualResult = SecurityDialogPanel.htmlWrap(testText);
         assertEquals("htmlWrap should properly wrap text with HTML tags", expectedResult, actualResult);
     }
 
diff -r ba6519dd5e79 -r 263e152a6084 tests/netx/unit/net/sourceforge/jnlp/templates/EFBBBF.jnlp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/netx/unit/net/sourceforge/jnlp/templates/EFBBBF.jnlp	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,59 @@
+﻿<!--
+
+This file is part of IcedTea.
+
+IcedTea is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+IcedTea is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with IcedTea; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version.
+
+ -->
+<!--
+This file is starting with EF BB BF bytes,
+but depends on your editor if yu can see them as ï»¿ or not at all.
+I fnot, use hexaeditor to verify
+-->
+<?xml version="1.0" encoding="utf-8"?>
+<jnlp spec="1.0" href="EFBBBF.jnlp" codebase=".">
+  <information>
+    <title>EFBBBF bytes starting with file</title>
+    <vendor>IcedTea</vendor>
+    <homepage href="http://icedtea.classpath.org/wiki/IcedTea-Web#Testing_IcedTea-Web"/>
+<!-- see http://icedtea.classpath.org/bugzilla/show_bug.cgi?id=2690-->
+    <description>File starting with xml BOM EFBBBF bytes</description>
+    <offline/>
+  </information>
+  <resources>
+    <j2se version="1.4+"/>
+    <jar href="simpletest1.jar"/>
+  </resources>
+  <application-desc main-class="SimpleTest1">
+  </application-desc>
+</jnlp>
diff -r ba6519dd5e79 -r 263e152a6084 tests/netx/unit/net/sourceforge/jnlp/util/UrlUtilsTest.java
--- a/tests/netx/unit/net/sourceforge/jnlp/util/UrlUtilsTest.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/tests/netx/unit/net/sourceforge/jnlp/util/UrlUtilsTest.java	Tue Jan 26 15:18:30 2016 +0100
@@ -42,6 +42,7 @@
 import static org.junit.Assert.assertTrue;
 
 import java.io.File;
+import java.net.MalformedURLException;
 import java.net.URL;
 import net.sourceforge.jnlp.annotations.KnownToFail;
 import org.junit.Assert;
@@ -245,6 +246,34 @@
         
     }
     
+     @Test
+    public void removeFileName3() throws Exception {
+        URL l1 = UrlUtils.removeFileName(new URL("http://aaa.bb/xyz/hchkr/jar.jar?someParam=some&param=very\\evil\\"));
+        assertEquals(l1, new URL("http://aaa.bb/xyz/hchkr"));
+
+        URL l2 = UrlUtils.removeFileName(new URL("http://aaa.bb/xyz/hchkr/?another=Param&param=very/evil/"));
+        assertEquals(l2, new URL("http://aaa.bb/xyz/hchkr"));
+
+        URL l3 = UrlUtils.removeFileName(new URL("http://aaa.bb/xyz/hchkr?stillSomePArams=aa"));
+        assertEquals(l3, new URL("http://aaa.bb/xyz"));
+
+        URL l4 = UrlUtils.removeFileName(new URL("http://aaa.bb/xyz/jar.jar?again=param/bad\\bad/params"));
+        assertEquals(l4, new URL("http://aaa.bb/xyz"));
+
+        URL l5 = UrlUtils.removeFileName(new URL("http://aaa.bb/xyz/?goingOnWith=params/bad/params"));
+        assertEquals(l5, new URL("http://aaa.bb/xyz"));
+
+        URL l6 = UrlUtils.removeFileName(new URL("http://aaa.bb/xyz?someParam=some"));
+        assertEquals(l6, new URL("http://aaa.bb"));
+
+        URL l7 = UrlUtils.removeFileName(new URL("http://aaa.bb/jar.jar?someParam=some"));
+        assertEquals(l7, new URL("http://aaa.bb"));
+
+        URL l8 = UrlUtils.removeFileName(new URL("http://aaa.bb/?someParam=some"));
+        assertEquals(l8, new URL("http://aaa.bb"));
+
+    }
+    
     @Test
     public void testUrlEquals() throws Exception {
         final URL n1 = null, n2 = null, u1 = new URL("http://example.com"), u2 = u1, u3 = new URL("http://example.com");
@@ -325,5 +354,62 @@
         Assert.assertFalse(UrlUtils.compareNullableStrings("BBB", "aaa", false));
 
     }
+    
+    @Test
+    public void sanitizePortTest() throws MalformedURLException {
+        Assert.assertEquals(0, UrlUtils.getSanitizedPort(new URL("http://aaa.cz:0")));
+        Assert.assertEquals(1, UrlUtils.getSanitizedPort(new URL("https://aaa.cz:1")));
+        Assert.assertEquals(100, UrlUtils.getSanitizedPort(new URL("ftp://aaa.cz:100")));
+        //Assert.assertEquals(1001, UrlUtils.getSanitizedPort(new URL("ssh://aaa.cz:1001"))); unknown protocol :(
+        //Assert.assertEquals(22, UrlUtils.getSanitizedPort(new URL("ssh://aaa.cz")));
+        Assert.assertEquals(80, UrlUtils.getSanitizedPort(new URL("http://aaa.cz")));
+        Assert.assertEquals(443, UrlUtils.getSanitizedPort(new URL("https://aaa.cz")));
+        Assert.assertEquals(21, UrlUtils.getSanitizedPort(new URL("ftp://aaa.cz")));
+        
+   }
 
+    @Test
+    public void getPortTest() throws MalformedURLException {
+        Assert.assertEquals(1, UrlUtils.getPort(new URL("http://aa.bb:1")));
+        Assert.assertEquals(10, UrlUtils.getPort(new URL("http://aa.bb:10/aa")));
+        Assert.assertEquals(1000, UrlUtils.getPort(new URL("http://aa.bb:1000/aa.fs")));
+        Assert.assertEquals(443, UrlUtils.getPort(new URL("https://aa.bb/aa.fs")));
+        Assert.assertEquals(80, UrlUtils.getPort(new URL("http://aa.bb")));
+        Assert.assertEquals(80, UrlUtils.getPort(new URL("http://aa.bb:80/a/b/c")));
+    }
+
+    @Test
+    public void getHostAndPortTest() throws MalformedURLException {
+        Assert.assertEquals("aa.bb:2", UrlUtils.getHostAndPort(new URL("http://aa.bb:2")));
+        Assert.assertEquals("aa.bb:12", UrlUtils.getHostAndPort(new URL("http://aa.bb:12/aa")));
+        Assert.assertEquals("aa.bb:1002", UrlUtils.getHostAndPort(new URL("http://aa.bb:1002/aa.fs")));
+        Assert.assertEquals("aa.bb:443", UrlUtils.getHostAndPort(new URL("https://aa.bb/aa.fs")));
+        Assert.assertEquals("aa.bb:80", UrlUtils.getHostAndPort(new URL("http://aa.bb")));
+        Assert.assertEquals("aa.bb:80", UrlUtils.getHostAndPort(new URL("http://aa.bb:80/a/b/c")));
+    }
+    
+    @Test
+    public void ensureSlashTailTest() {
+        Assert.assertEquals("a/", UrlUtils.ensureSlashTail("a"));
+        Assert.assertEquals("aa/a/", UrlUtils.ensureSlashTail("aa/a"));
+        Assert.assertEquals("aa/a/", UrlUtils.ensureSlashTail("aa/a/"));
+        Assert.assertEquals("/aa/a/", UrlUtils.ensureSlashTail("/aa/a/"));
+        Assert.assertEquals("/aa/a/", UrlUtils.ensureSlashTail("/aa/a"));
+        
+        Assert.assertEquals("aa\\a\\", UrlUtils.ensureSlashTail("aa\\a"));
+        Assert.assertEquals("aa\\a\\", UrlUtils.ensureSlashTail("aa\\a\\"));
+        Assert.assertEquals("\\aa\\a\\", UrlUtils.ensureSlashTail("\\aa\\a\\"));
+        Assert.assertEquals("\\aa\\a\\", UrlUtils.ensureSlashTail("\\aa\\a"));
+        
+        Assert.assertEquals("\\aa/a/", UrlUtils.ensureSlashTail("\\aa/a"));
+        Assert.assertEquals("//aa\\a/", UrlUtils.ensureSlashTail("//aa\\a"));
+        Assert.assertEquals("\\aa/a/", UrlUtils.ensureSlashTail("\\aa/a/"));
+        Assert.assertEquals("\\aa/a\\", UrlUtils.ensureSlashTail("\\aa/a\\"));
+    }
+    
+     @Test
+    public void ensureSlashTailTest3() throws MalformedURLException {
+        Assert.assertEquals("http://aa.bb:2/aa/", UrlUtils.ensureSlashTail(new URL("http://aa.bb:2/aa")).toExternalForm());
+        Assert.assertEquals("http://aa.bb/aa/", UrlUtils.ensureSlashTail(new URL("http://aa.bb/aa/")).toExternalForm());
+    }
 }
diff -r ba6519dd5e79 -r 263e152a6084 tests/netx/unit/net/sourceforge/jnlp/util/logging/FileLogTest.java
--- a/tests/netx/unit/net/sourceforge/jnlp/util/logging/FileLogTest.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/tests/netx/unit/net/sourceforge/jnlp/util/logging/FileLogTest.java	Tue Jan 26 15:18:30 2016 +0100
@@ -40,6 +40,7 @@
 import java.io.IOException;
 import net.sourceforge.jnlp.closinglisteners.RulesFolowingClosingListener;
 import net.sourceforge.jnlp.util.StreamUtils;
+import net.sourceforge.jnlp.util.logging.filelogs.LogBasedFileLog;
 import org.junit.AfterClass;
 import org.junit.Assert;
 import org.junit.BeforeClass;
@@ -47,13 +48,13 @@
 
 public class FileLogTest {
 
-    private static File[] loggingTargets = new File[12];
-    private static String line1 = "I'm logged line one";
-    private static String line2 = "I'm logged line two";
-    private static String line3 = "I'm logged line three";
-    private static RulesFolowingClosingListener.ContainsRule r1 = new RulesFolowingClosingListener.ContainsRule(line1);
-    private static RulesFolowingClosingListener.ContainsRule r2 = new RulesFolowingClosingListener.ContainsRule(line2);
-    private static RulesFolowingClosingListener.ContainsRule r3 = new RulesFolowingClosingListener.ContainsRule(line3);
+    private static final File[] loggingTargets = new File[12];
+    private static final String line1 = "I'm logged line one";
+    private static final String line2 = "I'm logged line two";
+    private static final String line3 = "I'm logged line three";
+    private static final RulesFolowingClosingListener.ContainsRule r1 = new RulesFolowingClosingListener.ContainsRule(line1);
+    private static final RulesFolowingClosingListener.ContainsRule r2 = new RulesFolowingClosingListener.ContainsRule(line2);
+    private static final RulesFolowingClosingListener.ContainsRule r3 = new RulesFolowingClosingListener.ContainsRule(line3);
 
     @BeforeClass
     public static void prepareTmpFiles() throws IOException {
@@ -78,7 +79,7 @@
     @Test
     public void isAppendingLoggerLoggingOnNotExisitngFile() throws Exception {
         int i = 0;
-        FileLog l = new FileLog(loggingTargets[i].getAbsolutePath(), true);
+        LogBasedFileLog l = new LogBasedFileLog(loggingTargets[i].getAbsolutePath(), true);
         l.log(line1);
         String s = StreamUtils.readStreamAsString(new FileInputStream(loggingTargets[i]), true);
         Assert.assertTrue(r1.evaluate(s));
@@ -87,7 +88,7 @@
     @Test
     public void isRewritingLoggerLoggingOnNotExisitngFile() throws Exception {
         int i = 1;
-        FileLog l = new FileLog(loggingTargets[i].getAbsolutePath(), false);
+        LogBasedFileLog l = new LogBasedFileLog(loggingTargets[i].getAbsolutePath(), false);
         l.log(line1);
         String s = StreamUtils.readStreamAsString(new FileInputStream(loggingTargets[i]), true);
         Assert.assertTrue(r1.evaluate(s));
@@ -96,12 +97,12 @@
     @Test
     public void isRewritingLoggerRewritingOnNotExisitngFile() throws Exception {
         int i = 2;
-        FileLog l1 = new FileLog(loggingTargets[i].getAbsolutePath(), false);
+        LogBasedFileLog l1 = new LogBasedFileLog(loggingTargets[i].getAbsolutePath(), false);
         l1.log(line2);
         String s1 = StreamUtils.readStreamAsString(new FileInputStream(loggingTargets[i]), true);
         Assert.assertTrue(r2.evaluate(s1));
         l1.close();
-        FileLog l2 = new FileLog(loggingTargets[i].getAbsolutePath(), false);
+        LogBasedFileLog l2 = new LogBasedFileLog(loggingTargets[i].getAbsolutePath(), false);
         l2.log(line3);
         String s2 = StreamUtils.readStreamAsString(new FileInputStream(loggingTargets[i]), true);
         Assert.assertFalse(r2.evaluate(s2));
@@ -112,12 +113,12 @@
     @Test
     public void isAppendingLoggerAppendingOnNotExisitngFile() throws Exception {
         int i = 4;
-        FileLog l1 = new FileLog(loggingTargets[i].getAbsolutePath(), true);
+        LogBasedFileLog l1 = new LogBasedFileLog(loggingTargets[i].getAbsolutePath(), true);
         l1.log(line2);
         String s1 = StreamUtils.readStreamAsString(new FileInputStream(loggingTargets[i]), true);
         Assert.assertTrue(r2.evaluate(s1));
         l1.close();
-        FileLog l2 = new FileLog(loggingTargets[i].getAbsolutePath(), true);
+        LogBasedFileLog l2 = new LogBasedFileLog(loggingTargets[i].getAbsolutePath(), true);
         l2.log(line3);
         String s2 = StreamUtils.readStreamAsString(new FileInputStream(loggingTargets[i]), true);
         Assert.assertTrue(r2.evaluate(s2));
@@ -129,7 +130,7 @@
     @Test
     public void isAppendingLoggerLoggingOnExisitngFile() throws Exception {
         int i = 6;
-        FileLog l = new FileLog(loggingTargets[i].getAbsolutePath(), true);
+        LogBasedFileLog l = new LogBasedFileLog(loggingTargets[i].getAbsolutePath(), true);
         l.log(line1);
         String s = StreamUtils.readStreamAsString(new FileInputStream(loggingTargets[i]), true);
         Assert.assertTrue(r1.evaluate(s));
@@ -138,7 +139,7 @@
     @Test
     public void isRewritingLoggerLoggingOnExisitngFile() throws Exception {
         int i = 7;
-        FileLog l = new FileLog(loggingTargets[i].getAbsolutePath(), false);
+        LogBasedFileLog l = new LogBasedFileLog(loggingTargets[i].getAbsolutePath(), false);
         l.log(line1);
         String s = StreamUtils.readStreamAsString(new FileInputStream(loggingTargets[i]), true);
         Assert.assertTrue(r1.evaluate(s));
@@ -147,12 +148,12 @@
     @Test
     public void isRewritingLoggerRewritingOnExisitngFile() throws Exception {
         int i = 8;
-        FileLog l1 = new FileLog(loggingTargets[i].getAbsolutePath(), false);
+        LogBasedFileLog l1 = new LogBasedFileLog(loggingTargets[i].getAbsolutePath(), false);
         l1.log(line2);
         String s1 = StreamUtils.readStreamAsString(new FileInputStream(loggingTargets[i]), true);
         Assert.assertTrue(r2.evaluate(s1));
         l1.close();
-        FileLog l2 = new FileLog(loggingTargets[i].getAbsolutePath(), false);
+        LogBasedFileLog l2 = new LogBasedFileLog(loggingTargets[i].getAbsolutePath(), false);
         l2.log(line3);
         String s2 = StreamUtils.readStreamAsString(new FileInputStream(loggingTargets[i]), true);
         Assert.assertFalse(r2.evaluate(s2));
@@ -163,12 +164,12 @@
     @Test
     public void isAppendingLoggerAppendingOnExisitngFile() throws Exception {
         int i = 10;
-        FileLog l1 = new FileLog(loggingTargets[i].getAbsolutePath(), true);
+        LogBasedFileLog l1 = new LogBasedFileLog(loggingTargets[i].getAbsolutePath(), true);
         l1.log(line2);
         String s1 = StreamUtils.readStreamAsString(new FileInputStream(loggingTargets[i]), true);
         Assert.assertTrue(r2.evaluate(s1));
         l1.close();
-        FileLog l2 = new FileLog(loggingTargets[i].getAbsolutePath(), true);
+        LogBasedFileLog l2 = new LogBasedFileLog(loggingTargets[i].getAbsolutePath(), true);
         l2.log(line3);
         String s2 = StreamUtils.readStreamAsString(new FileInputStream(loggingTargets[i]), true);
         Assert.assertTrue(r2.evaluate(s2));
diff -r ba6519dd5e79 -r 263e152a6084 tests/netx/unit/net/sourceforge/jnlp/util/logging/OutputControllerTest.java
--- a/tests/netx/unit/net/sourceforge/jnlp/util/logging/OutputControllerTest.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/tests/netx/unit/net/sourceforge/jnlp/util/logging/OutputControllerTest.java	Tue Jan 26 15:18:30 2016 +0100
@@ -42,6 +42,7 @@
 import java.util.Random;
 import net.sourceforge.jnlp.closinglisteners.RulesFolowingClosingListener;
 import net.sourceforge.jnlp.util.StreamUtils;
+import net.sourceforge.jnlp.util.logging.filelogs.WriterBasedFileLog;
 import org.junit.Assert;
 import org.junit.After;
 import org.junit.Before;
@@ -49,18 +50,18 @@
 
 public class OutputControllerTest {
 
-    private static String line1 = "I'm logged line one";
-    private static String line2 = "I'm logged line two";
-    private static String line3 = "I'm logged line three";
-    private static String line4 = "I'm logged line four";
-    private static String line5 = "I'm logged line five";
-    private static String line6 = "I'm logged line six";
-    private static RulesFolowingClosingListener.ContainsRule r1 = new RulesFolowingClosingListener.ContainsRule(line1);
-    private static RulesFolowingClosingListener.ContainsRule r2 = new RulesFolowingClosingListener.ContainsRule(line2);
-    private static RulesFolowingClosingListener.ContainsRule r3 = new RulesFolowingClosingListener.ContainsRule(line3);
-    private static RulesFolowingClosingListener.ContainsRule r4 = new RulesFolowingClosingListener.ContainsRule(line4);
-    private static RulesFolowingClosingListener.ContainsRule r5 = new RulesFolowingClosingListener.ContainsRule(line5);
-    private static RulesFolowingClosingListener.ContainsRule r6 = new RulesFolowingClosingListener.ContainsRule(line6);
+    private static final String line1 = "I'm logged line one";
+    private static final String line2 = "I'm logged line two";
+    private static final String line3 = "I'm logged line three";
+    private static final String line4 = "I'm logged line four";
+    private static final String line5 = "I'm logged line five";
+    private static final String line6 = "I'm logged line six";
+    private static final RulesFolowingClosingListener.ContainsRule r1 = new RulesFolowingClosingListener.ContainsRule(line1);
+    private static final RulesFolowingClosingListener.ContainsRule r2 = new RulesFolowingClosingListener.ContainsRule(line2);
+    private static final RulesFolowingClosingListener.ContainsRule r3 = new RulesFolowingClosingListener.ContainsRule(line3);
+    private static final RulesFolowingClosingListener.ContainsRule r4 = new RulesFolowingClosingListener.ContainsRule(line4);
+    private static final RulesFolowingClosingListener.ContainsRule r5 = new RulesFolowingClosingListener.ContainsRule(line5);
+    private static final RulesFolowingClosingListener.ContainsRule r6 = new RulesFolowingClosingListener.ContainsRule(line6);
 
     private static class AccessiblePrintStream extends PrintStream {
 
@@ -201,7 +202,7 @@
 
                     File f = File.createTempFile("replacedFilelogger", "itwTest");
                     f.deleteOnExit();
-                    oc.setFileLog(new FileLog(f.getAbsolutePath(), false));
+                    oc.setFileLog(new WriterBasedFileLog(f.getAbsolutePath(), false));
                     LogConfig.getLogConfig().setLogToFile(true);
 
                     ThreadGroup tg = new ThreadGroup("TerribleGroup");
@@ -322,7 +323,7 @@
         File f2 = File.createTempFile("replacedFilelogger", "itwTest");
         f1.deleteOnExit();
         f2.deleteOnExit();
-        oc.setFileLog(new FileLog(f1.getAbsolutePath(), false));
+        oc.setFileLog(new WriterBasedFileLog(f1.getAbsolutePath(), false));
         LogConfig.getLogConfig().setLogToFile(true);
         oc.log(OutputController.Level.MESSAGE_ALL, line1);
         oc.log(OutputController.Level.ERROR_ALL, line2);
@@ -338,7 +339,7 @@
         Assert.assertTrue(r3.evaluate(s1));
         Assert.assertFalse(r3.evaluate(s2));
 
-        oc.setFileLog(new FileLog(f2.getAbsolutePath(), false));
+        oc.setFileLog(new WriterBasedFileLog(f2.getAbsolutePath(), false));
         oc.log(OutputController.Level.ERROR_ALL, line5);
         oc.log(OutputController.Level.MESSAGE_ALL, line5);
         oc.flush();
diff -r ba6519dd5e79 -r 263e152a6084 tests/netx/unit/net/sourceforge/jnlp/util/logging/WriterBasedFileLogTest.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/netx/unit/net/sourceforge/jnlp/util/logging/WriterBasedFileLogTest.java	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,179 @@
+/*Copyright (C) 2013 Red Hat, Inc.
+
+ This file is part of IcedTea.
+
+ IcedTea is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, version 2.
+
+ IcedTea is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with IcedTea; see the file COPYING.  If not, write to
+ the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301 USA.
+
+ Linking this library statically or dynamically with other modules is
+ making a combined work based on this library.  Thus, the terms and
+ conditions of the GNU General Public License cover the whole
+ combination.
+
+ As a special exception, the copyright holders of this library give you
+ permission to link this library with independent modules to produce an
+ executable, regardless of the license terms of these independent
+ modules, and to copy and distribute the resulting executable under
+ terms of your choice, provided that you also meet, for each linked
+ independent module, the terms and conditions of the license of that
+ module.  An independent module is a module which is not derived from
+ or based on this library.  If you modify this library, you may extend
+ this exception to your version of the library, but you are not
+ obligated to do so.  If you do not wish to do so, delete this
+ exception statement from your version.
+ */
+package net.sourceforge.jnlp.util.logging;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import net.sourceforge.jnlp.closinglisteners.RulesFolowingClosingListener;
+import net.sourceforge.jnlp.util.StreamUtils;
+import net.sourceforge.jnlp.util.logging.filelogs.WriterBasedFileLog;
+import org.junit.AfterClass;
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+public class WriterBasedFileLogTest {
+
+    private static final File[] loggingTargets = new File[12];
+    private static final String line1 = "I'm logged line one";
+    private static final String line2 = "I'm logged line two";
+    private static final String line3 = "I'm logged line three";
+    private static final RulesFolowingClosingListener.ContainsRule r1 = new RulesFolowingClosingListener.ContainsRule(line1);
+    private static final RulesFolowingClosingListener.ContainsRule r2 = new RulesFolowingClosingListener.ContainsRule(line2);
+    private static final RulesFolowingClosingListener.ContainsRule r3 = new RulesFolowingClosingListener.ContainsRule(line3);
+
+    @BeforeClass
+    public static void prepareTmpFiles() throws IOException {
+        for (int i = 0; i < loggingTargets.length; i++) {
+            loggingTargets[i] = File.createTempFile("WriterBasedFileLogger", "iteTest");
+            loggingTargets[i].deleteOnExit();
+        }
+        //delete first half of the files, logger should handle both casses
+        for (int i = 0; i < loggingTargets.length / 2; i++) {
+            loggingTargets[i].delete();
+        }
+
+    }
+
+    @AfterClass
+    public static void cleanTmpFiles() throws IOException {
+        for (int i = 0; i < loggingTargets.length; i++) {
+            loggingTargets[i].delete();
+        }
+    }
+
+    @Test
+    public void isAppendingLoggerLoggingOnNotExisitngFile() throws Exception {
+        int i = 0;
+        WriterBasedFileLog l = new WriterBasedFileLog(loggingTargets[i].getAbsolutePath(), true);
+        l.log(line1);
+        String s = StreamUtils.readStreamAsString(new FileInputStream(loggingTargets[i]), true);
+        Assert.assertTrue(r1.evaluate(s));
+    }
+
+    @Test
+    public void isRewritingLoggerLoggingOnNotExisitngFile() throws Exception {
+        int i = 1;
+        WriterBasedFileLog l = new WriterBasedFileLog(loggingTargets[i].getAbsolutePath(), false);
+        l.log(line1);
+        String s = StreamUtils.readStreamAsString(new FileInputStream(loggingTargets[i]), true);
+        Assert.assertTrue(r1.evaluate(s));
+    }
+
+    @Test
+    public void isRewritingLoggerRewritingOnNotExisitngFile() throws Exception {
+        int i = 2;
+        WriterBasedFileLog l1 = new WriterBasedFileLog(loggingTargets[i].getAbsolutePath(), false);
+        l1.log(line2);
+        String s1 = StreamUtils.readStreamAsString(new FileInputStream(loggingTargets[i]), true);
+        Assert.assertTrue(r2.evaluate(s1));
+        l1.close();
+        WriterBasedFileLog l2 = new WriterBasedFileLog(loggingTargets[i].getAbsolutePath(), false);
+        l2.log(line3);
+        String s2 = StreamUtils.readStreamAsString(new FileInputStream(loggingTargets[i]), true);
+        Assert.assertFalse(r2.evaluate(s2));
+        Assert.assertTrue(r3.evaluate(s2));
+
+    }
+
+    @Test
+    public void isAppendingLoggerAppendingOnNotExisitngFile() throws Exception {
+        int i = 4;
+        WriterBasedFileLog l1 = new WriterBasedFileLog(loggingTargets[i].getAbsolutePath(), true);
+        l1.log(line2);
+        String s1 = StreamUtils.readStreamAsString(new FileInputStream(loggingTargets[i]), true);
+        Assert.assertTrue(r2.evaluate(s1));
+        l1.close();
+        WriterBasedFileLog l2 = new WriterBasedFileLog(loggingTargets[i].getAbsolutePath(), true);
+        l2.log(line3);
+        String s2 = StreamUtils.readStreamAsString(new FileInputStream(loggingTargets[i]), true);
+        Assert.assertTrue(r2.evaluate(s2));
+        Assert.assertTrue(r3.evaluate(s2));
+
+    }
+
+    //************
+    @Test
+    public void isAppendingLoggerLoggingOnExisitngFile() throws Exception {
+        int i = 6;
+        WriterBasedFileLog l = new WriterBasedFileLog(loggingTargets[i].getAbsolutePath(), true);
+        l.log(line1);
+        String s = StreamUtils.readStreamAsString(new FileInputStream(loggingTargets[i]), true);
+        Assert.assertTrue(r1.evaluate(s));
+    }
+
+    @Test
+    public void isRewritingLoggerLoggingOnExisitngFile() throws Exception {
+        int i = 7;
+        WriterBasedFileLog l = new WriterBasedFileLog(loggingTargets[i].getAbsolutePath(), false);
+        l.log(line1);
+        String s = StreamUtils.readStreamAsString(new FileInputStream(loggingTargets[i]), true);
+        Assert.assertTrue(r1.evaluate(s));
+    }
+
+    @Test
+    public void isRewritingLoggerRewritingOnExisitngFile() throws Exception {
+        int i = 8;
+        WriterBasedFileLog l1 = new WriterBasedFileLog(loggingTargets[i].getAbsolutePath(), false);
+        l1.log(line2);
+        String s1 = StreamUtils.readStreamAsString(new FileInputStream(loggingTargets[i]), true);
+        Assert.assertTrue(r2.evaluate(s1));
+        l1.close();
+        WriterBasedFileLog l2 = new WriterBasedFileLog(loggingTargets[i].getAbsolutePath(), false);
+        l2.log(line3);
+        String s2 = StreamUtils.readStreamAsString(new FileInputStream(loggingTargets[i]), true);
+        Assert.assertFalse(r2.evaluate(s2));
+        Assert.assertTrue(r3.evaluate(s2));
+
+    }
+
+    @Test
+    public void isAppendingLoggerAppendingOnExisitngFile() throws Exception {
+        int i = 10;
+        WriterBasedFileLog l1 = new WriterBasedFileLog(loggingTargets[i].getAbsolutePath(), true);
+        l1.log(line2);
+        String s1 = StreamUtils.readStreamAsString(new FileInputStream(loggingTargets[i]), true);
+        Assert.assertTrue(r2.evaluate(s1));
+        l1.close();
+        WriterBasedFileLog l2 = new WriterBasedFileLog(loggingTargets[i].getAbsolutePath(), true);
+        l2.log(line3);
+        String s2 = StreamUtils.readStreamAsString(new FileInputStream(loggingTargets[i]), true);
+        Assert.assertTrue(r2.evaluate(s2));
+        Assert.assertTrue(r3.evaluate(s2));
+
+    }
+}
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/custom/NoClassDeff/resources/NoClassDeff.html.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/reproducers/custom/NoClassDeff/resources/NoClassDeff.html.in	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,47 @@
+<!--
+
+This file is part of IcedTea.
+
+IcedTea is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+IcedTea is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with IcedTea; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version.
+
+ -->
+
+<html>
+<head></head>
+<body>
+	<applet code="NoClassDeff.class" archive="NoClassDeff.jar" codebase="." width="100" height="100">
+		<param name="die" value="DIE_ON_STAGE">
+                <param name="catchError" value="CATCH_ERROR">
+	</applet>
+</body>
+</html>
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/custom/NoClassDeff/resources/NoClassDeffApp.jnlp.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/reproducers/custom/NoClassDeff/resources/NoClassDeffApp.jnlp.in	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,56 @@
+<!--
+
+This file is part of IcedTea.
+
+IcedTea is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+IcedTea is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with IcedTea; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version.
+
+ -->
+
+<?xml version="1.0" encoding="utf-8"?>
+<jnlp spec="1.0" href="NoClassDeffApp.jnlp" codebase=".">
+  <information>
+	<title>NoClassDeff</title>
+    <vendor>IcedTea</vendor>
+    <homepage href="http://icedtea.classpath.org/wiki/IcedTea-Web#Testing_IcedTea-Web"/>
+    <description>PR2219</description>
+    <offline/>
+  </information>
+  <resources>
+    <j2se version="1.4+"/>
+    <jar href="NoClassDeff.jar"/>
+  </resources>
+  <application-desc main-class="NoClassDeff">
+ 	<argument>DIE_ON_STAGE</argument> <!-- die -->
+        <argument>CATCH_ERROR</argument> <!-- catch -->
+  </application-desc>
+</jnlp>
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/custom/NoClassDeff/resources/NoClassDeffApplet.jnlp.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/reproducers/custom/NoClassDeff/resources/NoClassDeffApplet.jnlp.in	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,60 @@
+<!--
+
+This file is part of IcedTea.
+
+IcedTea is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+IcedTea is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with IcedTea; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version.
+
+ -->
+
+<?xml version="1.0" encoding="utf-8"?>
+<jnlp spec="1.0" href="NoClassDeffApplet.jnlp" codebase=".">
+	<information>
+    	<title>NoClassDeff</title>
+    	<vendor>IcedTea</vendor>
+    	<homepage href="http://icedtea.classpath.org/wiki/IcedTea-Web#Testing_IcedTea-Web"/>
+    	<description>PR2219</description>
+    	<offline/>
+	</information>
+	<resources>
+	  	<j2se version="1.4+"/>
+		<jar href="NoClassDeff.jar"/>
+	</resources>
+	<applet-desc
+	  name="NoClassDeff"
+	  main-class="NoClassDeff"
+	  width="100"
+	  height="100">
+		<param name="die" value="DIE_ON_STAGE">
+                <param name="catchError" value="CATCH_ERROR">
+	</applet-desc>
+</jnlp>
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/custom/NoClassDeff/resources/NoClassDeffJnlpHref.html.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/reproducers/custom/NoClassDeff/resources/NoClassDeffJnlpHref.html.in	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,48 @@
+<!--
+
+This file is part of IcedTea.
+
+IcedTea is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+IcedTea is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with IcedTea; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version.
+
+ -->
+
+<html>
+<head></head>
+<body>
+	<applet width="100" height="100" code="NoClassDeff">
+		<param name="jnlp_href" value="NoClassDeffApplet.jnlp">
+		<param name="die" value="DIE_ON_STAGE">
+                <param name="catchError" value="CATCH_ERROR">
+	</applet>
+</body>
+</html>
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/custom/NoClassDeff/srcs/Makefile
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/reproducers/custom/NoClassDeff/srcs/Makefile	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,33 @@
+TESTNAME=NoClassDeff
+
+SRC_FILES=NoClassDeff
+ENTRYPOINT_CLASSES=NoClassDeff
+
+JAVAC_CLASSPATH=$(TEST_EXTENSIONS_DIR):$(NETX_DIR)/lib/classes.jar
+JAVAC=$(EXPORTED_JAVAC)
+JAR=$(EXPORTED_JAR)
+
+TMPDIR:=$(shell mktemp -d)
+
+prepare-reproducer:
+	echo PREPARING REPRODUCER $(TESTNAME);
+	pwd;
+	ls ;
+	$(JAVAC) -d $(TMPDIR) -classpath $(JAVAC_CLASSPATH) *.java;
+	#now the hack, remove inner class so we can later die on CNFE or NCDFE
+	ls $(TMPDIR)/
+	rm $(TMPDIR)/*\$$* ;  
+	ls $(TMPDIR)/
+	cp ../resources/* $(REPRODUCERS_TESTS_SERVER_DEPLOYDIR); \
+	for CLASS in $(ENTRYPOINT_CLASSES); \
+	do \
+		cd $(TMPDIR); \
+		$(JAR) cfe "$$CLASS.jar" "$$CLASS" "$$CLASS.class"; \
+		cd -;\
+		mv $(TMPDIR)/"$$CLASS.jar" $(REPRODUCERS_TESTS_SERVER_DEPLOYDIR); \
+	done; \
+	echo PREPARED REPRODUCER $(TESTNAME), removing $(TMPDIR) ; \
+	rm -rf $(TMPDIR)
+
+clean-reproducer:
+	echo NOTHING TO CLEAN FOR $(TESTNAME)
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/custom/NoClassDeff/srcs/NoClassDeff.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/reproducers/custom/NoClassDeff/srcs/NoClassDeff.java	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,154 @@
+/* ExtensionJnlpTestApplet.java
+ Copyright (C) 2013 Red Hat, Inc.
+
+ This file is part of IcedTea.
+
+ IcedTea is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, version 2.
+
+ IcedTea is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with IcedTea; see the file COPYING.  If not, write to
+ the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301 USA.
+
+ Linking this library statically or dynamically with other modules is
+ making a combined work based on this library.  Thus, the terms and
+ conditions of the GNU General Public License cover the whole
+ combination.
+
+ As a special exception, the copyright holders of this library give you
+ permission to link this library with independent modules to produce an
+ executable, regardless of the license terms of these independent
+ modules, and to copy and distribute the resulting executable under
+ terms of your choice, provided that you also meet, for each linked
+ independent module, the terms and conditions of the license of that
+ module.  An independent module is a module which is not derived from
+ or based on this library.  If you modify this library, you may extend
+ this exception to your version of the library, but you are not
+ obligated to do so.  If you do not wish to do so, delete this
+ exception statement from your version.
+ */
+
+import java.applet.*;
+import java.awt.Graphics;
+
+public class NoClassDeff extends Applet {
+
+    private static final String appletCloseString = "*** APPLET FINISHED ***";
+    private static String stage = null;
+    private static boolean catchError = false;
+
+    private static void checkStage() {
+        if (stage == null) {
+            throw new NullPointerException("satge cant be null");
+        }
+        System.out.println(stage);
+        System.out.println("catchError: " + catchError);
+    }
+
+    private static void lostClass() {
+        System.out.println("Loading LostClass");
+        System.out.flush();
+        if (catchError) {
+            try {
+                LostClass l = new LostClass();
+            } catch (Throwable ex) {// vs exception
+                System.out.println("EX: " + ex.toString());
+                System.out.flush();
+                ex.printStackTrace();
+            }
+        } else {
+            try {
+                LostClass l = new LostClass();
+            } catch (Exception ex) {// vs throwable
+                System.out.println("EX: " + ex.toString());
+                System.out.flush();
+                ex.printStackTrace();
+            }
+        }
+    }
+
+    private static class LostClass {
+
+    }
+
+    public static void main(String[] args) {
+        stage = args[0];
+        catchError = Boolean.valueOf(args[1]);
+        checkStage();
+        System.out.println("main1");
+        if (stage.equalsIgnoreCase("main")) {
+            lostClass();
+        }
+        System.out.println("main2");
+        System.out.println(appletCloseString);
+        System.out.flush();
+        System.out.println("some garbage");
+    }
+
+    @Override
+    public void init() {
+        stage = getParameter("die");
+        catchError = Boolean.valueOf(getParameter("catchError"));
+        System.out.println("init1");
+        if (stage.equalsIgnoreCase("init")) {
+            lostClass();
+        }
+        System.out.println("init2");
+    }
+
+    @Override
+    public void start() {
+        checkStage();
+        System.out.println("start1");
+        if (stage.equalsIgnoreCase("start")) {
+            lostClass();
+        }
+        System.out.println("start2");
+    }
+
+    @Override
+    public void stop() {
+        checkStage();
+        System.out.println("stop1");
+        if (stage.equalsIgnoreCase("stop")) {
+            lostClass();
+        }
+        System.out.println("stop2");
+        System.out.flush();
+        System.out.println("some garbage");
+    }
+
+    @Override
+    public void destroy() {
+        checkStage();
+        System.out.println("destroy1");
+        if (stage.equalsIgnoreCase("destroy")) {
+            lostClass();
+        }
+        System.out.println("destroy2");
+        System.out.flush();
+        System.out.println("some garbage");
+    }
+
+    @Override
+    public void paint(Graphics g) {
+        super.paint(g);
+        checkStage();
+        System.out.println("paint1");
+        if (stage.equalsIgnoreCase("paint")) {
+            lostClass();
+        }
+        System.out.println("paint2");
+        System.out.println(appletCloseString);
+        System.out.flush();
+        System.out.println("some garbage");
+    }
+
+}
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/custom/NoClassDeff/testcases/NoClassDeffTest.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/reproducers/custom/NoClassDeff/testcases/NoClassDeffTest.java	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,727 @@
+/* NoClassDeffTest.java
+ Copyright (C) 2013 Red Hat, Inc.
+
+ This file is part of IcedTea.
+
+ IcedTea is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, version 2.
+
+ IcedTea is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with IcedTea; see the file COPYING.  If not, write to
+ the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301 USA.
+
+ Linking this library statically or dynamically with other modules is
+ making a combined work based on this library.  Thus, the terms and
+ conditions of the GNU General Public License cover the whole
+ combination.
+
+ As a special exception, the copyright holders of this library give you
+ permission to link this library with independent modules to produce an
+ executable, regardless of the license terms of these independent
+ modules, and to copy and distribute the resulting executable under
+ terms of your choice, provided that you also meet, for each linked
+ independent module, the terms and conditions of the license of that
+ module.  An independent module is a module which is not derived from
+ or based on this library.  If you modify this library, you may extend
+ this exception to your version of the library, but you are not
+ obligated to do so.  If you do not wish to do so, delete this
+ exception statement from your version.
+ */
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+import net.sourceforge.jnlp.OptionsDefinitions;
+import net.sourceforge.jnlp.ProcessResult;
+import net.sourceforge.jnlp.ServerAccess;
+import net.sourceforge.jnlp.annotations.Bug;
+import net.sourceforge.jnlp.annotations.NeedsDisplay;
+import net.sourceforge.jnlp.annotations.TestInBrowsers;
+import net.sourceforge.jnlp.browsertesting.BrowserTest;
+import net.sourceforge.jnlp.browsertesting.Browsers;
+import net.sourceforge.jnlp.closinglisteners.AutoOkClosingListener;
+import net.sourceforge.jnlp.closinglisteners.StringBasedClosingListener;
+import net.sourceforge.jnlp.util.FileUtils;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+@Bug(id = "PR2219")
+/**
+ *
+ * When NoClassDefFound is thrown from ITW. Current behaviour: javaws app
+ * correctly dies browsers and -html correctly dies
+ *
+ * javaws applet SURVIVES init and start throwing this. But correctly dies in
+ * paint
+ *
+ *
+ */
+public class NoClassDeffTest extends BrowserTest {
+
+    private class NoClassDefFoundErrorClosingListener extends StringBasedClosingListener {
+
+        public NoClassDefFoundErrorClosingListener() {
+            super(NoClassDefFoundError.class.getSimpleName());
+        }
+
+    }
+
+    private static final String appletCloseString = AutoOkClosingListener.MAGICAL_OK_CLOSING_STRING;
+    private static final String[] HTMLA = new String[]{OptionsDefinitions.OPTIONS.HTML.option};
+    private static final List<String> HTMLL = Arrays.asList(HTMLA);
+
+    private static final String JNLPAPP = "NoClassDeffApp.jnlp";
+    private static final String JNLPAPPLET = "NoClassDeffApplet.jnlp";
+    private static final String HTML = "NoClassDeff.html";
+    private static final String HTMLHREF = "NoClassDeffJnlpHref.html";
+
+    //jnlp app OK run
+    @Test
+    @NeedsDisplay
+    public void noClassDeffTestWorksJnlp1() throws Exception {
+        prepare("okRun", false);
+        ProcessResult pr = server.executeJavaws(JNLPAPP, new AutoOkClosingListener(), null);
+        Assert.assertFalse(pr.stdout.contains("Loading LostClass"));
+        Assert.assertTrue(pr.stdout.contains("main1"));
+        Assert.assertTrue(pr.stdout.contains("main2"));
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertFalse(pr.stdout.contains("EX: "));
+    }
+
+    //jnlp bad run 1
+    @Test
+    @NeedsDisplay
+    public void noClassDeffTestThrowJnlp1() throws Exception {
+        prepare("main", false);
+        ProcessResult pr = server.executeJavaws(JNLPAPP, new AutoOkClosingListener(), null);
+        Assert.assertTrue(pr.stdout.contains("Loading LostClass"));
+        Assert.assertTrue(pr.stdout.contains("main1"));
+        Assert.assertFalse(pr.stdout.contains("main2"));
+        Assert.assertFalse(pr.stdout.contains(appletCloseString));
+        Assert.assertFalse(pr.stdout.contains("EX: "));
+    }
+
+    //jnlp bad run 2
+    @Test
+    @NeedsDisplay
+    public void noClassDeffTestThrowCatchJnlp1() throws Exception {
+        prepare("main", true);
+        ProcessResult pr = server.executeJavaws(JNLPAPP, new AutoOkClosingListener(), null);
+        Assert.assertTrue(pr.stdout.contains("Loading LostClass"));
+        Assert.assertTrue(pr.stdout.contains("main1"));
+        Assert.assertTrue(pr.stdout.contains("main2"));
+        Assert.assertTrue(pr.stdout.contains("EX: "));
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+    }
+
+    //applets  OK run
+    //opera should go correctly  up to destroy WITHOUT paint
+    //epiphany only start and init
+    //midori up to paint
+    //firefox, no data
+    //-html and jnlp applet get init, start, paint
+    @Test
+    @NeedsDisplay
+    @TestInBrowsers(testIn = {Browsers.one})
+    public void noClassDeffTestWorksHtml1() throws Exception {
+        prepare("okRun", false);
+        ProcessResult pr = server.executeBrowser(HTML, new AutoOkClosingListener(), null);
+        Assert.assertFalse(pr.stdout.contains("Loading LostClass"));
+        Assert.assertFalse(pr.stdout.contains("EX: "));
+        Assert.assertTrue(pr.stdout.contains("init1"));
+        Assert.assertTrue(pr.stdout.contains("init2"));
+        Assert.assertTrue(pr.stdout.contains("start1"));
+        Assert.assertTrue(pr.stdout.contains("start2"));
+//        Assert.assertTrue(pr.stdout.contains("paint1"));
+//        Assert.assertTrue(pr.stdout.contains("paint2"));
+//        Assert.assertTrue(pr.stdout.contains("stop1"));
+//        Assert.assertTrue(pr.stdout.contains("stop2"));
+//        Assert.assertTrue(pr.stdout.contains("destroy1"));
+//        Assert.assertTrue(pr.stdout.contains("destroy2"));
+//        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+    }
+
+    @Test
+    @NeedsDisplay
+    @TestInBrowsers(testIn = {Browsers.one})
+    public void noClassDeffTestWorksHtml2() throws Exception {
+        prepare("okRun", false);
+        ProcessResult pr = server.executeBrowser(HTMLHREF, new AutoOkClosingListener(), null);
+        Assert.assertFalse(pr.stdout.contains("Loading LostClass"));
+        Assert.assertFalse(pr.stdout.contains("EX: "));
+        Assert.assertTrue(pr.stdout.contains("init1"));
+        Assert.assertTrue(pr.stdout.contains("init2"));
+        Assert.assertTrue(pr.stdout.contains("start1"));
+        Assert.assertTrue(pr.stdout.contains("start2"));
+//        Assert.assertTrue(pr.stdout.contains("paint1"));
+//        Assert.assertTrue(pr.stdout.contains("paint2"));
+//        Assert.assertTrue(pr.stdout.contains("stop1"));
+//        Assert.assertTrue(pr.stdout.contains("stop2"));
+//        Assert.assertTrue(pr.stdout.contains("destroy1"));
+//        Assert.assertTrue(pr.stdout.contains("destroy2"));
+//        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+    }
+
+    @Test
+    @NeedsDisplay
+    public void noClassDeffTestWorksJnlp2() throws Exception {
+        prepare("okRun", false);
+        ProcessResult pr = server.executeJavaws(JNLPAPPLET, new AutoOkClosingListener(), null);
+        Assert.assertFalse(pr.stdout.contains("Loading LostClass"));
+        Assert.assertFalse(pr.stdout.contains("EX: "));
+        Assert.assertTrue(pr.stdout.contains("init1"));
+        Assert.assertTrue(pr.stdout.contains("init2"));
+        Assert.assertTrue(pr.stdout.contains("start1"));
+        Assert.assertTrue(pr.stdout.contains("start2"));
+        Assert.assertTrue(pr.stdout.contains("paint1"));
+        Assert.assertTrue(pr.stdout.contains("paint2"));
+//        Assert.assertTrue(pr.stdout.contains("stop1"));
+//        Assert.assertTrue(pr.stdout.contains("stop2"));
+//        Assert.assertTrue(pr.stdout.contains("destroy1"));
+//        Assert.assertTrue(pr.stdout.contains("destroy2"));
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+    }
+
+    @Test
+    @NeedsDisplay
+    @TestInBrowsers(testIn = {Browsers.one})
+    public void noClassDeffTestWorksJavawsHtml1() throws Exception {
+        prepare("okRun", false);
+        ProcessResult pr = server.executeJavaws(HTMLL, HTML, new AutoOkClosingListener(), null);
+        Assert.assertFalse(pr.stdout.contains("Loading LostClass"));
+        Assert.assertFalse(pr.stdout.contains("EX: "));
+        Assert.assertTrue(pr.stdout.contains("init1"));
+        Assert.assertTrue(pr.stdout.contains("init2"));
+        Assert.assertTrue(pr.stdout.contains("start1"));
+        Assert.assertTrue(pr.stdout.contains("start2"));
+//        Assert.assertTrue(pr.stdout.contains("paint1"));
+//        Assert.assertTrue(pr.stdout.contains("paint2"));
+//        Assert.assertTrue(pr.stdout.contains("stop1"));
+//        Assert.assertTrue(pr.stdout.contains("stop2"));
+//        Assert.assertTrue(pr.stdout.contains("destroy1"));
+//        Assert.assertTrue(pr.stdout.contains("destroy2"));
+    }
+
+    @Test
+    @NeedsDisplay
+    @TestInBrowsers(testIn = {Browsers.one})
+    public void noClassDeffTestWorksJavawsHtml2() throws Exception {
+        prepare("okRun", false);
+        ProcessResult pr = server.executeJavaws(HTMLL, HTMLHREF, new AutoOkClosingListener(), null);
+        Assert.assertFalse(pr.stdout.contains("Loading LostClass"));
+        Assert.assertFalse(pr.stdout.contains("EX: "));
+        Assert.assertTrue(pr.stdout.contains("init1"));
+        Assert.assertTrue(pr.stdout.contains("init2"));
+        Assert.assertTrue(pr.stdout.contains("start1"));
+        Assert.assertTrue(pr.stdout.contains("start2"));
+//        Assert.assertTrue(pr.stdout.contains("paint1"));
+//        Assert.assertTrue(pr.stdout.contains("paint2"));
+//        Assert.assertTrue(pr.stdout.contains("stop1"));
+//        Assert.assertTrue(pr.stdout.contains("stop2"));
+//        Assert.assertTrue(pr.stdout.contains("destroy1"));
+//        Assert.assertTrue(pr.stdout.contains("destroy2"));
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+    }
+
+    //jnlp applets crashes
+    //they behave a bit differently form browser ones
+    @Test
+    @NeedsDisplay
+    public void noClassDeffTestThrowsInitJnlp2() throws Exception {
+        prepare("init", false);
+        ProcessResult pr = server.executeJavaws(JNLPAPPLET, new AutoOkClosingListener(), new NoClassDefFoundErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains("Loading LostClass"));
+        Assert.assertFalse(pr.stdout.contains("EX: "));
+        Assert.assertFalse(pr.stderr.contains(NoClassDefFoundError.class.getSimpleName()));
+        Assert.assertTrue(pr.stdout.contains("init1"));
+        Assert.assertFalse(pr.stdout.contains("init2"));
+        Assert.assertFalse(pr.stdout.contains("start1"));
+        Assert.assertFalse(pr.stdout.contains("start2"));
+        Assert.assertTrue(pr.stdout.contains("paint1"));
+        Assert.assertTrue(pr.stdout.contains("paint2"));
+//        Assert.assertTrue(pr.stdout.contains("stop1"));
+//        Assert.assertTrue(pr.stdout.contains("stop2"));
+//        Assert.assertTrue(pr.stdout.contains("destroy1"));
+//        Assert.assertTrue(pr.stdout.contains("destroy2"));
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+    }
+
+    @Test
+    @NeedsDisplay
+    public void noClassDeffTestThrowsStartJnlp2() throws Exception {
+        prepare("start", false);
+        ProcessResult pr = server.executeJavaws(JNLPAPPLET, new AutoOkClosingListener(), new NoClassDefFoundErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains("Loading LostClass"));
+        Assert.assertFalse(pr.stdout.contains("EX: "));
+        Assert.assertFalse(pr.stderr.contains(NoClassDefFoundError.class.getSimpleName()));
+        Assert.assertTrue(pr.stdout.contains("init1"));
+        Assert.assertTrue(pr.stdout.contains("init2"));
+        Assert.assertTrue(pr.stdout.contains("start1"));
+        Assert.assertFalse(pr.stdout.contains("start2"));
+        Assert.assertTrue(pr.stdout.contains("paint1"));
+        Assert.assertTrue(pr.stdout.contains("paint2"));
+//        Assert.assertTrue(pr.stdout.contains("stop1"));
+//        Assert.assertTrue(pr.stdout.contains("stop2"));
+//        Assert.assertTrue(pr.stdout.contains("destroy1"));
+//        Assert.assertTrue(pr.stdout.contains("destroy2"));
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+    }
+
+    @Test
+    @NeedsDisplay
+    public void noClassDeffTestThrowsPaintJnlp2() throws Exception {
+        prepare("paint", false);
+        ProcessResult pr = server.executeJavaws(JNLPAPPLET, new AutoOkClosingListener(), new NoClassDefFoundErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains("Loading LostClass"));
+        Assert.assertFalse(pr.stdout.contains("EX: "));
+        Assert.assertTrue(pr.stderr.contains(NoClassDefFoundError.class.getSimpleName()));
+        Assert.assertTrue(pr.stdout.contains("init1"));
+        Assert.assertTrue(pr.stdout.contains("init2"));
+        Assert.assertTrue(pr.stdout.contains("start1"));
+        Assert.assertTrue(pr.stdout.contains("start2"));
+        Assert.assertTrue(pr.stdout.contains("paint1"));
+        Assert.assertFalse(pr.stdout.contains("paint2"));
+//        Assert.assertTrue(pr.stdout.contains("stop1"));
+//        Assert.assertTrue(pr.stdout.contains("stop2"));
+//        Assert.assertTrue(pr.stdout.contains("destroy1"));
+//        Assert.assertTrue(pr.stdout.contains("destroy2"));
+        Assert.assertFalse(pr.stdout.contains(appletCloseString));
+    }
+
+    @Test
+    @NeedsDisplay
+    public void noClassDeffTestThrowsCatchInitJnlp2() throws Exception {
+        prepare("init", true);
+        ProcessResult pr = server.executeJavaws(JNLPAPPLET, new AutoOkClosingListener(), null);
+        Assert.assertTrue(pr.stdout.contains("Loading LostClass"));
+        Assert.assertTrue(pr.stdout.contains("EX: "));
+        Assert.assertTrue(pr.stdout.contains("init1"));
+        Assert.assertTrue(pr.stdout.contains("init2"));
+        Assert.assertTrue(pr.stdout.contains("start1"));
+        Assert.assertTrue(pr.stdout.contains("start2"));
+        Assert.assertTrue(pr.stdout.contains("paint1"));
+        Assert.assertTrue(pr.stdout.contains("paint2"));
+//        Assert.assertTrue(pr.stdout.contains("stop1"));
+//        Assert.assertTrue(pr.stdout.contains("stop2"));
+//        Assert.assertTrue(pr.stdout.contains("destroy1"));
+//        Assert.assertTrue(pr.stdout.contains("destroy2"));
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+    }
+
+    @Test
+    @NeedsDisplay
+    public void noClassDeffTestThrowsCatchStartJnlp2() throws Exception {
+        prepare("start", true);
+        ProcessResult pr = server.executeJavaws(JNLPAPPLET, new AutoOkClosingListener(), null);
+        Assert.assertTrue(pr.stdout.contains("Loading LostClass"));
+        Assert.assertTrue(pr.stdout.contains("EX: "));
+        Assert.assertTrue(pr.stdout.contains("init1"));
+        Assert.assertTrue(pr.stdout.contains("init2"));
+        Assert.assertTrue(pr.stdout.contains("start1"));
+        Assert.assertTrue(pr.stdout.contains("start2"));
+        Assert.assertTrue(pr.stdout.contains("paint1"));
+        Assert.assertTrue(pr.stdout.contains("paint2"));
+//        Assert.assertTrue(pr.stdout.contains("stop1"));
+//        Assert.assertTrue(pr.stdout.contains("stop2"));
+//        Assert.assertTrue(pr.stdout.contains("destroy1"));
+//        Assert.assertTrue(pr.stdout.contains("destroy2"));
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+    }
+
+    @Test
+    @NeedsDisplay
+    public void noClassDeffTestThrowsCatchPaintJnlp2() throws Exception {
+        prepare("paint", true);
+        ProcessResult pr = server.executeJavaws(JNLPAPPLET, new AutoOkClosingListener(), null);
+        Assert.assertTrue(pr.stdout.contains("Loading LostClass"));
+        Assert.assertTrue(pr.stdout.contains("EX: "));
+        Assert.assertTrue(pr.stdout.contains("init1"));
+        Assert.assertTrue(pr.stdout.contains("init2"));
+        Assert.assertTrue(pr.stdout.contains("start1"));
+        Assert.assertTrue(pr.stdout.contains("start2"));
+        Assert.assertTrue(pr.stdout.contains("paint1"));
+        Assert.assertTrue(pr.stdout.contains("paint2"));
+//        Assert.assertTrue(pr.stdout.contains("stop1"));
+//        Assert.assertTrue(pr.stdout.contains("stop2"));
+//        Assert.assertTrue(pr.stdout.contains("destroy1"));
+//        Assert.assertTrue(pr.stdout.contains("destroy2"));
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+    }
+
+    //-html and browser crashes
+    //
+    //applets  crash init 1
+    @Test
+    @NeedsDisplay
+    @TestInBrowsers(testIn = {Browsers.one})
+    public void noClassDeffTestThrowsInitHtml1() throws Exception {
+        prepare("init", false);
+        ProcessResult pr = server.executeBrowser(HTML, null, new NoClassDefFoundErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains("Loading LostClass"));
+        Assert.assertFalse(pr.stdout.contains("EX: "));
+        Assert.assertTrue(pr.stderr.contains(NoClassDefFoundError.class.getSimpleName()));
+        Assert.assertTrue(pr.stdout.contains("init1"));
+        Assert.assertFalse(pr.stdout.contains("init2"));
+        Assert.assertFalse(pr.stdout.contains("start1"));
+        Assert.assertFalse(pr.stdout.contains("start2"));
+//        Assert.assertTrue(pr.stdout.contains("paint1"));
+//        Assert.assertTrue(pr.stdout.contains("paint2"));
+//        Assert.assertTrue(pr.stdout.contains("stop1"));
+//        Assert.assertTrue(pr.stdout.contains("stop2"));
+//        Assert.assertTrue(pr.stdout.contains("destroy1"));
+//        Assert.assertTrue(pr.stdout.contains("destroy2"));
+//        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+    }
+
+    @Test
+    @NeedsDisplay
+    @TestInBrowsers(testIn = {Browsers.one})
+    public void noClassDeffTestThrowsInitHtml2() throws Exception {
+        prepare("init", false);
+        ProcessResult pr = server.executeBrowser(HTMLHREF, null, new NoClassDefFoundErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains("Loading LostClass"));
+        Assert.assertFalse(pr.stdout.contains("EX: "));
+        Assert.assertTrue(pr.stderr.contains(NoClassDefFoundError.class.getSimpleName()));
+        Assert.assertTrue(pr.stdout.contains("init1"));
+        Assert.assertFalse(pr.stdout.contains("init2"));
+        Assert.assertFalse(pr.stdout.contains("start1"));
+        Assert.assertFalse(pr.stdout.contains("start2"));
+//        Assert.assertTrue(pr.stdout.contains("paint1"));
+//        Assert.assertTrue(pr.stdout.contains("paint2"));
+//        Assert.assertTrue(pr.stdout.contains("stop1"));
+//        Assert.assertTrue(pr.stdout.contains("stop2"));
+//        Assert.assertTrue(pr.stdout.contains("destroy1"));
+//        Assert.assertTrue(pr.stdout.contains("destroy2"));
+//        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+    }
+
+    @Test
+    @NeedsDisplay
+    @TestInBrowsers(testIn = {Browsers.one})
+    public void noClassDeffTestThrowsInitJavawsHtml1() throws Exception {
+        prepare("init", false);
+        ProcessResult pr = server.executeJavaws(HTMLL, HTML, null, new NoClassDefFoundErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains("Loading LostClass"));
+        Assert.assertFalse(pr.stdout.contains("EX: "));
+        Assert.assertTrue(pr.stdout.contains("init1"));
+        Assert.assertTrue(pr.stderr.contains(NoClassDefFoundError.class.getSimpleName()));
+        Assert.assertFalse(pr.stdout.contains("init2"));
+        Assert.assertFalse(pr.stdout.contains("start1"));
+        Assert.assertFalse(pr.stdout.contains("start2"));
+//        Assert.assertTrue(pr.stdout.contains("paint1"));
+//        Assert.assertTrue(pr.stdout.contains("paint2"));
+//        Assert.assertTrue(pr.stdout.contains("stop1"));
+//        Assert.assertTrue(pr.stdout.contains("stop2"));
+//        Assert.assertTrue(pr.stdout.contains("destroy1"));
+//        Assert.assertTrue(pr.stdout.contains("destroy2"));
+    }
+
+    @Test
+    @NeedsDisplay
+    @TestInBrowsers(testIn = {Browsers.one})
+    public void noClassDeffTestThrowsInitJavawsHtml2() throws Exception {
+        prepare("init", false);
+        ProcessResult pr = server.executeJavaws(HTMLL, HTMLHREF, null, new NoClassDefFoundErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains("Loading LostClass"));
+        Assert.assertFalse(pr.stdout.contains("EX: "));
+        Assert.assertTrue(pr.stderr.contains(NoClassDefFoundError.class.getSimpleName()));
+        Assert.assertTrue(pr.stdout.contains("init1"));
+        Assert.assertFalse(pr.stdout.contains("init2"));
+        Assert.assertFalse(pr.stdout.contains("start1"));
+        Assert.assertFalse(pr.stdout.contains("start2"));
+//        Assert.assertTrue(pr.stdout.contains("paint1"));
+//        Assert.assertTrue(pr.stdout.contains("paint2"));
+//        Assert.assertTrue(pr.stdout.contains("stop1"));
+//        Assert.assertTrue(pr.stdout.contains("stop2"));
+//        Assert.assertTrue(pr.stdout.contains("destroy1"));
+//        Assert.assertTrue(pr.stdout.contains("destroy2"));
+        Assert.assertFalse(pr.stdout.contains(appletCloseString));
+    }
+
+    //applets  crash start 1
+    @Test
+    @NeedsDisplay
+    @TestInBrowsers(testIn = {Browsers.one})
+    public void noClassDeffTestThrowsStartHtml1() throws Exception {
+        prepare("start", false);
+        ProcessResult pr = server.executeBrowser(HTML, null, new NoClassDefFoundErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains("Loading LostClass"));
+        Assert.assertFalse(pr.stdout.contains("EX: "));
+        Assert.assertTrue(pr.stderr.contains(NoClassDefFoundError.class.getSimpleName()));
+        Assert.assertTrue(pr.stdout.contains("init1"));
+        Assert.assertTrue(pr.stdout.contains("init2"));
+        Assert.assertTrue(pr.stdout.contains("start1"));
+        Assert.assertFalse(pr.stdout.contains("start2"));
+//        Assert.assertTrue(pr.stdout.contains("paint1"));
+//        Assert.assertTrue(pr.stdout.contains("paint2"));
+//        Assert.assertTrue(pr.stdout.contains("stop1"));
+//        Assert.assertTrue(pr.stdout.contains("stop2"));
+//        Assert.assertTrue(pr.stdout.contains("destroy1"));
+//        Assert.assertTrue(pr.stdout.contains("destroy2"));
+//        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+    }
+
+    @Test
+    @NeedsDisplay
+    @TestInBrowsers(testIn = {Browsers.one})
+    public void noClassDeffTestThrowsStartHtml2() throws Exception {
+        prepare("start", false);
+        ProcessResult pr = server.executeBrowser(HTMLHREF, null, new NoClassDefFoundErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains("Loading LostClass"));
+        Assert.assertFalse(pr.stdout.contains("EX: "));
+        Assert.assertTrue(pr.stderr.contains(NoClassDefFoundError.class.getSimpleName()));
+        Assert.assertTrue(pr.stdout.contains("init1"));
+        Assert.assertTrue(pr.stdout.contains("init2"));
+        Assert.assertTrue(pr.stdout.contains("start1"));
+        Assert.assertFalse(pr.stdout.contains("start2"));
+//        Assert.assertTrue(pr.stdout.contains("paint1"));
+//        Assert.assertTrue(pr.stdout.contains("paint2"));
+//        Assert.assertTrue(pr.stdout.contains("stop1"));
+//        Assert.assertTrue(pr.stdout.contains("stop2"));
+//        Assert.assertTrue(pr.stdout.contains("destroy1"));
+//        Assert.assertTrue(pr.stdout.contains("destroy2"));
+//        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+    }
+
+    @Test
+    @NeedsDisplay
+    @TestInBrowsers(testIn = {Browsers.one})
+    public void noClassDeffTestThrowsStartJavawsHtml1() throws Exception {
+        prepare("start", false);
+        ProcessResult pr = server.executeJavaws(HTMLL, HTML, null, new NoClassDefFoundErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains("Loading LostClass"));
+        Assert.assertFalse(pr.stdout.contains("EX: "));
+        Assert.assertTrue(pr.stdout.contains("init1"));
+        Assert.assertTrue(pr.stderr.contains(NoClassDefFoundError.class.getSimpleName()));
+        Assert.assertTrue(pr.stdout.contains("init2"));
+        Assert.assertTrue(pr.stdout.contains("start1"));
+        Assert.assertFalse(pr.stdout.contains("start2"));
+//        Assert.assertTrue(pr.stdout.contains("paint1"));
+//        Assert.assertTrue(pr.stdout.contains("paint2"));
+//        Assert.assertTrue(pr.stdout.contains("stop1"));
+//        Assert.assertTrue(pr.stdout.contains("stop2"));
+//        Assert.assertTrue(pr.stdout.contains("destroy1"));
+//        Assert.assertTrue(pr.stdout.contains("destroy2"));
+    }
+
+    @Test
+    @NeedsDisplay
+    @TestInBrowsers(testIn = {Browsers.one})
+    public void noClassDeffTestThrowsStartJavawsHtml2() throws Exception {
+        prepare("start", false);
+        ProcessResult pr = server.executeJavaws(HTMLL, HTMLHREF, null, new NoClassDefFoundErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains("Loading LostClass"));
+        Assert.assertFalse(pr.stdout.contains("EX: "));
+        Assert.assertTrue(pr.stderr.contains(NoClassDefFoundError.class.getSimpleName()));
+        Assert.assertTrue(pr.stdout.contains("init1"));
+        Assert.assertTrue(pr.stdout.contains("init2"));
+        Assert.assertTrue(pr.stdout.contains("start1"));
+        Assert.assertFalse(pr.stdout.contains("start2"));
+//        Assert.assertTrue(pr.stdout.contains("paint1"));
+//        Assert.assertTrue(pr.stdout.contains("paint2"));
+//        Assert.assertTrue(pr.stdout.contains("stop1"));
+//        Assert.assertTrue(pr.stdout.contains("stop2"));
+//        Assert.assertTrue(pr.stdout.contains("destroy1"));
+//        Assert.assertTrue(pr.stdout.contains("destroy2"));
+        Assert.assertFalse(pr.stdout.contains(appletCloseString));
+    }
+
+    private void prepare(String when, boolean catchError) throws IOException {
+        File dir = ServerAccess.getInstance().getDir();
+        String[] files = new String[]{"NoClassDeffApp.jnlp", "NoClassDeff.html", "NoClassDeffApplet.jnlp", "NoClassDeffJnlpHref.html"};
+        for (String file : files) {
+            String s = FileUtils.loadFileAsString(new File(dir, file + ".in"));
+            s = s.replaceAll("DIE_ON_STAGE", when);
+            s = s.replaceAll("CATCH_ERROR", String.valueOf(catchError));
+            FileUtils.saveFile(s, new File(dir, file));
+        }
+    }
+
+    //applets  crash init 2
+    @Test
+    @NeedsDisplay
+    @TestInBrowsers(testIn = {Browsers.one})
+    public void noClassDeffTestThrowsCatchInitHtml1() throws Exception {
+        prepare("init", true);
+        ProcessResult pr = server.executeBrowser(HTML, new AutoOkClosingListener(), null);
+        Assert.assertTrue(pr.stdout.contains("Loading LostClass"));
+        Assert.assertTrue(pr.stdout.contains("EX: "));
+        Assert.assertTrue(pr.stderr.contains(NoClassDefFoundError.class.getSimpleName()));
+        Assert.assertTrue(pr.stdout.contains("init1"));
+        Assert.assertTrue(pr.stdout.contains("init2"));
+        Assert.assertTrue(pr.stdout.contains("start1"));
+        Assert.assertTrue(pr.stdout.contains("start2"));
+//        Assert.assertTrue(pr.stdout.contains("paint1"));
+//        Assert.assertTrue(pr.stdout.contains("paint2"));
+//        Assert.assertTrue(pr.stdout.contains("stop1"));
+//        Assert.assertTrue(pr.stdout.contains("stop2"));
+//        Assert.assertTrue(pr.stdout.contains("destroy1"));
+//        Assert.assertTrue(pr.stdout.contains("destroy2"));
+//        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+    }
+
+    @Test
+    @NeedsDisplay
+    @TestInBrowsers(testIn = {Browsers.one})
+    public void noClassDeffTestThrowsCatchInitHtml2() throws Exception {
+        prepare("init", true);
+        ProcessResult pr = server.executeBrowser(HTMLHREF, new AutoOkClosingListener(), null);
+        Assert.assertTrue(pr.stdout.contains("Loading LostClass"));
+        Assert.assertTrue(pr.stdout.contains("EX: "));
+        Assert.assertTrue(pr.stderr.contains(NoClassDefFoundError.class.getSimpleName()));
+        Assert.assertTrue(pr.stdout.contains("init1"));
+        Assert.assertTrue(pr.stdout.contains("init2"));
+        Assert.assertTrue(pr.stdout.contains("start1"));
+        Assert.assertTrue(pr.stdout.contains("start2"));
+//        Assert.assertTrue(pr.stdout.contains("paint1"));
+//        Assert.assertTrue(pr.stdout.contains("paint2"));
+//        Assert.assertTrue(pr.stdout.contains("stop1"));
+//        Assert.assertTrue(pr.stdout.contains("stop2"));
+//        Assert.assertTrue(pr.stdout.contains("destroy1"));
+//        Assert.assertTrue(pr.stdout.contains("destroy2"));
+//        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+    }
+
+    @Test
+    @NeedsDisplay
+    @TestInBrowsers(testIn = {Browsers.one})
+    public void noClassDeffTestThrowsCatchInitJavawsHtml1() throws Exception {
+        prepare("init", true);
+        ProcessResult pr = server.executeJavaws(HTMLL, HTML, new AutoOkClosingListener(), null);
+        Assert.assertTrue(pr.stdout.contains("Loading LostClass"));
+        Assert.assertTrue(pr.stdout.contains("EX: "));
+        Assert.assertTrue(pr.stdout.contains("init1"));
+        Assert.assertTrue(pr.stderr.contains(NoClassDefFoundError.class.getSimpleName()));
+        Assert.assertTrue(pr.stdout.contains("init2"));
+        Assert.assertTrue(pr.stdout.contains("start1"));
+        Assert.assertTrue(pr.stdout.contains("start2"));
+//        Assert.assertTrue(pr.stdout.contains("paint1"));
+//        Assert.assertTrue(pr.stdout.contains("paint2"));
+//        Assert.assertTrue(pr.stdout.contains("stop1"));
+//        Assert.assertTrue(pr.stdout.contains("stop2"));
+//        Assert.assertTrue(pr.stdout.contains("destroy1"));
+//        Assert.assertTrue(pr.stdout.contains("destroy2"));
+    }
+
+    @Test
+    @NeedsDisplay
+    @TestInBrowsers(testIn = {Browsers.one})
+    public void noClassDeffTestThrowsCatchInitJavawsHtml2() throws Exception {
+        prepare("init", true);
+        ProcessResult pr = server.executeJavaws(HTMLL, HTMLHREF, new AutoOkClosingListener(), null);
+        Assert.assertTrue(pr.stdout.contains("Loading LostClass"));
+        Assert.assertTrue(pr.stdout.contains("EX: "));
+        Assert.assertTrue(pr.stderr.contains(NoClassDefFoundError.class.getSimpleName()));
+        Assert.assertTrue(pr.stdout.contains("init1"));
+        Assert.assertTrue(pr.stdout.contains("init2"));
+        Assert.assertTrue(pr.stdout.contains("start1"));
+        Assert.assertTrue(pr.stdout.contains("start2"));
+//        Assert.assertTrue(pr.stdout.contains("paint1"));
+//        Assert.assertTrue(pr.stdout.contains("paint2"));
+//        Assert.assertTrue(pr.stdout.contains("stop1"));
+//        Assert.assertTrue(pr.stdout.contains("stop2"));
+//        Assert.assertTrue(pr.stdout.contains("destroy1"));
+//        Assert.assertTrue(pr.stdout.contains("destroy2"));
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+    }
+
+    //applets  crash start 2
+    @Test
+    @NeedsDisplay
+    @TestInBrowsers(testIn = {Browsers.one})
+    public void noClassDeffTestThrowsCatchStartHtml1() throws Exception {
+        prepare("start", true);
+        ProcessResult pr = server.executeBrowser(HTML, new AutoOkClosingListener(), null);
+        Assert.assertTrue(pr.stdout.contains("Loading LostClass"));
+        Assert.assertTrue(pr.stdout.contains("EX: "));
+        Assert.assertTrue(pr.stderr.contains(NoClassDefFoundError.class.getSimpleName()));
+        Assert.assertTrue(pr.stdout.contains("init1"));
+        Assert.assertTrue(pr.stdout.contains("init2"));
+        Assert.assertTrue(pr.stdout.contains("start1"));
+        Assert.assertTrue(pr.stdout.contains("start2"));
+//        Assert.assertTrue(pr.stdout.contains("paint1"));
+//        Assert.assertTrue(pr.stdout.contains("paint2"));
+//        Assert.assertTrue(pr.stdout.contains("stop1"));
+//        Assert.assertTrue(pr.stdout.contains("stop2"));
+//        Assert.assertTrue(pr.stdout.contains("destroy1"));
+//        Assert.assertTrue(pr.stdout.contains("destroy2"));
+//        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+    }
+
+    @Test
+    @NeedsDisplay
+    @TestInBrowsers(testIn = {Browsers.one})
+    public void noClassDeffTestThrowsCatchStartHtml2() throws Exception {
+        prepare("start", true);
+        ProcessResult pr = server.executeBrowser(HTMLHREF, new AutoOkClosingListener(), null);
+        Assert.assertTrue(pr.stdout.contains("Loading LostClass"));
+        Assert.assertTrue(pr.stdout.contains("EX: "));
+        Assert.assertTrue(pr.stderr.contains(NoClassDefFoundError.class.getSimpleName()));
+        Assert.assertTrue(pr.stdout.contains("init1"));
+        Assert.assertTrue(pr.stdout.contains("init2"));
+        Assert.assertTrue(pr.stdout.contains("start1"));
+        Assert.assertTrue(pr.stdout.contains("start2"));
+//        Assert.assertTrue(pr.stdout.contains("paint1"));
+//        Assert.assertTrue(pr.stdout.contains("paint2"));
+//        Assert.assertTrue(pr.stdout.contains("stop1"));
+//        Assert.assertTrue(pr.stdout.contains("stop2"));
+//        Assert.assertTrue(pr.stdout.contains("destroy1"));
+//        Assert.assertTrue(pr.stdout.contains("destroy2"));
+//        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+    }
+
+    @Test
+    @NeedsDisplay
+    @TestInBrowsers(testIn = {Browsers.one})
+    public void noClassDeffTestThrowsCatchStartJavawsHtml1() throws Exception {
+        prepare("start", true);
+        ProcessResult pr = server.executeJavaws(HTMLL, HTML, new AutoOkClosingListener(), null);
+        Assert.assertTrue(pr.stdout.contains("Loading LostClass"));
+        Assert.assertTrue(pr.stdout.contains("EX: "));
+        Assert.assertTrue(pr.stdout.contains("init1"));
+        Assert.assertTrue(pr.stderr.contains(NoClassDefFoundError.class.getSimpleName()));
+        Assert.assertTrue(pr.stdout.contains("init2"));
+        Assert.assertTrue(pr.stdout.contains("start1"));
+        Assert.assertTrue(pr.stdout.contains("start2"));
+//        Assert.assertTrue(pr.stdout.contains("paint1"));
+//        Assert.assertTrue(pr.stdout.contains("paint2"));
+//        Assert.assertTrue(pr.stdout.contains("stop1"));
+//        Assert.assertTrue(pr.stdout.contains("stop2"));
+//        Assert.assertTrue(pr.stdout.contains("destroy1"));
+//        Assert.assertTrue(pr.stdout.contains("destroy2"));
+    }
+
+    @Test
+    @NeedsDisplay
+    @TestInBrowsers(testIn = {Browsers.one})
+    public void noClassDeffTestThrowsCatchStartJavawsHtml2() throws Exception {
+        prepare("start", true);
+        ProcessResult pr = server.executeJavaws(HTMLL, HTMLHREF, new AutoOkClosingListener(), null);
+        Assert.assertTrue(pr.stdout.contains("Loading LostClass"));
+        Assert.assertTrue(pr.stdout.contains("EX: "));
+        Assert.assertTrue(pr.stderr.contains(NoClassDefFoundError.class.getSimpleName()));
+        Assert.assertTrue(pr.stdout.contains("init1"));
+        Assert.assertTrue(pr.stdout.contains("init2"));
+        Assert.assertTrue(pr.stdout.contains("start1"));
+        Assert.assertTrue(pr.stdout.contains("start2"));
+//        Assert.assertTrue(pr.stdout.contains("paint1"));
+//        Assert.assertTrue(pr.stdout.contains("paint2"));
+//        Assert.assertTrue(pr.stdout.contains("stop1"));
+//        Assert.assertTrue(pr.stdout.contains("stop2"));
+//        Assert.assertTrue(pr.stdout.contains("destroy1"));
+//        Assert.assertTrue(pr.stdout.contains("destroy2"));
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+    }
+
+  
+
+}
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/signed/CheckPluginParams/resources/CheckPluginParams.jnlp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/reproducers/signed/CheckPluginParams/resources/CheckPluginParams.jnlp	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,57 @@
+<!--
+
+This file is part of IcedTea.
+
+IcedTea is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+IcedTea is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with IcedTea; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version.
+
+ -->
+<?xml version="1.0" encoding="utf-8"?>
+<jnlp spec="1.0" href="CheckPluginParams.jnlp" codebase=".">
+    <information>
+        <title>CheckPluginParams</title>
+        <vendor>IcedTea</vendor>
+        <homepage href="http://icedtea.classpath.org/wiki/IcedTea-Web#Testing_IcedTea-Web"/>
+        <description>CheckPluginParams</description>
+        <offline/>
+    </information>
+    <resources>
+        <j2se version="1.4+"/>
+        <jar href="CheckPluginParams.jar"/>
+    </resources>
+    <applet-desc
+      documentBase="."
+      name="CheckPluginParams"
+      main-class="CheckPluginParams"
+      width="100"
+      height="100" />
+</jnlp>
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/signed/CheckPluginParams/resources/CheckPluginParams1.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/reproducers/signed/CheckPluginParams/resources/CheckPluginParams1.html	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,46 @@
+<!--
+
+This file is part of IcedTea.
+
+IcedTea is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+IcedTea is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with IcedTea; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version.
+
+-->
+<html>
+  <head></head>
+  <body>
+    <applet code="CheckPluginParams" width="800" height="600">
+      <param name="jnlp_href" value="CheckPluginParams.jnlp">
+    </applet>
+  </body>
+</html>
+
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/signed/CheckPluginParams/resources/CheckPluginParams2.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/reproducers/signed/CheckPluginParams/resources/CheckPluginParams2.html	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,45 @@
+<!--
+
+This file is part of IcedTea.
+
+IcedTea is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+IcedTea is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with IcedTea; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version.
+
+-->
+<html>
+  <head></head>
+  <body>
+	<applet code="CheckPluginParams.class" archive="CheckPluginParams.jar" codebase="." width="800" height="600">
+    </applet>
+  </body>
+</html>
+
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/signed/CheckPluginParams/srcs/CheckPluginParams.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/reproducers/signed/CheckPluginParams/srcs/CheckPluginParams.java	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,69 @@
+/* CheckPluginParams.java
+Copyright (C) 2012 Red Hat, Inc.
+
+This file is part of IcedTea.
+
+IcedTea is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License as published by
+the Free Software Foundation, version 2.
+
+IcedTea is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with IcedTea; see the file COPYING.  If not, write to
+the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version.
+ */
+
+
+import java.applet.Applet;
+
+public class CheckPluginParams extends Applet {
+    
+    private static final String ID ="test.custom";
+
+    public static void main(String... args){
+        System.out.println(""+ID+"1: "+System.getProperty(""+ID+"1"));
+        System.out.println(""+ID+"2: "+System.getProperty(""+ID+"2"));
+        System.out.println(""+ID+"3: "+System.getProperty(""+ID+"3"));
+        System.out.println(""+ID+"4: "+System.getProperty(""+ID+"4"));
+    }
+    
+
+    @Override
+    public void init() {
+        main();
+        
+    }
+
+    @Override
+    public void start() {
+        //main();
+        System.out.println("*** APPLET FINISHED ***");
+        
+    }
+
+   
+    
+    
+}
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/signed/CheckPluginParams/testcases/CheckPluginParamsTests.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/reproducers/signed/CheckPluginParams/testcases/CheckPluginParamsTests.java	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,102 @@
+/* CheckPluginParamsTests.java
+ Copyright (C) 2012 Red Hat, Inc.
+
+ This file is part of IcedTea.
+
+ IcedTea is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, version 2.
+
+ IcedTea is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with IcedTea; see the file COPYING.  If not, write to
+ the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301 USA.
+
+ Linking this library statically or dynamically with other modules is
+ making a combined work based on this library.  Thus, the terms and
+ conditions of the GNU General Public License cover the whole
+ combination.
+
+ As a special exception, the copyright holders of this library give you
+ permission to link this library with independent modules to produce an
+ executable, regardless of the license terms of these independent
+ modules, and to copy and distribute the resulting executable under
+ terms of your choice, provided that you also meet, for each linked
+ independent module, the terms and conditions of the license of that
+ module.  An independent module is a module which is not derived from
+ or based on this library.  If you modify this library, you may extend
+ this exception to your version of the library, but you are not
+ obligated to do so.  If you do not wish to do so, delete this
+ exception statement from your version.
+ */
+
+import java.io.IOException;
+import net.sourceforge.jnlp.ProcessResult;
+import net.sourceforge.jnlp.annotations.Bug;
+import net.sourceforge.jnlp.annotations.NeedsDisplay;
+import net.sourceforge.jnlp.annotations.TestInBrowsers;
+import net.sourceforge.jnlp.browsertesting.BrowserTest;
+import net.sourceforge.jnlp.browsertesting.Browsers;
+import net.sourceforge.jnlp.closinglisteners.AutoErrorClosingListener;
+import net.sourceforge.jnlp.closinglisteners.AutoOkClosingListener;
+import net.sourceforge.jnlp.config.DeploymentConfiguration;
+import net.sourceforge.jnlp.tools.DeploymentPropertiesModifier;
+import org.junit.AfterClass;
+
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+@Bug(id = "RH1273691")
+public class CheckPluginParamsTests extends BrowserTest {
+
+    private static DeploymentPropertiesModifier d;
+    private static final String ID = "test.custom";
+
+    @BeforeClass
+    public static void setup() throws IOException {
+        String value
+                = " -D" + ID + "1=value1"
+                + " -D" + ID + "2\\=value2=value2"
+                + " -D" + ID + "3=value3\\=value3"
+                + " -D" + ID + "4\\=value4\\\\=value4";
+        d = new DeploymentPropertiesModifier();
+        d.setProperties(DeploymentConfiguration.KEY_PLUGIN_JVM_ARGUMENTS, value);
+    }
+
+    @AfterClass
+    public static void tearDown() throws IOException {
+        d.restoreProperties();
+    }
+
+    public void evaluateApplet(ProcessResult pr) {
+        String s = pr.stdout;
+        Assert.assertTrue(s.contains(ID + "1: value1"));
+        Assert.assertTrue(s.contains(ID + "2: value2=value2"));
+        Assert.assertTrue(s.contains(ID + "3: value3=value3"));
+        Assert.assertTrue(s.contains(ID + "4: value4\\=value4"));
+    }
+
+    @Bug(id = "RH1273691")
+    @Test
+    @NeedsDisplay
+    @TestInBrowsers(testIn = {Browsers.one})
+    public void CheckWebstartServices() throws Exception {
+        ProcessResult pr = server.executeBrowser(null, "/CheckPluginParams1.html", new AutoOkClosingListener(), new AutoErrorClosingListener());
+        evaluateApplet(pr);
+    }
+    
+    @Bug(id = "RH1273691")
+    @Test
+    @NeedsDisplay
+    @TestInBrowsers(testIn = {Browsers.one})
+    public void CheckPluginJNLPHServices() throws Exception {
+        ProcessResult pr = server.executeBrowser(null, "/CheckPluginParams2.html", new AutoOkClosingListener(), new AutoErrorClosingListener());
+        evaluateApplet(pr);
+    }
+}
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/signed/ClasspathManifestTest/testcases/ClasspathManifestTest.java
--- a/tests/reproducers/signed/ClasspathManifestTest/testcases/ClasspathManifestTest.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/tests/reproducers/signed/ClasspathManifestTest/testcases/ClasspathManifestTest.java	Tue Jan 26 15:18:30 2016 +0100
@@ -1,59 +1,74 @@
 /* ClasspathManifestTest.java
-Copyright (C) 2012 Red Hat, Inc.
+ Copyright (C) 2012 Red Hat, Inc.
 
-This file is part of IcedTea.
+ This file is part of IcedTea.
 
-IcedTea is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License as published by
-the Free Software Foundation, version 2.
+ IcedTea is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, version 2.
 
-IcedTea is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
+ IcedTea is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with IcedTea; see the file COPYING.  If not, write to
-the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-02110-1301 USA.
+ You should have received a copy of the GNU General Public License
+ along with IcedTea; see the file COPYING.  If not, write to
+ the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301 USA.
 
-Linking this library statically or dynamically with other modules is
-making a combined work based on this library.  Thus, the terms and
-conditions of the GNU General Public License cover the whole
-combination.
+ Linking this library statically or dynamically with other modules is
+ making a combined work based on this library.  Thus, the terms and
+ conditions of the GNU General Public License cover the whole
+ combination.
 
-As a special exception, the copyright holders of this library give you
-permission to link this library with independent modules to produce an
-executable, regardless of the license terms of these independent
-modules, and to copy and distribute the resulting executable under
-terms of your choice, provided that you also meet, for each linked
-independent module, the terms and conditions of the license of that
-module.  An independent module is a module which is not derived from
-or based on this library.  If you modify this library, you may extend
-this exception to your version of the library, but you are not
-obligated to do so.  If you do not wish to do so, delete this
-exception statement from your version.
+ As a special exception, the copyright holders of this library give you
+ permission to link this library with independent modules to produce an
+ executable, regardless of the license terms of these independent
+ modules, and to copy and distribute the resulting executable under
+ terms of your choice, provided that you also meet, for each linked
+ independent module, the terms and conditions of the license of that
+ module.  An independent module is a module which is not derived from
+ or based on this library.  If you modify this library, you may extend
+ this exception to your version of the library, but you are not
+ obligated to do so.  If you do not wish to do so, delete this
+ exception statement from your version.
  */
 
+import java.io.File;
+import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 
 import net.sourceforge.jnlp.ProcessResult;
 import net.sourceforge.jnlp.ServerAccess;
-import net.sourceforge.jnlp.annotations.KnownToFail;
 import net.sourceforge.jnlp.annotations.NeedsDisplay;
 import net.sourceforge.jnlp.annotations.TestInBrowsers;
 import net.sourceforge.jnlp.browsertesting.BrowserTest;
 import net.sourceforge.jnlp.browsertesting.Browsers;
+import net.sourceforge.jnlp.browsertesting.browsers.firefox.FirefoxProfilesOperator;
+import net.sourceforge.jnlp.util.FileUtils;
+import org.junit.AfterClass;
 
 import org.junit.Assert;
+import org.junit.BeforeClass;
 import org.junit.Test;
 
 public class ClasspathManifestTest extends BrowserTest {
 
-    private static String s1 = "Searching for CheckForClasspath.";
-    private static String s2 = "CheckForClasspath found on classpath.";
-    private static String ss = "xception";
+    private static final String s1 = "Searching for CheckForClasspath.";
+    private static final String s2 = "CheckForClasspath found on classpath.";
+    private static final String ss = "xception";
+
+    private static final String n1 = "ClasspathManifestJNLPHrefTest.html";
+    private static final String n4 = "ClasspathManifestApplicationTest.jnlp";
+    private static final String n2 = "ClasspathManifestAppletTest.jnlp";
+    private static final String n3 = "ClasspathManifestAppletTest.html";
+    private static final String[] ns = new String[]{n1, n2, n3, n4};
+    private static final String n0 = "ClasspathManifestTest.jar";
+
+    private static File newRoot;
+    private static File newRoot1;
 
     public void checkAppFails(ProcessResult pr, String testName) {
         Assert.assertTrue("ClasspathManifest." + testName + " stdout should contain " + s1 + " but didn't", pr.stdout.contains(s1));
@@ -61,69 +76,148 @@
         Assert.assertTrue("ClasspathManifest." + testName + " stderr should contain " + ss + " but didn't", pr.stderr.contains(ss));
     }
 
+    public void checkAppPass(ProcessResult pr, String testName) {
+        Assert.assertTrue("ClasspathManifest." + testName + " stdout should contain " + s1 + " but didn't", pr.stdout.contains(s1));
+        Assert.assertTrue("ClasspathManifest." + testName + " stdout should not contain " + s2 + " but did", pr.stdout.contains(s2));
+        Assert.assertFalse("ClasspathManifest." + testName + " stderr should contain " + ss + " but didn't", pr.stderr.contains(ss));
+    }
+
+    @AfterClass
+    public static void removeAlternativeLocalDirs() throws IOException {
+        FirefoxProfilesOperator.deleteRecursively(newRoot);
+    }
+
+    @BeforeClass
+    public static void createAlternativeLocalDirs() throws IOException {
+        newRoot = File.createTempFile("itw", "ClasspathManifestTest");
+        newRoot.delete();
+        newRoot.mkdirs();
+        newRoot.deleteOnExit();
+        newRoot1 = new File(newRoot, "r1");
+        newRoot1.mkdir();
+        FirefoxProfilesOperator.copyRecursively(new File(server.getDir(), "Classpath"), newRoot);
+
+        for (String n : ns) {
+            copyTextFile(new File(server.getDir(), n), new File(newRoot, n));
+        }
+        FirefoxProfilesOperator.copyFile(new File(server.getDir(), n0), new File(newRoot1, n0));
+    }
+
+    public static void copyTextFile(File from, File to) throws IOException {
+        String s = FileUtils.loadFileAsString(from);
+//        for (String n : ns) {
+//            s = s.replaceAll(n, newRoot1.getName()+"/" + n);
+//        }
+        s = s.replaceAll(n0, newRoot1.getName() + "/" + n0);
+        FileUtils.saveFile(s, to);
+    }
+
     @NeedsDisplay
     @Test
     public void ApplicationJNLPRemoteTest() throws Exception {
-        ProcessResult pr = server.executeJavawsHeadless(null, "/ClasspathManifestApplicationTest.jnlp");
+        ProcessResult pr = server.executeJavawsHeadless(null, "/" + n4);
         checkAppFails(pr, "ApplicationJNLPRemoteTest");
     }
 
+    /**
+     * See the difference between *LocalTest() and *LocalTest_differentDir().
+     *
+     * Itw always have "." on classpath. So
+     *
+     * ./jnlp or ./html (calling to jar.jar) + ./jar.jar +
+     * ./Codebase/../second.jar are all on classapth but ./jnlp or ./html
+     * (calling to someDir/jar.jar)+ ./someDir/jar.jar +
+     * ./Codebase/../second.jar Is making the jar.jar laodable for startup, but
+     * diapearing after encauntering Class-Path: in Manifest.mf
+     *
+     * @throws Exception
+     */
     @NeedsDisplay
-    @KnownToFail
     @Test
     public void ApplicationJNLPLocalTest() throws Exception {
-        List<String> commands=new ArrayList<String>(3);
+        List<String> commands = new ArrayList<>(3);
         commands.add(server.getJavawsLocation());
         commands.add(ServerAccess.HEADLES_OPTION);
-        commands.add("ClasspathManifestApplicationTest.jnlp");
+        commands.add(n4);
         ProcessResult pr = ServerAccess.executeProcess(commands, server.getDir());
-        checkAppFails(pr, "ApplicationJNLPLocalTest");
+        checkAppPass(pr, "ApplicationJNLPLocalTest");
+    }
+
+    @NeedsDisplay
+    @Test
+    public void ApplicationJNLPLocalTest_differentDir() throws Exception {
+        List<String> commands = new ArrayList<>(3);
+        commands.add(server.getJavawsLocation());
+        commands.add(ServerAccess.HEADLES_OPTION);
+        commands.add(n4);
+        ProcessResult pr = ServerAccess.executeProcess(commands, newRoot);
+        checkAppFails(pr, "ApplicationJNLPLocalTest_differentDir");
     }
 
     @NeedsDisplay
     @Test
     public void AppletJNLPRemoteTest() throws Exception {
-        ProcessResult pr = server.executeJavawsHeadless(null, "/ClasspathManifestAppletTest.jnlp");
+        ProcessResult pr = server.executeJavawsHeadless(null, "/" + n2);
         checkAppFails(pr, "AppletJNLPRemoteTest");
     }
 
     @NeedsDisplay
-    @KnownToFail
     @Test
     public void AppletJNLPRLocalTest() throws Exception {
-        List<String> commands=new ArrayList<String>(3);
+        List<String> commands = new ArrayList<>(3);
         commands.add(server.getJavawsLocation());
         commands.add(ServerAccess.HEADLES_OPTION);
-        commands.add("ClasspathManifestAppletTest.jnlp");
+        commands.add(n2);
         ProcessResult pr = ServerAccess.executeProcess(commands, server.getDir());
-        checkAppFails(pr, "AppletJNLPRLocalTest");
+        checkAppPass(pr, "AppletJNLPRLocalTest");
+    }
+
+    @NeedsDisplay
+    @Test
+    public void AppletJNLPRLocalTest_differentDir() throws Exception {
+        List<String> commands = new ArrayList<>(3);
+        commands.add(server.getJavawsLocation());
+        commands.add(ServerAccess.HEADLES_OPTION);
+        commands.add(n2);
+        ProcessResult pr = ServerAccess.executeProcess(commands, newRoot);
+        checkAppFails(pr, "AppletJNLPRLocalTest_differentDir");
     }
 
     @NeedsDisplay
     @TestInBrowsers(testIn = {Browsers.one})
     @Test
     public void BrowserJNLPHrefRemoteTest() throws Exception {
-        ProcessResult pr = server.executeBrowser("/ClasspathManifestJNLPHrefTest.html");
+        ProcessResult pr = server.executeBrowser("/" + n1);
         checkAppFails(pr, "BrowserJNLPHrefRemoteTest");
     }
 
     @NeedsDisplay
     @TestInBrowsers(testIn = {Browsers.one})
-    @KnownToFail
     @Test
     public void BrowserJNLPHrefLocalTest() throws Exception {
-        List<String> commands=new ArrayList<String>(2);
+        List<String> commands = new ArrayList<>(2);
         commands.add(server.getBrowserLocation());
-        commands.add("ClasspathManifestJNLPHrefTest.html");
+        commands.add(n1);
         ProcessResult pr = ServerAccess.executeProcess(commands, server.getDir());
-        checkAppFails(pr, "BrowserJNLPHrefLocalTest");
+        checkAppPass(pr, "BrowserJNLPHrefLocalTest");
+    }
+
+    @NeedsDisplay
+    @TestInBrowsers(testIn = {Browsers.one})
+    @Test
+    public void BrowserJNLPHrefLocalTest_differentDir() throws Exception {
+        List<String> commands = new ArrayList<>(2);
+        commands.add(server.getBrowserLocation());
+        commands.add(n1);
+        ProcessResult pr = ServerAccess.executeProcess(commands, newRoot);
+        checkAppFails(pr, "BrowserJNLPHrefLocalTest_differentDir");
     }
 
     @NeedsDisplay
     @TestInBrowsers(testIn = {Browsers.one})
     @Test
     public void BrowserAppletRemoteTest() throws Exception {
-        ProcessResult pr = server.executeBrowser("/ClasspathManifestAppletTest.html");
+        ProcessResult pr = server.executeBrowser("/" + n3);
         Assert.assertTrue("ClasspathManifest.BrowserAppletRemoteTest stdout should contain " + s1 + " but didn't", pr.stdout.contains(s1));
         // Should be the only one to search manifest for classpath.
         Assert.assertTrue("ClasspathManifest.BrowserAppletRemoteTest stdout should contain " + s2 + " but didn't", pr.stdout.contains(s2));
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/signed/CodeBaseManifestEntrySignedMatching/testcases/CodeBaseManifestEntrySignedMatching.java
--- a/tests/reproducers/signed/CodeBaseManifestEntrySignedMatching/testcases/CodeBaseManifestEntrySignedMatching.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/tests/reproducers/signed/CodeBaseManifestEntrySignedMatching/testcases/CodeBaseManifestEntrySignedMatching.java	Tue Jan 26 15:18:30 2016 +0100
@@ -37,10 +37,8 @@
 
 import java.io.File;
 import java.io.IOException;
-import java.text.MessageFormat;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.PropertyResourceBundle;
 import net.sourceforge.jnlp.ProcessResult;
 import net.sourceforge.jnlp.ServerAccess;
 import net.sourceforge.jnlp.annotations.NeedsDisplay;
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/signed/CodeBaseManifestEntrySignedMatching/testcases/CodeBaseManifestEntrySignedNotMatching.java
--- a/tests/reproducers/signed/CodeBaseManifestEntrySignedMatching/testcases/CodeBaseManifestEntrySignedNotMatching.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/tests/reproducers/signed/CodeBaseManifestEntrySignedMatching/testcases/CodeBaseManifestEntrySignedNotMatching.java	Tue Jan 26 15:18:30 2016 +0100
@@ -74,7 +74,7 @@
     @NeedsDisplay
     @Test
     public void ApplicationJNLPLocalTest() throws Exception {
-        List<String> commands = new ArrayList<String>(3);
+        List<String> commands = new ArrayList<>(3);
         commands.add(server.getJavawsLocation());
         commands.add(ServerAccess.HEADLES_OPTION);
         commands.add(GENERAL_NAME + SIGNATURE + ".jnlp");
@@ -90,7 +90,7 @@
     @Test
     public void ApplicationJNLPLocalTestWithRemoteCodebase() throws Exception {
         prepareCopyFile();
-        List<String> commands = new ArrayList<String>(3);
+        List<String> commands = new ArrayList<>(3);
         commands.add(server.getJavawsLocation());
         commands.add(ServerAccess.HEADLES_OPTION);
         commands.add(GENERAL_NAME + SIGNATURE + "_copy.jnlp");
@@ -109,7 +109,7 @@
     @NeedsDisplay
     @Test
     public void AppletJNLPRLocalTest() throws Exception {
-        List<String> commands = new ArrayList<String>(3);
+        List<String> commands = new ArrayList<>(3);
         commands.add(server.getJavawsLocation());
         commands.add(ServerAccess.HEADLES_OPTION);
         commands.add(GENERAL_NAME + SIGNATURE + "Applet.jnlp");
@@ -132,7 +132,7 @@
     @TestInBrowsers(testIn = {Browsers.one})
     @Test
     public void BrowserJNLPHrefLocalTest() throws Exception {
-        List<String> commands = new ArrayList<String>(2);
+        List<String> commands = new ArrayList<>(2);
         commands.add(server.getBrowserLocation());
         commands.add(GENERAL_NAME + SIGNATURE + "Jnlp.html");
         ProcessResult pr = ServerAccess.executeProcess(commands, server.getDir(), new AutoOkClosingListener(), null);
@@ -144,7 +144,7 @@
     @TestInBrowsers(testIn = {Browsers.one})
     @Test
     public void BrowserAppletLocalTest() throws Exception {
-        List<String> commands = new ArrayList<String>(2);
+        List<String> commands = new ArrayList<>(2);
         commands.add(server.getBrowserLocation());
         commands.add(GENERAL_NAME + SIGNATURE + ".html");
         ProcessResult pr = ServerAccess.executeProcess(commands, server.getDir(), new AutoOkClosingListener(), null);
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/signed/CodeBaseManifestEntrySignedMatching/testcases/CodeBaseManifestEntryUnsignedMatching.java
--- a/tests/reproducers/signed/CodeBaseManifestEntrySignedMatching/testcases/CodeBaseManifestEntryUnsignedMatching.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/tests/reproducers/signed/CodeBaseManifestEntrySignedMatching/testcases/CodeBaseManifestEntryUnsignedMatching.java	Tue Jan 26 15:18:30 2016 +0100
@@ -71,7 +71,7 @@
 
     @Test
     public void ApplicationJNLPLocalTest() throws Exception {
-        List<String> commands = new ArrayList<String>(3);
+        List<String> commands = new ArrayList<>(3);
         commands.add(server.getJavawsLocation());
         commands.add(ServerAccess.HEADLES_OPTION);
         commands.add(GENERAL_NAME + SIGNATURE + ".jnlp");
@@ -86,7 +86,7 @@
     @Test
     public void ApplicationJNLPLocalTestWithRemoteCodebase() throws Exception {
         prepareCopyFile();
-        List<String> commands = new ArrayList<String>(3);
+        List<String> commands = new ArrayList<>(3);
         commands.add(server.getJavawsLocation());
         commands.add(ServerAccess.HEADLES_OPTION);
         commands.add(GENERAL_NAME + SIGNATURE + "_copy.jnlp");
@@ -106,7 +106,7 @@
     @NeedsDisplay
     @Test
     public void AppletJNLPRLocalTest() throws Exception {
-        List<String> commands = new ArrayList<String>(3);
+        List<String> commands = new ArrayList<>(3);
         commands.add(server.getJavawsLocation());
         commands.add(ServerAccess.HEADLES_OPTION);
         commands.add(GENERAL_NAME + SIGNATURE + "Applet.jnlp");
@@ -128,7 +128,7 @@
     @TestInBrowsers(testIn = {Browsers.one})
     @Test
     public void BrowserJNLPHrefLocalTest() throws Exception {
-        List<String> commands = new ArrayList<String>(2);
+        List<String> commands = new ArrayList<>(2);
         commands.add(server.getBrowserLocation());
         commands.add(GENERAL_NAME + SIGNATURE + "Jnlp.html");
         ProcessResult pr = ServerAccess.executeProcess(commands, server.getDir(), new AutoOkClosingListener(), null);
@@ -140,7 +140,7 @@
     @TestInBrowsers(testIn = {Browsers.one})
     @Test
     public void BrowserAppletLocalTest() throws Exception {
-        List<String> commands = new ArrayList<String>(2);
+        List<String> commands = new ArrayList<>(2);
         commands.add(server.getBrowserLocation());
         commands.add(GENERAL_NAME + SIGNATURE + ".html");
         ProcessResult pr = ServerAccess.executeProcess(commands, server.getDir(), new AutoOkClosingListener(), null);
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/signed/CodeBaseManifestEntrySignedMatching/testcases/CodeBaseManifestEntryUnsignedNotMatching.java
--- a/tests/reproducers/signed/CodeBaseManifestEntrySignedMatching/testcases/CodeBaseManifestEntryUnsignedNotMatching.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/tests/reproducers/signed/CodeBaseManifestEntrySignedMatching/testcases/CodeBaseManifestEntryUnsignedNotMatching.java	Tue Jan 26 15:18:30 2016 +0100
@@ -73,7 +73,7 @@
 
     @Test
     public void ApplicationJNLPLocalTest() throws Exception {
-        List<String> commands = new ArrayList<String>(3);
+        List<String> commands = new ArrayList<>(3);
         commands.add(server.getJavawsLocation());
         commands.add(ServerAccess.HEADLES_OPTION);
         commands.add(GENERAL_NAME + SIGNATURE + ".jnlp");
@@ -88,7 +88,7 @@
     @Test
     public void ApplicationJNLPLocalTestWithRemoteCodebase() throws Exception {
         prepareCopyFile();
-        List<String> commands = new ArrayList<String>(3);
+        List<String> commands = new ArrayList<>(3);
         commands.add(server.getJavawsLocation());
         commands.add(ServerAccess.HEADLES_OPTION);
         commands.add(GENERAL_NAME + SIGNATURE + "_copy.jnlp");
@@ -108,7 +108,7 @@
     @NeedsDisplay
     @Test
     public void AppletJNLPRLocalTest() throws Exception {
-        List<String> commands = new ArrayList<String>(3);
+        List<String> commands = new ArrayList<>(3);
         commands.add(server.getJavawsLocation());
         commands.add(ServerAccess.HEADLES_OPTION);
         commands.add(GENERAL_NAME + SIGNATURE + "Applet.jnlp");
@@ -130,7 +130,7 @@
     @TestInBrowsers(testIn = {Browsers.one})
     @Test
     public void BrowserJNLPHrefLocalTest() throws Exception {
-        List<String> commands = new ArrayList<String>(2);
+        List<String> commands = new ArrayList<>(2);
         commands.add(server.getBrowserLocation());
         commands.add(GENERAL_NAME + SIGNATURE + "Jnlp.html");
         ProcessResult pr = ServerAccess.executeProcess(commands, server.getDir(), new AutoOkClosingListener(), null);
@@ -142,7 +142,7 @@
     @TestInBrowsers(testIn = {Browsers.one})
     @Test
     public void BrowserAppletLocalTest() throws Exception {
-        List<String> commands = new ArrayList<String>(2);
+        List<String> commands = new ArrayList<>(2);
         commands.add(server.getBrowserLocation());
         commands.add(GENERAL_NAME + SIGNATURE + ".html");
         ProcessResult pr = ServerAccess.executeProcess(commands, server.getDir(), new AutoOkClosingListener(), null);
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/signed/CodebasesAttsSigned/resources/CodebasesAttsSigned.html.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/reproducers/signed/CodebasesAttsSigned/resources/CodebasesAttsSigned.html.in	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,46 @@
+<!--
+
+This file is part of IcedTea.
+
+IcedTea is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+IcedTea is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with IcedTea; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version.
+
+ -->
+
+<html>
+<head></head>
+<body>
+	<applet code="CodebasesAttsSigned.class" archive="@JAR@.jar" @CODEBASE@ width="100" height="100">
+		<param name="id" value="@ID@">
+	</applet>
+</body>
+</html>
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/signed/CodebasesAttsSigned/resources/CodebasesAttsSignedApp.jnlp.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/reproducers/signed/CodebasesAttsSigned/resources/CodebasesAttsSignedApp.jnlp.in	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,55 @@
+<!--
+
+This file is part of IcedTea.
+
+IcedTea is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+IcedTea is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with IcedTea; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version.
+
+ -->
+
+<?xml version="1.0" encoding="utf-8"?>
+<jnlp spec="1.0" href="CodebasesAttsSignedApp.jnlp" @CODEBASE@>
+  <information>
+	<title>CodebasesAttsSigned</title>
+    <vendor>IcedTea</vendor>
+    <homepage href="http://icedtea.classpath.org/wiki/IcedTea-Web#Testing_IcedTea-Web"/>
+    <description>PR2489</description>
+    <offline/>
+  </information>
+  <resources>
+    <j2se version="1.4+"/>
+    <jar href="@JAR@.jar"/>
+  </resources>
+  <application-desc main-class="CodebasesAttsSigned">
+    <argument>@ID@</argument>
+  </application-desc>
+</jnlp>
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/signed/CodebasesAttsSigned/resources/CodebasesAttsSignedApplet.jnlp.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/reproducers/signed/CodebasesAttsSigned/resources/CodebasesAttsSignedApplet.jnlp.in	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,59 @@
+<!--
+
+This file is part of IcedTea.
+
+IcedTea is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+IcedTea is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with IcedTea; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version.
+
+ -->
+
+<?xml version="1.0" encoding="utf-8"?>
+<jnlp spec="1.0" href="CodebasesAttsSignedApplet.jnlp" @CODEBASE@>
+	<information>
+    	<title>CodebasesAttsSigned</title>
+    	<vendor>IcedTea</vendor>
+    	<homepage href="http://icedtea.classpath.org/wiki/IcedTea-Web#Testing_IcedTea-Web"/>
+    	<description>PR2489</description>
+    	<offline/>
+	</information>
+	<resources>
+	  	<j2se version="1.4+"/>
+		<jar href="@JAR@.jar"/>
+	</resources>
+	<applet-desc
+	  name="CodebasesAttsSigned"
+	  main-class="CodebasesAttsSigned"
+	  width="100"
+	  height="100">
+            <param name="id" value="@ID@">
+	</applet-desc>
+</jnlp>
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/signed/CodebasesAttsSigned/resources/CodebasesAttsSignedJnlpHref.html.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/reproducers/signed/CodebasesAttsSigned/resources/CodebasesAttsSignedJnlpHref.html.in	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,47 @@
+<!--
+
+This file is part of IcedTea.
+
+IcedTea is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+IcedTea is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with IcedTea; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version.
+
+ -->
+
+<html>
+<head></head>
+<body>
+	<applet width="100" height="100" code="@JAR@"  @CODEBASE@ >
+		<param name="jnlp_href" value="@JNLPHREF@">
+                <param name="id" value="@ID@">
+	</applet>
+</body>
+</html>
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/signed/CodebasesAttsSigned/srcs/CodebasesAttsSigned.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/reproducers/signed/CodebasesAttsSigned/srcs/CodebasesAttsSigned.java	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,86 @@
+/* ExtensionJnlpTestApplet.java
+ Copyright (C) 2013 Red Hat, Inc.
+
+ This file is part of IcedTea.
+
+ IcedTea is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, version 2.
+
+ IcedTea is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with IcedTea; see the file COPYING.  If not, write to
+ the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301 USA.
+
+ Linking this library statically or dynamically with other modules is
+ making a combined work based on this library.  Thus, the terms and
+ conditions of the GNU General Public License cover the whole
+ combination.
+
+ As a special exception, the copyright holders of this library give you
+ permission to link this library with independent modules to produce an
+ executable, regardless of the license terms of these independent
+ modules, and to copy and distribute the resulting executable under
+ terms of your choice, provided that you also meet, for each linked
+ independent module, the terms and conditions of the license of that
+ module.  An independent module is a module which is not derived from
+ or based on this library.  If you modify this library, you may extend
+ this exception to your version of the library, but you are not
+ obligated to do so.  If you do not wish to do so, delete this
+ exception statement from your version.
+ */
+
+import java.applet.*;
+import java.awt.Graphics;
+
+/**
+ *
+ * Note that for html's appelt and jnlphreff's jnlp file may have different
+ * codebase.
+ *
+ */
+public class CodebasesAttsSigned extends Applet {
+
+    private static final String appletCloseString = "*** APPLET FINISHED ***";
+    private static final String bid = "BID0";
+
+    public static void main(String... args) {
+        System.out.println("id: "+args[0]);
+        System.out.println("BID: "+bid);
+        System.out.println(CodebasesAttsSigned.class.getName());
+        System.out.println(appletCloseString);
+        System.out.flush();
+        System.out.println("some garbage");
+    }
+
+    @Override
+    public void init() {
+
+    }
+
+    @Override
+    public void start() {
+        main(getParameter("id"));
+    }
+
+    @Override
+    public void stop() {
+
+    }
+
+    @Override
+    public void destroy() {
+
+    }
+
+    @Override
+    public void paint(Graphics g) {
+
+    }
+
+}
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/signed/CodebasesAttsSigned/testcases/CodebasesAttsSignedDialogsTest1.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/reproducers/signed/CodebasesAttsSigned/testcases/CodebasesAttsSignedDialogsTest1.java	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,528 @@
+/* CodebasesAttsSignedNoDialogsTest1.java
+ Copyright (C) 2013 Red Hat, Inc.
+
+ This file is part of IcedTea.
+
+ IcedTea is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, version 2.
+
+ IcedTea is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with IcedTea; see the file COPYING.  If not, write to
+ the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301 USA.
+
+ Linking this library statically or dynamically with other modules is
+ making a combined work based on this library.  Thus, the terms and
+ conditions of the GNU General Public License cover the whole
+ combination.
+
+ As a special exception, the copyright holders of this library give you
+ permission to link this library with independent modules to produce an
+ executable, regardless of the license terms of these independent
+ modules, and to copy and distribute the resulting executable under
+ terms of your choice, provided that you also meet, for each linked
+ independent module, the terms and conditions of the license of that
+ module.  An independent module is a module which is not derived from
+ or based on this library.  If you modify this library, you may extend
+ this exception to your version of the library, but you are not
+ obligated to do so.  If you do not wish to do so, delete this
+ exception statement from your version.
+ */
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.URL;
+import java.util.AbstractMap;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Enumeration;
+import java.util.List;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+import java.util.zip.ZipOutputStream;
+import net.sourceforge.jnlp.OptionsDefinitions;
+import net.sourceforge.jnlp.ProcessResult;
+import net.sourceforge.jnlp.ProcessWrapper;
+import net.sourceforge.jnlp.ServerAccess;
+import net.sourceforge.jnlp.ServerLauncher;
+import net.sourceforge.jnlp.annotations.Bug;
+import net.sourceforge.jnlp.annotations.NeedsDisplay;
+import net.sourceforge.jnlp.annotations.TestInBrowsers;
+import net.sourceforge.jnlp.browsertesting.BrowserTest;
+import static net.sourceforge.jnlp.browsertesting.BrowserTest.server;
+import net.sourceforge.jnlp.browsertesting.Browsers;
+import net.sourceforge.jnlp.closinglisteners.AutoErrorClosingListener;
+import net.sourceforge.jnlp.closinglisteners.AutoOkClosingListener;
+import net.sourceforge.jnlp.config.DeploymentConfiguration;
+import net.sourceforge.jnlp.runtime.ManifestAttributesChecker;
+import net.sourceforge.jnlp.security.appletextendedsecurity.AppletSecurityLevel;
+import net.sourceforge.jnlp.tools.DeploymentPropertiesModifier;
+import net.sourceforge.jnlp.util.FileUtils;
+import org.junit.AfterClass;
+
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+/**
+ *
+ * null, empty, none, wrong, correct jnlp x html different codebases.
+ *
+ * no dialogs should be appeared. Second testsuite with ALL dialogs (head only)
+ *
+ *
+ */
+public class CodebasesAttsSignedDialogsTest1 extends BrowserTest {
+
+    public static final String appletCloseString = AutoOkClosingListener.MAGICAL_OK_CLOSING_STRING;
+    public static final String[] JAVAWS_HTML_ARRAY = new String[]{OptionsDefinitions.OPTIONS.HTML.option};
+    public static final List<String> JAVAWS_HTML_LIST = Arrays.asList(JAVAWS_HTML_ARRAY);
+    //disabled - 1.6 specific. We need dialogs to pop up.  Anyway, in 1.6 all such tests are disbaled for runtime anyway
+    private static final String[] JAVAWS_HEADLES_ARRAY = new String[]{};//{OptionsDefinitions.OPTIONS.HTML.HEADLESS.option};
+    private static final List<String> JAVAWS_HEADLES_LIST = Arrays.asList(JAVAWS_HEADLES_ARRAY);
+
+    public static final String JNLPAPP = "CodebasesAttsSignedApp.jnlp";
+    public static final String JNLPAPPLET = "CodebasesAttsSignedApplet.jnlp";
+    public static final String HTML = "CodebasesAttsSigned.html";
+    public static final String HTMLHREF = "CodebasesAttsSignedJnlpHref.html";
+    public static final String CodebasesAttsSigned = "CodebasesAttsSigned";
+
+    private static ServerLauncher secondValidServer;
+    private static DeploymentPropertiesModifier.MultipleDeploymentPropertiesModifier ensuredDP;
+
+    public static final String[] files = new String[]{"CodebasesAttsSignedApp.jnlp", "CodebasesAttsSigned.html", "CodebasesAttsSignedApplet.jnlp", "CodebasesAttsSignedJnlpHref.html"};
+
+    @BeforeClass
+    public static void initSecondaryServers() throws IOException {
+        secondValidServer = ServerAccess.getIndependentInstanceOnTmpDir();
+    }
+
+    @AfterClass
+    public static void stopSecondaryServers() throws IOException {
+        secondValidServer.stop();
+    }
+
+    @BeforeClass
+    public static void setProperties() throws IOException {
+        ensuredDP = new DeploymentPropertiesModifier.MultipleDeploymentPropertiesModifier(
+                new AbstractMap.SimpleEntry(DeploymentConfiguration.KEY_ENABLE_MANIFEST_ATTRIBUTES_CHECK, ManifestAttributesChecker.MANIFEST_ATTRIBUTES_CHECK.ALL.name()),
+                new AbstractMap.SimpleEntry(DeploymentConfiguration.KEY_SECURITY_LEVEL, AppletSecurityLevel.ASK_UNSIGNED.name())
+        );
+        ensuredDP.setProperties();
+    }
+
+    @AfterClass
+    public static void resetProperties() throws IOException {
+        ensuredDP.restoreProperties();
+    }
+
+    //jar from different source
+    @NeedsDisplay
+    //@Test
+    @Bug(id = "PR2489")
+    public void codebasesAttsSignedTestWorksJnlp1_null_foreignJar() throws Exception {
+        prepareSwapResources();
+        ProcessWrapper pw = new ProcessWrapper(server.getJavawsLocation(), JAVAWS_HEADLES_LIST, secondValidServer.getUrl(JNLPAPP));
+        pw.addStdOutListener(new AutoOkClosingListener());
+        pw.addStdErrListener(new AutoErrorClosingListener());
+        //pw.setWriter("YES\nYES\nYES\nYES\n");
+        ProcessResult pr = pw.execute();
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAttsSigned));
+        Assert.assertTrue(pr.stdout.contains("id: 2"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    //@Test
+    @Bug(id = "PR2489")
+    public void codebasesAttsSignedTestWorksJnlp2_null_foreignJar() throws Exception {
+        prepareSwapResources();
+        ProcessWrapper pw = new ProcessWrapper(server.getJavawsLocation(), JAVAWS_HEADLES_LIST, secondValidServer.getUrl(JNLPAPPLET));
+        pw.addStdOutListener(new AutoOkClosingListener());
+        pw.addStdErrListener(new AutoErrorClosingListener());
+        //pw.setWriter("YES\nYES\nYES\nYES\n");
+        ProcessResult pr = pw.execute();
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAttsSigned));
+        Assert.assertTrue(pr.stdout.contains("id: 2"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    //@Test//   browsers dont support headless dialogues
+    @TestInBrowsers(testIn = Browsers.one)
+    @Bug(id = "PR2489")
+    public void codebasesAttsSignedTestWorksHtml1_null_foreignJar() throws Exception {
+        prepareSwapResources();
+        ProcessResult pr = server.executeBrowser(null, secondValidServer.getUrl(HTML), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAttsSigned));
+        Assert.assertTrue(pr.stdout.contains("id: 2"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    //@Test //browsers do not support ehadless dialogues
+    @TestInBrowsers(testIn = Browsers.one)
+    @Bug(id = "PR2489")
+    public void codebasesAttsSignedTestWorksHtml2_null_foreignJar() throws Exception {
+        prepareSwapResources();
+        ProcessResult pr = server.executeBrowser(null, secondValidServer.getUrl(HTMLHREF), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAttsSigned));
+        Assert.assertTrue(pr.stdout.contains("id: 2"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    //@Test
+    @Bug(id = "PR2489")
+    public void codebasesAttsSignedTestWorksJavawsHtml1_null_foreignJar() throws Exception {
+        prepareSwapResources();
+        ArrayList<String> HTML_HEADLESS = new ArrayList<>();
+        HTML_HEADLESS.addAll(JAVAWS_HEADLES_LIST);
+        HTML_HEADLESS.addAll(JAVAWS_HTML_LIST);
+        ProcessWrapper pw = new ProcessWrapper(server.getJavawsLocation(), HTML_HEADLESS, secondValidServer.getUrl(HTML));
+        pw.addStdOutListener(new AutoOkClosingListener());
+        pw.addStdErrListener(new AutoErrorClosingListener());
+        //pw.setWriter("YES\nYES\nYES\nYES\n");
+        ProcessResult pr = pw.execute();
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAttsSigned));
+        Assert.assertTrue(pr.stdout.contains("id: 2"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    //@Test
+    @Bug(id = "PR2489")
+    public void codebasesAttsSignedTestWorksJavawsHtml2_null_foreignJar() throws Exception {
+        prepareSwapResources();
+        ArrayList<String> HTML_HEADLESS = new ArrayList<>();
+        HTML_HEADLESS.addAll(JAVAWS_HEADLES_LIST);
+        HTML_HEADLESS.addAll(JAVAWS_HTML_LIST);
+        ProcessWrapper pw = new ProcessWrapper(server.getJavawsLocation(), HTML_HEADLESS, secondValidServer.getUrl(HTMLHREF));
+        pw.addStdOutListener(new AutoOkClosingListener());
+        pw.addStdErrListener(new AutoErrorClosingListener());
+        //pw.setWriter("YES\nYES\nYES\nYES\n");
+        ProcessResult pr = pw.execute();
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAttsSigned));
+        Assert.assertTrue(pr.stdout.contains("id: 2"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+    //done cross jars
+
+    @NeedsDisplay
+    //@Test
+    @Bug(id = "PR2489")
+    //the only alaca one in "normal mode"
+    public void codebasesAttsSignedTestWorksJnlp1_null() throws Exception {
+        prepare(null);
+        ProcessWrapper pw = new ProcessWrapper(server.getJavawsLocation(), JAVAWS_HEADLES_LIST, server.getUrl(JNLPAPP));
+        pw.addStdOutListener(new AutoOkClosingListener());
+        pw.addStdErrListener(new AutoErrorClosingListener());
+        //pw.setWriter("YES\nYES\nYES\nYES\n");
+        ProcessResult pr = pw.execute();
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAttsSigned));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    //@Test
+    @Bug(id = "PR2489")
+    public void codebasesAttsSignedTestWorksJnlp2_null() throws Exception {
+        prepare(null);
+        ProcessWrapper pw = new ProcessWrapper(server.getJavawsLocation(), JAVAWS_HEADLES_LIST, server.getUrl(JNLPAPPLET));
+        pw.addStdOutListener(new AutoOkClosingListener());
+        pw.addStdErrListener(new AutoErrorClosingListener());
+        //pw.setWriter("YES\nYES\nYES\nYES\n");
+        ProcessResult pr = pw.execute();
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAttsSigned));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    //@Test // browsers dont support headless dialogues
+    @TestInBrowsers(testIn = Browsers.one)
+    @Bug(id = "PR2489")
+    public void codebasesAttsSignedTestWorksHtml1_null() throws Exception {
+        prepare(null);
+        ProcessResult pr = server.executeBrowser(null, HTML, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAttsSigned));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    //@Test // browsers do not support ehadless dialogues
+    @TestInBrowsers(testIn = Browsers.one)
+    @Bug(id = "PR2489")
+    public void codebasesAttsSignedTestWorksHtml2_null() throws Exception {
+        prepare(null);
+        ProcessResult pr = server.executeBrowser(null, HTMLHREF, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAttsSigned));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    //@Test
+    @Bug(id = "PR2489")
+    public void codebasesAttsSignedTestWorksJavawsHtml1_null() throws Exception {
+        prepare(null);
+        ArrayList<String> HTML_HEADLESS = new ArrayList<>();
+        HTML_HEADLESS.addAll(JAVAWS_HEADLES_LIST);
+        HTML_HEADLESS.addAll(JAVAWS_HTML_LIST);
+        ProcessWrapper pw = new ProcessWrapper(server.getJavawsLocation(), HTML_HEADLESS, server.getUrl(HTML));
+        pw.addStdOutListener(new AutoOkClosingListener());
+        pw.addStdErrListener(new AutoErrorClosingListener());
+        //pw.setWriter("YES\nYES\nYES\nYES\n");
+        ProcessResult pr = pw.execute();
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAttsSigned));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    //@Test
+    @Bug(id = "PR2489")
+    public void codebasesAttsSignedTestWorksJavawsHtml2_null() throws Exception {
+        prepare(null);
+        ArrayList<String> HTML_HEADLESS = new ArrayList<>();
+        HTML_HEADLESS.addAll(JAVAWS_HEADLES_LIST);
+        HTML_HEADLESS.addAll(JAVAWS_HTML_LIST);
+        ProcessWrapper pw = new ProcessWrapper(server.getJavawsLocation(), HTML_HEADLESS, server.getUrl(HTMLHREF));
+        pw.addStdOutListener(new AutoOkClosingListener());
+        pw.addStdErrListener(new AutoErrorClosingListener());
+        //pw.setWriter("YES\nYES\nYES\nYES\n");
+        ProcessResult pr = pw.execute();
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAttsSigned));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    public static void prepare(String codebase) throws IOException {
+        prepare(codebase, codebase);
+    }
+
+    public static void prepare(String codebase1, String codebase2) throws IOException {
+        prepareSingle(codebase1, null, null, '1', ServerAccess.getInstance().getDir(), files, true);
+        prepareSingle(codebase2, null, null, '2', secondValidServer.getDir(), files, true);
+    }
+
+    //note, that the modification of jar is breaking signature.. well worthy to add test :)
+    public static void prepareSingle(String codebase, String jnlphref, String jar, char id, File targetDir, String[] files, boolean corrupt) throws IOException {
+        File srcDir = ServerAccess.getInstance().getDir();
+        for (String file : files) {
+            String s1 = FileUtils.loadFileAsString(new File(srcDir, file + ".in"));
+            if (codebase == null) {
+                s1 = s1.replace("@CODEBASE@", "");
+            } else {
+                s1 = s1.replace("@CODEBASE@", "codebase=\"" + codebase + "\"");
+            }
+            if (jnlphref == null) {
+                s1 = s1.replace("@JNLPHREF@", "CodebasesAttsSignedApplet.jnlp");
+            } else {
+                s1 = s1.replace("@JNLPHREF@", jnlphref + "/CodebasesAttsSignedApplet.jnlp");
+            }
+            if (jar == null) {
+                s1 = s1.replace("@JAR@", "CodebasesAttsSigned");
+            } else {
+                s1 = s1.replace("@JAR@", jar + "/CodebasesAttsSigned");
+            }
+            s1 = s1.replace("@ID@", "" + id);
+            FileUtils.saveFile(s1, new File(targetDir, file));
+        }
+        String n = "CodebasesAttsSigned.jar";
+        if (!srcDir.equals(targetDir)) {
+            copyJarAndChange(new File(srcDir, n), new File(targetDir, n), id, corrupt);
+        }
+    }
+
+    /**
+     * This copy zip jar entry by entry, and for one particular class it do BYTE
+     * changes
+     *
+     * @param from
+     * @param to
+     * @param id
+     * @throws FileNotFoundException
+     * @throws IOException
+     */
+    private static void copyJarAndChange(File from, File to, char id, boolean corruptSignatures) throws FileNotFoundException, IOException {
+        ZipFile original = new ZipFile(from);
+        try (ZipOutputStream outputStream = new ZipOutputStream(new FileOutputStream(to))) {
+            Enumeration entries = original.entries();
+            byte[] buffer = new byte[512];
+            while (entries.hasMoreElements()) {
+                ZipEntry entry = (ZipEntry) entries.nextElement();
+                if (entry.getName().endsWith("CodebasesAttsSigned.class") && corruptSignatures) {
+                    ZipEntry newEntry = new ZipEntry(entry.getName());
+                    outputStream.putNextEntry(newEntry);
+                    try (InputStream in = original.getInputStream(entry)) {
+                        copyStreamAndChange(in, outputStream, id);
+                    }
+                } else {
+                    ZipEntry newEntry = new ZipEntry(entry.getName());
+                    outputStream.putNextEntry(newEntry);
+                    try (InputStream in = original.getInputStream(entry)) {
+                        while (0 < in.available()) {
+                            int read = in.read(buffer);
+                            outputStream.write(buffer, 0, read);
+                        }
+                    }
+                }
+                outputStream.closeEntry();
+            }
+        }
+    }
+
+    /**
+     * This changes bytes BID0 to BID'idchar'.
+     *
+     * @param din
+     * @param dout
+     * @param id
+     * @throws FileNotFoundException
+     * @throws IOException
+     */
+    private static void copyStreamAndChange(InputStream din, OutputStream dout, char id) throws FileNotFoundException, IOException {
+        int c;
+        final boolean[] BID0 = new boolean[]{false, false, false};
+        while ((c = din.read()) != -1) {
+            if (c == 'B') {
+                BID0[0] = true;
+                dout.write((byte) c);
+            } else if (c == 'I' && BID0[0]) {
+                BID0[1] = true;
+                dout.write((byte) c);
+            } else if (c == 'D' && BID0[1]) {
+                BID0[2] = true;
+                dout.write((byte) c);
+            } else if (c == '0' && BID0[2]) {
+                dout.write((byte) id);
+                reset(BID0);
+            } else {
+                reset(BID0);
+                dout.write((byte) c);
+            }
+        }
+    }
+
+    private static void reset(final boolean[] b) {
+        for (int i = 0; i < b.length; i++) {
+            b[i] = false;
+
+        }
+    }
+
+    //reading corruptied jars
+    @NeedsDisplay
+    @Test
+    public void codebasesAttsSignedTestWorksJnlp1_null_corruptedJar() throws Exception {
+        prepare(null);
+        ProcessWrapper pw = new ProcessWrapper(server.getJavawsLocation(), JAVAWS_HEADLES_LIST, secondValidServer.getUrl(JNLPAPP));
+        pw.addStdOutListener(new AutoOkClosingListener());
+        pw.addStdErrListener(new AutoErrorClosingListener());
+        ProcessResult pr = pw.execute();
+        generalFailure(pr);
+    }
+
+    @NeedsDisplay
+    @Test
+    @Bug(id = "PR2489")
+    public void codebasesAttsSignedTestWorksJnlp2_null_corruptedJar() throws Exception {
+        prepare(null);
+        ProcessWrapper pw = new ProcessWrapper(server.getJavawsLocation(), JAVAWS_HEADLES_LIST, secondValidServer.getUrl(JNLPAPPLET));
+        pw.addStdOutListener(new AutoOkClosingListener());
+        pw.addStdErrListener(new AutoErrorClosingListener());
+        ProcessResult pr = pw.execute();
+        generalFailure(pr);
+    }
+
+    @NeedsDisplay
+    @Test  // browsers dont support headless dialogues
+    @TestInBrowsers(testIn = Browsers.one)
+    @Bug(id = "PR2489")
+    public void codebasesAttsSignedTestWorksHtml1_null_corruptedJar() throws Exception {
+        prepare(null);
+        ProcessResult pr = server.executeBrowser(null, secondValidServer.getUrl(HTML), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        generalFailure(pr);
+    }
+
+    @NeedsDisplay
+    @Test //browsers do not support ehadless dialogues
+    @TestInBrowsers(testIn = Browsers.one)
+    @Bug(id = "PR2489")
+    public void codebasesAttsSignedTestWorksHtml2_null_corruptedJar() throws Exception {
+        prepare(null);
+        ProcessResult pr = server.executeBrowser(null, secondValidServer.getUrl(HTMLHREF), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        generalFailure(pr);
+    }
+
+    @NeedsDisplay
+    @Test
+    @Bug(id = "PR2489")
+    public void codebasesAttsSignedTestWorksJavawsHtml1_null_corruptedJar() throws Exception {
+        prepare(null);
+        ArrayList<String> HTML_HEADLESS = new ArrayList<>();
+        HTML_HEADLESS.addAll(JAVAWS_HEADLES_LIST);
+        HTML_HEADLESS.addAll(JAVAWS_HTML_LIST);
+        ProcessWrapper pw = new ProcessWrapper(server.getJavawsLocation(), HTML_HEADLESS, secondValidServer.getUrl(HTML));
+        pw.addStdOutListener(new AutoOkClosingListener());
+        pw.addStdErrListener(new AutoErrorClosingListener());
+        ProcessResult pr = pw.execute();
+        generalFailure(pr);
+    }
+
+    @NeedsDisplay
+    @Test
+    @Bug(id = "PR2489")
+    public void codebasesAttsSignedTestWorksJavawsHtml2_null_corruptedJar() throws Exception {
+        prepare(null);
+        ArrayList<String> HTML_HEADLESS = new ArrayList<>();
+        HTML_HEADLESS.addAll(JAVAWS_HEADLES_LIST);
+        HTML_HEADLESS.addAll(JAVAWS_HTML_LIST);
+        ProcessWrapper pw = new ProcessWrapper(server.getJavawsLocation(), HTML_HEADLESS, secondValidServer.getUrl(HTMLHREF));
+        pw.addStdOutListener(new AutoOkClosingListener());
+        pw.addStdErrListener(new AutoErrorClosingListener());
+        ProcessResult pr = pw.execute();
+        generalFailure(pr);
+    }
+
+    public void generalFailure(String s) {
+        Assert.assertFalse(s.contains(appletCloseString));
+        Assert.assertFalse(s.contains("id:"));
+        Assert.assertFalse(s.contains("BID"));
+    }
+
+    private void generalFailure(ProcessResult pr) {
+        generalFailure(pr.stdout);
+    }
+
+    private void prepareSwapResources() throws IOException {
+        prepareSingle(null, null, secondValidServer.getUrl().toExternalForm(), '1', ServerAccess.getInstance().getDir(), files, true);
+        prepareSingle(null, null, server.getUrl().toExternalForm(), '2', secondValidServer.getDir(), files, true);
+    }
+
+}
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/simple/CodebasesAtts/resources/CodebasesAtts.html.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/reproducers/simple/CodebasesAtts/resources/CodebasesAtts.html.in	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,46 @@
+<!--
+
+This file is part of IcedTea.
+
+IcedTea is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+IcedTea is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with IcedTea; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version.
+
+ -->
+
+<html>
+<head></head>
+<body>
+	<applet code="CodebasesAtts.class" archive="@JAR@.jar" @CODEBASE@ width="100" height="100">
+		<param name="id" value="@ID@">
+	</applet>
+</body>
+</html>
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/simple/CodebasesAtts/resources/CodebasesAttsApp.jnlp.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/reproducers/simple/CodebasesAtts/resources/CodebasesAttsApp.jnlp.in	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,55 @@
+<!--
+
+This file is part of IcedTea.
+
+IcedTea is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+IcedTea is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with IcedTea; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version.
+
+ -->
+
+<?xml version="1.0" encoding="utf-8"?>
+<jnlp spec="1.0" href="CodebasesAttsApp.jnlp" @CODEBASE@>
+  <information>
+	<title>CodebasesAtts</title>
+    <vendor>IcedTea</vendor>
+    <homepage href="http://icedtea.classpath.org/wiki/IcedTea-Web#Testing_IcedTea-Web"/>
+    <description>PR2489</description>
+    <offline/>
+  </information>
+  <resources>
+    <j2se version="1.4+"/>
+    <jar href="@JAR@.jar"/>
+  </resources>
+  <application-desc main-class="CodebasesAtts">
+    <argument>@ID@</argument>
+  </application-desc>
+</jnlp>
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/simple/CodebasesAtts/resources/CodebasesAttsApplet.jnlp.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/reproducers/simple/CodebasesAtts/resources/CodebasesAttsApplet.jnlp.in	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,59 @@
+<!--
+
+This file is part of IcedTea.
+
+IcedTea is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+IcedTea is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with IcedTea; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version.
+
+ -->
+
+<?xml version="1.0" encoding="utf-8"?>
+<jnlp spec="1.0" href="CodebasesAttsApplet.jnlp" @CODEBASE@>
+	<information>
+    	<title>CodebasesAtts</title>
+    	<vendor>IcedTea</vendor>
+    	<homepage href="http://icedtea.classpath.org/wiki/IcedTea-Web#Testing_IcedTea-Web"/>
+    	<description>PR2489</description>
+    	<offline/>
+	</information>
+	<resources>
+	  	<j2se version="1.4+"/>
+		<jar href="@JAR@.jar"/>
+	</resources>
+	<applet-desc
+	  name="CodebasesAtts"
+	  main-class="CodebasesAtts"
+	  width="100"
+	  height="100">
+            <param name="id" value="@ID@">
+	</applet-desc>
+</jnlp>
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/simple/CodebasesAtts/resources/CodebasesAttsJnlpHref.html.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/reproducers/simple/CodebasesAtts/resources/CodebasesAttsJnlpHref.html.in	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,47 @@
+<!--
+
+This file is part of IcedTea.
+
+IcedTea is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+IcedTea is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with IcedTea; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version.
+
+ -->
+
+<html>
+<head></head>
+<body>
+	<applet width="100" height="100" code="@JAR@"  @CODEBASE@ >
+		<param name="jnlp_href" value="@JNLPHREF@">
+                <param name="id" value="@ID@">
+	</applet>
+</body>
+</html>
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/simple/CodebasesAtts/srcs/CodebasesAtts.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/reproducers/simple/CodebasesAtts/srcs/CodebasesAtts.java	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,86 @@
+/* ExtensionJnlpTestApplet.java
+ Copyright (C) 2013 Red Hat, Inc.
+
+ This file is part of IcedTea.
+
+ IcedTea is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, version 2.
+
+ IcedTea is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with IcedTea; see the file COPYING.  If not, write to
+ the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301 USA.
+
+ Linking this library statically or dynamically with other modules is
+ making a combined work based on this library.  Thus, the terms and
+ conditions of the GNU General Public License cover the whole
+ combination.
+
+ As a special exception, the copyright holders of this library give you
+ permission to link this library with independent modules to produce an
+ executable, regardless of the license terms of these independent
+ modules, and to copy and distribute the resulting executable under
+ terms of your choice, provided that you also meet, for each linked
+ independent module, the terms and conditions of the license of that
+ module.  An independent module is a module which is not derived from
+ or based on this library.  If you modify this library, you may extend
+ this exception to your version of the library, but you are not
+ obligated to do so.  If you do not wish to do so, delete this
+ exception statement from your version.
+ */
+
+import java.applet.*;
+import java.awt.Graphics;
+
+/**
+ *
+ * Note that for html's appelt and jnlphreff's jnlp file may have different
+ * codebase.
+ *
+ */
+public class CodebasesAtts extends Applet {
+
+    private static final String appletCloseString = "*** APPLET FINISHED ***";
+    private static final String bid = "BID0";
+
+    public static void main(String... args) {
+        System.out.println("id: "+args[0]);
+        System.out.println("BID: "+bid);
+        System.out.println(CodebasesAtts.class.getName());
+        System.out.println(appletCloseString);
+        System.out.flush();
+        System.out.println("some garbage");
+    }
+
+    @Override
+    public void init() {
+
+    }
+
+    @Override
+    public void start() {
+        main(getParameter("id"));
+    }
+
+    @Override
+    public void stop() {
+
+    }
+
+    @Override
+    public void destroy() {
+
+    }
+
+    @Override
+    public void paint(Graphics g) {
+
+    }
+
+}
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/simple/CodebasesAtts/testcases/CodebasesAttsDialogsTest1.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/reproducers/simple/CodebasesAtts/testcases/CodebasesAttsDialogsTest1.java	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,239 @@
+/* CodebasesAttsNoDialogsTest1.java
+ Copyright (C) 2013 Red Hat, Inc.
+
+ This file is part of IcedTea.
+
+ IcedTea is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, version 2.
+
+ IcedTea is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with IcedTea; see the file COPYING.  If not, write to
+ the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301 USA.
+
+ Linking this library statically or dynamically with other modules is
+ making a combined work based on this library.  Thus, the terms and
+ conditions of the GNU General Public License cover the whole
+ combination.
+
+ As a special exception, the copyright holders of this library give you
+ permission to link this library with independent modules to produce an
+ executable, regardless of the license terms of these independent
+ modules, and to copy and distribute the resulting executable under
+ terms of your choice, provided that you also meet, for each linked
+ independent module, the terms and conditions of the license of that
+ module.  An independent module is a module which is not derived from
+ or based on this library.  If you modify this library, you may extend
+ this exception to your version of the library, but you are not
+ obligated to do so.  If you do not wish to do so, delete this
+ exception statement from your version.
+ */
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.URL;
+import java.util.AbstractMap;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Enumeration;
+import java.util.List;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+import java.util.zip.ZipOutputStream;
+import net.sourceforge.jnlp.OptionsDefinitions;
+import net.sourceforge.jnlp.ProcessResult;
+import net.sourceforge.jnlp.ProcessWrapper;
+import net.sourceforge.jnlp.ServerAccess;
+import net.sourceforge.jnlp.ServerLauncher;
+import net.sourceforge.jnlp.annotations.Bug;
+import net.sourceforge.jnlp.annotations.NeedsDisplay;
+import net.sourceforge.jnlp.annotations.TestInBrowsers;
+import net.sourceforge.jnlp.browsertesting.BrowserTest;
+import static net.sourceforge.jnlp.browsertesting.BrowserTest.server;
+import net.sourceforge.jnlp.browsertesting.Browsers;
+import net.sourceforge.jnlp.closinglisteners.AutoErrorClosingListener;
+import net.sourceforge.jnlp.closinglisteners.AutoOkClosingListener;
+import net.sourceforge.jnlp.config.DeploymentConfiguration;
+import net.sourceforge.jnlp.runtime.ManifestAttributesChecker;
+import net.sourceforge.jnlp.security.appletextendedsecurity.AppletSecurityLevel;
+import net.sourceforge.jnlp.tools.DeploymentPropertiesModifier;
+import net.sourceforge.jnlp.util.FileUtils;
+import org.junit.AfterClass;
+
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+/**
+ *
+ * null, empty, none, wrong, correct jnlp x html different codebases.
+ *
+ * no dialogs should be appeared. Second testsuite with ALL dialogs (head only)
+ *
+ *
+ */
+public class CodebasesAttsDialogsTest1 extends BrowserTest {
+
+    private static final String appletCloseString = CodebasesAttsNoDialogsTest1.appletCloseString;
+    private static final String[] JAVAWS_HTML_ARRAY = CodebasesAttsNoDialogsTest1.JAVAWS_HTML_ARRAY;
+    private static final List<String> JAVAWS_HTML_LIST = CodebasesAttsNoDialogsTest1.JAVAWS_HTML_LIST;
+    //disabled - 1.6 specific. We need dialogs to pop up.  Anyway, in 1.6 all such tests are disbaled for runtime anyway
+    private static final String[] JAVAWS_HEADLES_ARRAY = new String[]{};//{OptionsDefinitions.OPTIONS.HTML.HEADLESS.option};
+    private static final List<String> JAVAWS_HEADLES_LIST = Arrays.asList(JAVAWS_HEADLES_ARRAY);
+
+    private static final String JNLPAPP = CodebasesAttsNoDialogsTest1.JNLPAPP;
+    private static final String JNLPAPPLET = CodebasesAttsNoDialogsTest1.JNLPAPPLET;
+    private static final String HTML = CodebasesAttsNoDialogsTest1.HTML;
+    private static final String HTMLHREF = CodebasesAttsNoDialogsTest1.HTMLHREF;
+    private static final String CodebasesAtts = CodebasesAttsNoDialogsTest1.CodebasesAtts;
+
+    private static ServerLauncher secondValidServer;
+    private static DeploymentPropertiesModifier.MultipleDeploymentPropertiesModifier ensuredDP;
+
+    public static final String[] files = new String[]{"CodebasesAttsApp.jnlp", "CodebasesAtts.html", "CodebasesAttsApplet.jnlp", "CodebasesAttsJnlpHref.html"};
+
+    @BeforeClass
+    public static void initSecondaryServers() throws IOException {
+        secondValidServer = ServerAccess.getIndependentInstanceOnTmpDir();
+    }
+
+    @AfterClass
+    public static void stopSecondaryServers() throws IOException {
+        secondValidServer.stop();
+    }
+
+    @BeforeClass
+    public static void setProperties() throws IOException {
+        ensuredDP = new DeploymentPropertiesModifier.MultipleDeploymentPropertiesModifier(
+                new AbstractMap.SimpleEntry(DeploymentConfiguration.KEY_ENABLE_MANIFEST_ATTRIBUTES_CHECK, ManifestAttributesChecker.MANIFEST_ATTRIBUTES_CHECK.ALL.name()),
+                new AbstractMap.SimpleEntry(DeploymentConfiguration.KEY_SECURITY_LEVEL, AppletSecurityLevel.ASK_UNSIGNED.name())
+        );
+        ensuredDP.setProperties();
+    }
+
+    @AfterClass
+    public static void resetProperties() throws IOException {
+        ensuredDP.restoreProperties();
+    }
+    
+    @Test
+    public void allTestsInThisFileAreDisabled(){
+        //because 1.6 do not support headless dialogues
+    }
+
+    @NeedsDisplay
+    //@Test
+    @Bug(id = "PR2489")
+    public void codebasesAttsTestWorksJnlp1_null() throws Exception {
+        prepare(null);
+        ProcessWrapper pw = new ProcessWrapper(server.getJavawsLocation(), JAVAWS_HEADLES_LIST, server.getUrl(JNLPAPP));
+        pw.addStdOutListener(new AutoOkClosingListener());
+        pw.addStdErrListener(new AutoErrorClosingListener());
+        //pw.setWriter("YES\nYES\nYES\nYES\n");
+        ProcessResult pr = pw.execute();
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    //@Test
+    @Bug(id = "PR2489")
+    public void codebasesAttsTestWorksJnlp2_null() throws Exception {
+        prepare(null);
+        ProcessWrapper pw = new ProcessWrapper(server.getJavawsLocation(), JAVAWS_HEADLES_LIST, server.getUrl(JNLPAPPLET));
+        pw.addStdOutListener(new AutoOkClosingListener());
+        pw.addStdErrListener(new AutoErrorClosingListener());
+        //pw.setWriter("YES\nYES\nYES\nYES\n");
+        ProcessResult pr = pw.execute();
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    //@Test  //rowsers dont support headless dialogues
+    @TestInBrowsers(testIn = Browsers.one)
+    @Bug(id = "PR2489")
+    public void codebasesAttsTestWorksHtml1_null() throws Exception {
+        prepare(null);
+        ProcessResult pr = server.executeBrowser(null, HTML, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    //@Test //browsers do not support ehadless dialogues
+    @TestInBrowsers(testIn = Browsers.one)
+    @Bug(id = "PR2489")
+    public void codebasesAttsTestWorksHtml2_null() throws Exception {
+        prepare(null);
+        ProcessResult pr = server.executeBrowser(null, HTMLHREF, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    //@Test
+    @Bug(id = "PR2489")
+    public void codebasesAttsTestWorksJavawsHtml1_null() throws Exception {
+        prepare(null);
+        ArrayList<String> HTML_HEADLESS = new ArrayList<>();
+        HTML_HEADLESS.addAll(JAVAWS_HEADLES_LIST);
+        HTML_HEADLESS.addAll(JAVAWS_HTML_LIST);
+        ProcessWrapper pw = new ProcessWrapper(server.getJavawsLocation(), HTML_HEADLESS, server.getUrl(HTML));
+        pw.addStdOutListener(new AutoOkClosingListener());
+        pw.addStdErrListener(new AutoErrorClosingListener());
+        //pw.setWriter("YES\nYES\nYES\nYES\n");
+        ProcessResult pr = pw.execute();
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    //@Test
+    @Bug(id = "PR2489")
+    public void codebasesAttsTestWorksJavawsHtml2_null() throws Exception {
+        prepare(null);
+        ArrayList<String> HTML_HEADLESS = new ArrayList<>();
+        HTML_HEADLESS.addAll(JAVAWS_HEADLES_LIST);
+        HTML_HEADLESS.addAll(JAVAWS_HTML_LIST);
+        ProcessWrapper pw = new ProcessWrapper(server.getJavawsLocation(), HTML_HEADLESS, server.getUrl(HTMLHREF));
+        pw.addStdOutListener(new AutoOkClosingListener());
+        pw.addStdErrListener(new AutoErrorClosingListener());
+        //pw.setWriter("YES\nYES\nYES\nYES\n");
+        ProcessResult pr = pw.execute();
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    public static void prepare(String codebase) throws IOException {
+        prepare(codebase, codebase);
+    }
+
+    public static void prepare(String codebase1, String codebase2) throws IOException {
+        CodebasesAttsNoDialogsTest1.prepareSingle(codebase1, null, null, '1', ServerAccess.getInstance().getDir(), files);
+        CodebasesAttsNoDialogsTest1.prepareSingle(codebase2, null, null, '2', secondValidServer.getDir(), files);
+    }
+
+}
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/simple/CodebasesAtts/testcases/CodebasesAttsNoDialogsTest1.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/reproducers/simple/CodebasesAtts/testcases/CodebasesAttsNoDialogsTest1.java	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,699 @@
+/* CodebasesAttsNoDialogsTest1.java
+ Copyright (C) 2013 Red Hat, Inc.
+
+ This file is part of IcedTea.
+
+ IcedTea is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, version 2.
+
+ IcedTea is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with IcedTea; see the file COPYING.  If not, write to
+ the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301 USA.
+
+ Linking this library statically or dynamically with other modules is
+ making a combined work based on this library.  Thus, the terms and
+ conditions of the GNU General Public License cover the whole
+ combination.
+
+ As a special exception, the copyright holders of this library give you
+ permission to link this library with independent modules to produce an
+ executable, regardless of the license terms of these independent
+ modules, and to copy and distribute the resulting executable under
+ terms of your choice, provided that you also meet, for each linked
+ independent module, the terms and conditions of the license of that
+ module.  An independent module is a module which is not derived from
+ or based on this library.  If you modify this library, you may extend
+ this exception to your version of the library, but you are not
+ obligated to do so.  If you do not wish to do so, delete this
+ exception statement from your version.
+ */
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.URL;
+import java.util.AbstractMap;
+import java.util.Arrays;
+import java.util.Enumeration;
+import java.util.List;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+import java.util.zip.ZipOutputStream;
+import net.sourceforge.jnlp.OptionsDefinitions;
+import net.sourceforge.jnlp.ProcessResult;
+import net.sourceforge.jnlp.ServerAccess;
+import net.sourceforge.jnlp.ServerLauncher;
+import net.sourceforge.jnlp.annotations.Bug;
+import net.sourceforge.jnlp.annotations.NeedsDisplay;
+import net.sourceforge.jnlp.annotations.TestInBrowsers;
+import net.sourceforge.jnlp.browsertesting.BrowserTest;
+import net.sourceforge.jnlp.browsertesting.Browsers;
+import net.sourceforge.jnlp.closinglisteners.AutoErrorClosingListener;
+import net.sourceforge.jnlp.closinglisteners.AutoOkClosingListener;
+import net.sourceforge.jnlp.config.DeploymentConfiguration;
+import net.sourceforge.jnlp.runtime.ManifestAttributesChecker;
+import net.sourceforge.jnlp.security.appletextendedsecurity.AppletSecurityLevel;
+import net.sourceforge.jnlp.tools.DeploymentPropertiesModifier;
+import net.sourceforge.jnlp.util.FileUtils;
+import org.junit.AfterClass;
+
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+/**
+ *
+ * null, empty, none, wrong, correct jnlp x html different codebases.
+ *
+ * no dialogs should be appeared. Second testsuite with ALL dialogs (head only)
+ *
+ *
+ */
+public class CodebasesAttsNoDialogsTest1 extends BrowserTest {
+
+    public static final String appletCloseString = AutoOkClosingListener.MAGICAL_OK_CLOSING_STRING;
+    public static final String[] JAVAWS_HTML_ARRAY = new String[]{OptionsDefinitions.OPTIONS.HTML.option};
+    public static final List<String> JAVAWS_HTML_LIST = Arrays.asList(JAVAWS_HTML_ARRAY);
+
+    public static final String JNLPAPP = "CodebasesAttsApp.jnlp";
+    public static final String JNLPAPPLET = "CodebasesAttsApplet.jnlp";
+    public static final String HTML = "CodebasesAtts.html";
+    public static final String HTMLHREF = "CodebasesAttsJnlpHref.html";
+    public static final String CodebasesAtts = "CodebasesAtts";
+
+    private static ServerLauncher emptyServer;
+    private static ServerLauncher secondValidServer;
+    private static DeploymentPropertiesModifier.MultipleDeploymentPropertiesModifier ensuredDP;
+
+    public static final String[] files = new String[]{"CodebasesAttsApp.jnlp", "CodebasesAtts.html", "CodebasesAttsApplet.jnlp", "CodebasesAttsJnlpHref.html"};
+
+    @BeforeClass
+    public static void initSecondaryServers() throws IOException {
+        emptyServer = ServerAccess.getIndependentInstanceOnTmpDir();
+        secondValidServer = ServerAccess.getIndependentInstanceOnTmpDir();
+    }
+
+    @AfterClass
+    public static void stopSecondaryServers() throws IOException {
+        emptyServer.stop();
+        secondValidServer.stop();
+    }
+
+    @BeforeClass
+    public static void setProperties() throws IOException {
+        ensuredDP = new DeploymentPropertiesModifier.MultipleDeploymentPropertiesModifier(
+                new AbstractMap.SimpleEntry(DeploymentConfiguration.KEY_ENABLE_MANIFEST_ATTRIBUTES_CHECK, ManifestAttributesChecker.MANIFEST_ATTRIBUTES_CHECK.NONE.name()),
+                new AbstractMap.SimpleEntry(DeploymentConfiguration.KEY_SECURITY_LEVEL, AppletSecurityLevel.ALLOW_UNSIGNED.name())
+        );
+        ensuredDP.setProperties();
+    }
+
+    @AfterClass
+    public static void resetProperties() throws IOException {
+        ensuredDP.restoreProperties();
+    }
+
+    //jnlp app 
+    @NeedsDisplay
+    @Test
+    public void codebasesAttsTestWorksJnlp1_dot() throws Exception {
+        prepare("\".\"");
+        ProcessResult pr = server.executeJavaws(JNLPAPP, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    public void codebasesAttsTestWorksJnlp1_empty() throws Exception {
+        prepare("\"\"");
+        ProcessResult pr = server.executeJavaws(JNLPAPP, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    public void codebasesAttsTestWorksJnlp1_space() throws Exception {
+        prepare("\" \"");
+        ProcessResult pr = server.executeJavaws(JNLPAPP, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    public void codebasesAttsTestWorksJnlp1_spaces() throws Exception {
+        prepare("\"     \"");
+        ProcessResult pr = server.executeJavaws(JNLPAPP, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    @Bug(id = "PR2489")
+    public void codebasesAttsTestWorksJnlp1_null() throws Exception {
+        prepare(null);
+        ProcessResult pr = server.executeJavaws(JNLPAPP, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    public void codebasesAttsTestWorksJnlp1_value() throws Exception {
+        prepare(server.getUrl().toString());
+        ProcessResult pr = server.executeJavaws(JNLPAPP, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    //all three are valid, but on l one bug is supported nows
+    @Bug(id = "http://icedtea.classpath.org/hg/icedtea-web/rev/22b7becd48a7")
+    //@Bug(id = "http://icedtea.classpath.org/hg/release/icedtea-web-1.6/rev/0d9faf51357d")
+    //@Bug(id = "http://mail.openjdk.java.net/pipermail/distro-pkg-dev/2016-January/034446.html")
+    public void codebasesAttsTestWorksJnlp1_value2() throws Exception {
+        prepare(secondValidServer.getUrl().toString());
+        ProcessResult pr = server.executeJavaws(JNLPAPP, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1")); //param comes from original jnlp, this will be visible on jnlp_href
+        Assert.assertTrue(pr.stdout.contains("BID2"));
+    }
+
+    @NeedsDisplay
+    @Test
+    public void codebasesAttsTestWorksJnlp1_value3() throws Exception {
+        prepare(secondValidServer.getUrl().toString());
+        ProcessResult pr = server.executeJavawsUponUrl(null, new URL(secondValidServer.getUrl().toString() + "/" + JNLPAPP), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 2"));
+        Assert.assertTrue(pr.stdout.contains("BID2"));
+    }
+
+    //value3 and 4 tests ar emoreover testing taht our three servers are working as expected.
+    @NeedsDisplay
+    @Test
+    //all three are valid, but on l one bug is supported now
+    @Bug(id = "http://icedtea.classpath.org/hg/release/icedtea-web-1.6/rev/0d9faf51357d")
+    //@Bug(id = "http://icedtea.classpath.org/hg/icedtea-web/rev/22b7becd48a7") 
+    //@Bug(id = "http://mail.openjdk.java.net/pipermail/distro-pkg-dev/2016-January/034446.html")
+    public void codebasesAttsTestWorksJnlp1_value4() throws Exception {
+        prepare(server.getUrl().toString());
+        ProcessResult pr = server.executeJavawsUponUrl(null, new URL(secondValidServer.getUrl().toString() + "/" + JNLPAPP), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 2")); //param comes from original jnlp, this will be visible on jnlp_href
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    //jnlp applet
+    @NeedsDisplay
+    @Test
+    public void codebasesAttsTestWorksJnlp2_dot() throws Exception {
+        prepare("\".\"");
+        ProcessResult pr = server.executeJavaws(JNLPAPPLET, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    public void codebasesAttsTestWorksJnlp2_empty() throws Exception {
+        prepare("\"\"");
+        ProcessResult pr = server.executeJavaws(JNLPAPPLET, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    public void codebasesAttsTestWorksJnlp2_space() throws Exception {
+        prepare("\" \"");
+        ProcessResult pr = server.executeJavaws(JNLPAPPLET, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    public void codebasesAttsTestWorksJnlp2_spaces() throws Exception {
+        prepare("\"     \"");
+        ProcessResult pr = server.executeJavaws(JNLPAPPLET, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    @Bug(id = "PR2489")
+    public void codebasesAttsTestWorksJnlp2_null() throws Exception {
+        prepare(null);
+        ProcessResult pr = server.executeJavaws(JNLPAPPLET, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    public void codebasesAttsTestWorksJnlp2_value() throws Exception {
+        prepare(server.getUrl().toString());
+        ProcessResult pr = server.executeJavaws(JNLPAPPLET, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    //all three are valid, but on l one bug is supported now
+    @Bug(id = "http://mail.openjdk.java.net/pipermail/distro-pkg-dev/2016-January/034446.html")
+    //@Bug(id = "http://icedtea.classpath.org/hg/release/icedtea-web-1.6/rev/0d9faf51357d")
+    //@Bug(id = "http://icedtea.classpath.org/hg/icedtea-web/rev/22b7becd48a7") 
+    public void codebasesAttsTestWorksJnlp2_value2() throws Exception {
+        prepare(secondValidServer.getUrl().toString());
+        ProcessResult pr = server.executeJavaws(JNLPAPPLET, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1")); //param comes from original jnlp, this will be visible on jnlp_href
+        Assert.assertTrue(pr.stdout.contains("BID2"));
+    }
+
+    @NeedsDisplay
+    @Test
+    public void codebasesAttsTestWorksJnlp2_value3() throws Exception {
+        prepare(secondValidServer.getUrl().toString());
+        ProcessResult pr = server.executeJavawsUponUrl(null, new URL(secondValidServer.getUrl().toString() + "/" + JNLPAPPLET), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 2"));
+        Assert.assertTrue(pr.stdout.contains("BID2"));
+    }
+
+    //value3 and 4 tests ar emoreover testing taht our three servers are working as expected.
+    @NeedsDisplay
+    @Test
+    //all three are valid, but on l one bug is supported now
+    //@Bug(id = "http://mail.openjdk.java.net/pipermail/distro-pkg-dev/2016-January/034446.html")
+    @Bug(id = "http://icedtea.classpath.org/hg/release/icedtea-web-1.6/rev/0d9faf51357d")
+    //@Bug(id = "http://icedtea.classpath.org/hg/icedtea-web/rev/22b7becd48a7") 
+    public void codebasesAttsTestWorksJnlp2_value4() throws Exception {
+        prepare(server.getUrl().toString());
+        ProcessResult pr = server.executeJavawsUponUrl(null, new URL(secondValidServer.getUrl().toString() + "/" + JNLPAPPLET), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 2")); //param comes from original jnlp, this will be visible on jnlp_href
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    public void codebasesAttsTestWorksHtml1_dot() throws Exception {
+        prepare("\".\"");
+        ProcessResult pr = server.executeBrowser(HTML, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    public void codebasesAttsTestWorksHtml1_empty() throws Exception {
+        prepare("\"\"");
+        ProcessResult pr = server.executeBrowser(HTML, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    public void codebasesAttsTestWorksJHtml1_space() throws Exception {
+        prepare("\" \"");
+        ProcessResult pr = server.executeBrowser(HTML, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    public void codebasesAttsTestWorksHtml1_spaces() throws Exception {
+        prepare("\"     \"");
+        ProcessResult pr = server.executeBrowser(HTML, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    @Bug(id = "PR2489")
+    public void codebasesAttsTestWorksHtml1_null() throws Exception {
+        prepare(null);
+        ProcessResult pr = server.executeBrowser(HTML, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    public void codebasesAttsTestWorksHtml1_value() throws Exception {
+        prepare(server.getUrl().toString());
+        ProcessResult pr = server.executeBrowser(HTML, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    //all three are valid, but on l one bug is supported now
+    //@Bug(id = "http://mail.openjdk.java.net/pipermail/distro-pkg-dev/2016-January/034446.html")
+    //@Bug(id = "http://icedtea.classpath.org/hg/release/icedtea-web-1.6/rev/0d9faf51357d")
+    @Bug(id = "http://icedtea.classpath.org/hg/icedtea-web/rev/22b7becd48a7")
+    public void codebasesAttsTestWorksHtml1_value2() throws Exception {
+        prepare(secondValidServer.getUrl().toString());
+        ProcessResult pr = server.executeBrowser(HTML, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1")); //param comes from original jnlp, this will be visible on jnlp_href
+        Assert.assertTrue(pr.stdout.contains("BID2"));
+    }
+
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    public void codebasesAttsTestWorksHtml1_value3() throws Exception {
+        prepare(secondValidServer.getUrl().toString());
+        ProcessResult pr = server.executeBrowser(null, new URL(secondValidServer.getUrl().toString() + "/" + HTML), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 2"));
+        Assert.assertTrue(pr.stdout.contains("BID2"));
+    }
+
+    //value3 and 4 tests ar emoreover testing taht our three servers are working as expected.
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    //all three are valid, but on l one bug is supported now
+    @Bug(id = "http://mail.openjdk.java.net/pipermail/distro-pkg-dev/2016-January/034446.html")
+    //@Bug(id = "http://icedtea.classpath.org/hg/release/icedtea-web-1.6/rev/0d9faf51357d")
+    //@Bug(id = "http://icedtea.classpath.org/hg/icedtea-web/rev/22b7becd48a7") 
+    public void codebasesAttsTestWorksHtml1_value4() throws Exception {
+        prepare(server.getUrl().toString());
+        ProcessResult pr = server.executeBrowser(null, new URL(secondValidServer.getUrl().toString() + "/" + HTML), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 2")); //param comes from original jnlp, this will be visible on jnlp_href
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    public void codebasesAttsTestWorksHtml2_dot() throws Exception {
+        prepare("\".\"");
+        ProcessResult pr = server.executeBrowser(HTMLHREF, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    public void codebasesAttsTestWorksHtml2_empty() throws Exception {
+        prepare("\"\"");
+        ProcessResult pr = server.executeBrowser(HTMLHREF, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    public void codebasesAttsTestWorksJHtml2_space() throws Exception {
+        prepare("\" \"");
+        ProcessResult pr = server.executeBrowser(HTMLHREF, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    public void codebasesAttsTestWorksHtml2_spaces() throws Exception {
+        prepare("\"     \"");
+        ProcessResult pr = server.executeBrowser(HTMLHREF, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    @Bug(id = "PR2489")
+    public void codebasesAttsTestWorksHtml2_null() throws Exception {
+        prepare(null);
+        ProcessResult pr = server.executeBrowser(HTMLHREF, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    public void codebasesAttsTestWorksHtml2_value() throws Exception {
+        prepare(server.getUrl().toString());
+        ProcessResult pr = server.executeBrowser(HTMLHREF, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    //all three are valid, but on l one bug is supported now
+    //@Bug(id = "http://mail.openjdk.java.net/pipermail/distro-pkg-dev/2016-January/034446.html")
+    @Bug(id = "http://icedtea.classpath.org/hg/release/icedtea-web-1.6/rev/0d9faf51357d")
+    //@Bug(id = "http://icedtea.classpath.org/hg/icedtea-web/rev/22b7becd48a7") 
+    public void codebasesAttsTestWorksHtml2_value2() throws Exception {
+        prepare(secondValidServer.getUrl().toString());
+        ProcessResult pr = server.executeBrowser(HTMLHREF, new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1")); //param comes from original jnlp, this will be visible on SECOND jnlp_href tests
+        Assert.assertTrue(pr.stdout.contains("BID2"));
+    }
+
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    public void codebasesAttsTestWorksHtml2_value3() throws Exception {
+        prepare(secondValidServer.getUrl().toString());
+        ProcessResult pr = server.executeBrowser(null, new URL(secondValidServer.getUrl().toString() + "/" + HTMLHREF), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 2"));
+        Assert.assertTrue(pr.stdout.contains("BID2"));
+    }
+
+    //value3 and 4 tests ar emoreover testing taht our three servers are working as expected.
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    //all three are valid, but on l one bug is supported now
+    //@Bug(id = "http://mail.openjdk.java.net/pipermail/distro-pkg-dev/2016-January/034446.html")
+    //@Bug(id = "http://icedtea.classpath.org/hg/release/icedtea-web-1.6/rev/0d9faf51357d")
+    @Bug(id = "http://icedtea.classpath.org/hg/icedtea-web/rev/22b7becd48a7")
+    public void codebasesAttsTestWorksHtml2_value4() throws Exception {
+        prepare(server.getUrl().toString());
+        ProcessResult pr = server.executeBrowser(null, new URL(secondValidServer.getUrl().toString() + "/" + HTMLHREF), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 2")); //param comes from original jnlp, this will be visible on jnlp_href
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    private static void prepare(String codebase) throws IOException {
+        prepare(codebase, codebase);
+    }
+
+    private static void prepare(String codebase1, String codebase2) throws IOException {
+        prepareSingle(codebase1, null, null, '1', ServerAccess.getInstance().getDir(), files);
+        prepareSingle(codebase2, null, null, '2', secondValidServer.getDir(), files);
+    }
+
+    public static void prepareSingle(URL codebase, String jnlphref, String jar, char id, File targetDir, String[] files) throws IOException {
+        prepareSingle(codebase.toExternalForm(), jnlphref, jar, id, targetDir, files);
+    }
+    public static void prepareSingle(String codebase, String jnlphref, String jar, char id, File targetDir, String[] files) throws IOException {
+        File srcDir = ServerAccess.getInstance().getDir();
+        for (String file : files) {
+            String s1 = FileUtils.loadFileAsString(new File(srcDir, file + ".in"));
+            if (codebase == null) {
+                s1 = s1.replace("@CODEBASE@", "");
+            } else {
+                s1 = s1.replace("@CODEBASE@", "codebase=\"" + codebase + "\"");
+            }
+            if (jnlphref == null) {
+                s1 = s1.replace("@JNLPHREF@", "CodebasesAttsApplet.jnlp");
+            } else {
+                s1 = s1.replace("@JNLPHREF@", jnlphref + "/CodebasesAttsApplet.jnlp");
+            }
+            if (jar == null) {
+                s1 = s1.replace("@JAR@", "CodebasesAtts");
+            } else {
+                s1 = s1.replace("@JAR@", jar + "/CodebasesAtts");
+            }
+            s1 = s1.replace("@ID@", "" + id);
+            FileUtils.saveFile(s1, new File(targetDir, file));
+        }
+        String n = "CodebasesAtts.jar";
+        if (!srcDir.equals(targetDir)) {
+            copyJarAndChange(new File(srcDir, n), new File(targetDir, n), id);
+        }
+    }
+
+    /**
+     * This copy zip jar entry by entry, and for one particular class it do BYTE
+     * changes
+     *
+     * @param from
+     * @param to
+     * @param id
+     * @throws FileNotFoundException
+     * @throws IOException
+     */
+    private static void copyJarAndChange(File from, File to, char id) throws FileNotFoundException, IOException {
+        ZipFile original = new ZipFile(from);
+        try (ZipOutputStream outputStream = new ZipOutputStream(new FileOutputStream(to))) {
+            Enumeration entries = original.entries();
+            byte[] buffer = new byte[512];
+            while (entries.hasMoreElements()) {
+                ZipEntry entry = (ZipEntry) entries.nextElement();
+                if (entry.getName().endsWith("CodebasesAtts.class")) {
+                    ZipEntry newEntry = new ZipEntry(entry.getName());
+                    outputStream.putNextEntry(newEntry);
+                    try (InputStream in = original.getInputStream(entry)) {
+                        copyStreamAndChange(in, outputStream, id);
+                    }
+                } else {
+                    ZipEntry newEntry = new ZipEntry(entry.getName());
+                    outputStream.putNextEntry(newEntry);
+                    try (InputStream in = original.getInputStream(entry)) {
+                        while (0 < in.available()) {
+                            int read = in.read(buffer);
+                            outputStream.write(buffer, 0, read);
+                        }
+                    }
+                }
+                outputStream.closeEntry();
+            }
+        }
+    }
+
+    /**
+     * This changes bytes BID0 to BID'idchar'.
+     *
+     * @param din
+     * @param dout
+     * @param id
+     * @throws FileNotFoundException
+     * @throws IOException
+     */
+    private static void copyStreamAndChange(InputStream din, OutputStream dout, char id) throws FileNotFoundException, IOException {
+        int c;
+        final boolean[] BID0 = new boolean[]{false, false, false};
+        while ((c = din.read()) != -1) {
+            if (c == 'B') {
+                BID0[0] = true;
+                dout.write((byte) c);
+            } else if (c == 'I' && BID0[0]) {
+                BID0[1] = true;
+                dout.write((byte) c);
+            } else if (c == 'D' && BID0[1]) {
+                BID0[2] = true;
+                dout.write((byte) c);
+            } else if (c == '0' && BID0[2]) {
+                dout.write((byte) id);
+                reset(BID0);
+            } else {
+                reset(BID0);
+                dout.write((byte) c);
+            }
+        }
+    }
+
+    private static void reset(final boolean[] b) {
+        for (int i = 0; i < b.length; i++) {
+            b[i] = false;
+
+        }
+    }
+
+}
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/simple/CodebasesAtts/testcases/CodebasesAttsNoDialogsTest2.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/reproducers/simple/CodebasesAtts/testcases/CodebasesAttsNoDialogsTest2.java	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,432 @@
+/* CodebasesAttsNoDialogsTest1.java
+ Copyright (C) 2013 Red Hat, Inc.
+
+ This file is part of IcedTea.
+
+ IcedTea is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, version 2.
+
+ IcedTea is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with IcedTea; see the file COPYING.  If not, write to
+ the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301 USA.
+
+ Linking this library statically or dynamically with other modules is
+ making a combined work based on this library.  Thus, the terms and
+ conditions of the GNU General Public License cover the whole
+ combination.
+
+ As a special exception, the copyright holders of this library give you
+ permission to link this library with independent modules to produce an
+ executable, regardless of the license terms of these independent
+ modules, and to copy and distribute the resulting executable under
+ terms of your choice, provided that you also meet, for each linked
+ independent module, the terms and conditions of the license of that
+ module.  An independent module is a module which is not derived from
+ or based on this library.  If you modify this library, you may extend
+ this exception to your version of the library, but you are not
+ obligated to do so.  If you do not wish to do so, delete this
+ exception statement from your version.
+ */
+
+import java.io.IOException;
+import java.net.URL;
+import java.util.AbstractMap;
+import java.util.Arrays;
+import java.util.List;
+import net.sourceforge.jnlp.OptionsDefinitions;
+import net.sourceforge.jnlp.ProcessResult;
+import net.sourceforge.jnlp.ServerAccess;
+import net.sourceforge.jnlp.ServerLauncher;
+import net.sourceforge.jnlp.annotations.Bug;
+import net.sourceforge.jnlp.annotations.NeedsDisplay;
+import net.sourceforge.jnlp.annotations.TestInBrowsers;
+import net.sourceforge.jnlp.browsertesting.BrowserTest;
+import net.sourceforge.jnlp.browsertesting.Browsers;
+import net.sourceforge.jnlp.closinglisteners.AutoErrorClosingListener;
+import net.sourceforge.jnlp.closinglisteners.AutoOkClosingListener;
+import net.sourceforge.jnlp.config.DeploymentConfiguration;
+import net.sourceforge.jnlp.runtime.ManifestAttributesChecker;
+import net.sourceforge.jnlp.security.appletextendedsecurity.AppletSecurityLevel;
+import net.sourceforge.jnlp.tools.DeploymentPropertiesModifier;
+import org.junit.AfterClass;
+
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+/**
+ *
+ * null, empty, none, wrong, correct jnlp x html different codebases.
+ *
+ * no dialogs should be appeared. Second testsuite with ALL dialogs (head only)
+ *
+ *
+ */
+public class CodebasesAttsNoDialogsTest2 extends BrowserTest {
+
+    private static final String appletCloseString = CodebasesAttsNoDialogsTest1.appletCloseString;
+    private static final String[] HTMLA = CodebasesAttsNoDialogsTest1.JAVAWS_HTML_ARRAY;
+    private static final List<String> HTMLL = CodebasesAttsNoDialogsTest1.JAVAWS_HTML_LIST;
+
+    private static final String JNLPAPP = CodebasesAttsNoDialogsTest1.JNLPAPP;
+    private static final String JNLPAPPLET = CodebasesAttsNoDialogsTest1.JNLPAPPLET;
+    private static final String HTML = CodebasesAttsNoDialogsTest1.HTML;
+    private static final String HTMLHREF = CodebasesAttsNoDialogsTest1.HTMLHREF;
+    private static final String CodebasesAtts = CodebasesAttsNoDialogsTest1.CodebasesAtts;
+
+    private static ServerLauncher secondValidServer;
+    private static DeploymentPropertiesModifier.MultipleDeploymentPropertiesModifier ensuredDP;
+
+    @BeforeClass
+    public static void initSecondaryServers() throws IOException {
+        secondValidServer = ServerAccess.getIndependentInstanceOnTmpDir();
+    }
+
+    @AfterClass
+    public static void stopSecondaryServers() throws IOException {
+        secondValidServer.stop();
+    }
+
+    @BeforeClass
+    public static void setProperties() throws IOException {
+        ensuredDP = new DeploymentPropertiesModifier.MultipleDeploymentPropertiesModifier(
+                new AbstractMap.SimpleEntry(DeploymentConfiguration.KEY_ENABLE_MANIFEST_ATTRIBUTES_CHECK, ManifestAttributesChecker.MANIFEST_ATTRIBUTES_CHECK.NONE.name()),
+                new AbstractMap.SimpleEntry(DeploymentConfiguration.KEY_SECURITY_LEVEL, AppletSecurityLevel.ALLOW_UNSIGNED.name())
+        );
+        ensuredDP.setProperties();
+    }
+
+    @AfterClass
+    public static void resetProperties() throws IOException {
+        ensuredDP.restoreProperties();
+    }
+
+    //jnlp app 
+    @NeedsDisplay
+    @Test
+    public void codebasesAttsTestWorksJnlp1_NormalValid_normal() throws Exception {
+        prepare(server.getUrl(), secondValidServer.getUrl());
+        ProcessResult pr = server.executeJavawsUponUrl(null, server.getUrl(JNLPAPP), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    public void codebasesAttsTestWorksJnlp1_NormalValid_second() throws Exception {
+        prepare(server.getUrl(), secondValidServer.getUrl());
+        ProcessResult pr = server.executeJavawsUponUrl(null, secondValidServer.getUrl(JNLPAPP), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 2"));
+        Assert.assertTrue(pr.stdout.contains("BID2"));
+    }
+
+    @NeedsDisplay
+    @Test
+    public void codebasesAttsTestWorksJnlp1_ValidNormal_normal() throws Exception {
+        prepare(secondValidServer.getUrl(), server.getUrl());
+        ProcessResult pr = server.executeJavawsUponUrl(null, server.getUrl(JNLPAPP), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID2"));
+    }
+
+    @NeedsDisplay
+    @Test
+    public void codebasesAttsTestWorksJnlp1_ValidNormal_second() throws Exception {
+        prepare(secondValidServer.getUrl(), server.getUrl());
+        ProcessResult pr = server.executeJavawsUponUrl(null, secondValidServer.getUrl(JNLPAPP), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 2"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    //jnlp app let
+    @NeedsDisplay
+    @Test
+    public void codebasesAttsTestWorksJnlp2_NormalValid_normal() throws Exception {
+        prepare(server.getUrl(), secondValidServer.getUrl());
+        ProcessResult pr = server.executeJavawsUponUrl(null, server.getUrl(JNLPAPPLET), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    public void codebasesAttsTestWorksJnlp2_NormalValid_second() throws Exception {
+        prepare(server.getUrl(), secondValidServer.getUrl());
+        ProcessResult pr = server.executeJavawsUponUrl(null, secondValidServer.getUrl(JNLPAPPLET), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 2"));
+        Assert.assertTrue(pr.stdout.contains("BID2"));
+    }
+
+    @NeedsDisplay
+    @Test
+    public void codebasesAttsTestWorksJnlp2_ValidNormal_normal() throws Exception {
+        prepare(secondValidServer.getUrl(), server.getUrl());
+        ProcessResult pr = server.executeJavawsUponUrl(null, server.getUrl(JNLPAPPLET), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID2"));
+    }
+
+    @NeedsDisplay
+    @Test
+    public void codebasesAttsTestWorksJnlp2_ValidNormal_second() throws Exception {
+        prepare(secondValidServer.getUrl(), server.getUrl());
+        ProcessResult pr = server.executeJavawsUponUrl(null, secondValidServer.getUrl(JNLPAPPLET), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 2"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    //html
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    public void codebasesAttsTestWorksHtml1_NormalValid_normal() throws Exception {
+        prepare(server.getUrl(), secondValidServer.getUrl());
+        ProcessResult pr = server.executeBrowser(null, server.getUrl(HTML), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    public void codebasesAttsTestWorksHtml1_NormalValid_second() throws Exception {
+        prepare(server.getUrl(), secondValidServer.getUrl());
+        ProcessResult pr = server.executeBrowser(null, secondValidServer.getUrl(HTML), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 2"));
+        Assert.assertTrue(pr.stdout.contains("BID2"));
+    }
+
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    public void codebasesAttsTestWorksHtml1_ValidNormal_normal() throws Exception {
+        prepare(secondValidServer.getUrl(), server.getUrl());
+        ProcessResult pr = server.executeBrowser(null, server.getUrl(HTML), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID2"));
+    }
+
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    public void codebasesAttsTestWorksHtml1_ValidNormal_second() throws Exception {
+        prepare(secondValidServer.getUrl(), server.getUrl());
+        ProcessResult pr = server.executeBrowser(null, secondValidServer.getUrl(HTML), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 2"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    //htmlhref relative hrefs
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    public void codebasesAttsTestWorksHtml2_NormalValid_normal() throws Exception {
+        prepare(server.getUrl(), secondValidServer.getUrl());
+        ProcessResult pr = server.executeBrowser(null, server.getUrl(HTMLHREF), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    public void codebasesAttsTestWorksHtml2_NormalValid_second() throws Exception {
+        prepare(server.getUrl(), secondValidServer.getUrl());
+        ProcessResult pr = server.executeBrowser(null, secondValidServer.getUrl(HTMLHREF), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 2"));
+        Assert.assertTrue(pr.stdout.contains("BID2"));
+    }
+
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    public void codebasesAttsTestWorksHtml2_ValidNormal_normal() throws Exception {
+        prepare(secondValidServer.getUrl(), server.getUrl());
+        ProcessResult pr = server.executeBrowser(null, server.getUrl(HTMLHREF), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0")); //codebase is relative, so launchiong server is used to locate jnlp
+    }
+
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    public void codebasesAttsTestWorksHtml2_ValidNormal_second() throws Exception {
+        prepare(secondValidServer.getUrl(), server.getUrl());
+        ProcessResult pr = server.executeBrowser(null, secondValidServer.getUrl(HTMLHREF), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 2"));
+        Assert.assertTrue(pr.stdout.contains("BID2"));//jnlphref is relative, so launchiong server is used to locate jnlp
+    }
+
+    public void prepare(URL c1, URL c2) throws IOException {
+        prepare(c1.toExternalForm(), c2.toExternalForm());
+    }
+
+    public static void prepare(String codebase1, String codebase2) throws IOException {
+        CodebasesAttsNoDialogsTest1.prepareSingle(codebase1, null, null, '1', ServerAccess.getInstance().getDir(), CodebasesAttsNoDialogsTest1.files);
+        CodebasesAttsNoDialogsTest1.prepareSingle(codebase2, null, null, '2', secondValidServer.getDir(), CodebasesAttsNoDialogsTest1.files);
+    }
+
+    //htmlhref absolute hrefs
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    public void codebasesAttsTestWorksHtml2_NormalValid_normal_absoluteJnlpHrefNormal() throws Exception {
+        CodebasesAttsNoDialogsTest1.prepareSingle(server.getUrl(), server.getUrl().toExternalForm(), null, '1', ServerAccess.getInstance().getDir(), CodebasesAttsNoDialogsTest1.files);
+        CodebasesAttsNoDialogsTest1.prepareSingle(secondValidServer.getUrl(), server.getUrl().toExternalForm(), null, '2', secondValidServer.getDir(), CodebasesAttsNoDialogsTest1.files);
+
+        ProcessResult pr = server.executeBrowser(null, server.getUrl(HTMLHREF), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    //all three are valid, but on l one bug is supported now
+    @Bug(id = "http://mail.openjdk.java.net/pipermail/distro-pkg-dev/2016-January/034446.html")
+    //@Bug(id = "http://icedtea.classpath.org/hg/release/icedtea-web-1.6/rev/0d9faf51357d")
+    //@Bug(id = "http://icedtea.classpath.org/hg/icedtea-web/rev/22b7becd48a7")
+    public void codebasesAttsTestWorksHtml2_NormalValid_normal_absoluteJnlpHrefSecond() throws Exception {
+        CodebasesAttsNoDialogsTest1.prepareSingle(server.getUrl(), secondValidServer.getUrl().toExternalForm(), null, '1', ServerAccess.getInstance().getDir(), CodebasesAttsNoDialogsTest1.files);
+        CodebasesAttsNoDialogsTest1.prepareSingle(secondValidServer.getUrl(), secondValidServer.getUrl().toExternalForm(), null, '2', secondValidServer.getDir(), CodebasesAttsNoDialogsTest1.files);
+
+        ProcessResult pr = server.executeBrowser(null, server.getUrl(HTMLHREF), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID2"));
+    }
+
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    //all three are valid, but on l one bug is supported now
+    //@Bug(id = "http://mail.openjdk.java.net/pipermail/distro-pkg-dev/2016-January/034446.html")
+    @Bug(id = "http://icedtea.classpath.org/hg/release/icedtea-web-1.6/rev/0d9faf51357d")
+    //@Bug(id = "http://icedtea.classpath.org/hg/icedtea-web/rev/22b7becd48a7")
+    public void codebasesAttsTestWorksHtml2_NormalValid_second_absoluteJnlpHrefNormal() throws Exception {
+        CodebasesAttsNoDialogsTest1.prepareSingle(server.getUrl(), server.getUrl().toExternalForm(), null, '1', ServerAccess.getInstance().getDir(), CodebasesAttsNoDialogsTest1.files);
+        CodebasesAttsNoDialogsTest1.prepareSingle(secondValidServer.getUrl(), server.getUrl().toExternalForm(), null, '2', secondValidServer.getDir(), CodebasesAttsNoDialogsTest1.files);
+
+        ProcessResult pr = server.executeBrowser(null, secondValidServer.getUrl(HTMLHREF), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 2"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    public void codebasesAttsTestWorksHtml2_NormalValid_second_absoluteJnlpHrefSecond() throws Exception {
+        CodebasesAttsNoDialogsTest1.prepareSingle(server.getUrl(), secondValidServer.getUrl().toExternalForm(), null, '1', ServerAccess.getInstance().getDir(), CodebasesAttsNoDialogsTest1.files);
+        CodebasesAttsNoDialogsTest1.prepareSingle(secondValidServer.getUrl(), secondValidServer.getUrl().toExternalForm(), null, '2', secondValidServer.getDir(), CodebasesAttsNoDialogsTest1.files);
+
+        ProcessResult pr = server.executeBrowser(null, secondValidServer.getUrl(HTMLHREF), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 2"));
+        Assert.assertTrue(pr.stdout.contains("BID2"));
+    }
+
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    //all three are valid, but on l one bug is supported now
+    //@Bug(id = "http://mail.openjdk.java.net/pipermail/distro-pkg-dev/2016-January/034446.html")
+    //@Bug(id = "http://icedtea.classpath.org/hg/release/icedtea-web-1.6/rev/0d9faf51357d")
+    @Bug(id = "http://icedtea.classpath.org/hg/icedtea-web/rev/22b7becd48a7")
+    public void codebasesAttsTestWorksHtml2_ValidNormal_normal_absoluteJnlpHrefNormal() throws Exception {
+        CodebasesAttsNoDialogsTest1.prepareSingle(secondValidServer.getUrl(), server.getUrl().toExternalForm(), null, '1', ServerAccess.getInstance().getDir(), CodebasesAttsNoDialogsTest1.files);
+        CodebasesAttsNoDialogsTest1.prepareSingle(server.getUrl(), server.getUrl().toExternalForm(), null, '2', secondValidServer.getDir(), CodebasesAttsNoDialogsTest1.files);
+        ProcessResult pr = server.executeBrowser(null, server.getUrl(HTMLHREF), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID2"));
+    }
+
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    public void codebasesAttsTestWorksHtml2_ValidNormal_normal_absoluteJnlpHrefSecond() throws Exception {
+        CodebasesAttsNoDialogsTest1.prepareSingle(secondValidServer.getUrl(), secondValidServer.getUrl().toExternalForm(), null, '1', ServerAccess.getInstance().getDir(), CodebasesAttsNoDialogsTest1.files);
+        CodebasesAttsNoDialogsTest1.prepareSingle(server.getUrl(), secondValidServer.getUrl().toExternalForm(), null, '2', secondValidServer.getDir(), CodebasesAttsNoDialogsTest1.files);
+        ProcessResult pr = server.executeBrowser(null, server.getUrl(HTMLHREF), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 1"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    public void codebasesAttsTestWorksHtml2_ValidNormal_second_bsoluteJnlpHrefNormal() throws Exception {
+        CodebasesAttsNoDialogsTest1.prepareSingle(secondValidServer.getUrl(), server.getUrl().toExternalForm(), null, '1', ServerAccess.getInstance().getDir(), CodebasesAttsNoDialogsTest1.files);
+        CodebasesAttsNoDialogsTest1.prepareSingle(server.getUrl(), server.getUrl().toExternalForm(), null, '2', secondValidServer.getDir(), CodebasesAttsNoDialogsTest1.files);
+        ProcessResult pr = server.executeBrowser(null, secondValidServer.getUrl(HTMLHREF), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 2"));
+        Assert.assertTrue(pr.stdout.contains("BID2"));
+    }
+
+    @NeedsDisplay
+    @Test
+    @TestInBrowsers(testIn = Browsers.one)
+    //all three are valid, but on l one bug is supported now
+    @Bug(id = "http://mail.openjdk.java.net/pipermail/distro-pkg-dev/2016-January/034446.html")
+    //@Bug(id = "http://icedtea.classpath.org/hg/release/icedtea-web-1.6/rev/0d9faf51357d")
+    //@Bug(id = "http://icedtea.classpath.org/hg/icedtea-web/rev/22b7becd48a
+    public void codebasesAttsTestWorksHtml2_ValidNormal_second_bsoluteJnlpHrefSecond() throws Exception {
+        CodebasesAttsNoDialogsTest1.prepareSingle(secondValidServer.getUrl(), secondValidServer.getUrl().toExternalForm(), null, '1', ServerAccess.getInstance().getDir(), CodebasesAttsNoDialogsTest1.files);
+        CodebasesAttsNoDialogsTest1.prepareSingle(server.getUrl(), secondValidServer.getUrl().toExternalForm(), null, '2', secondValidServer.getDir(), CodebasesAttsNoDialogsTest1.files);
+        ProcessResult pr = server.executeBrowser(null, secondValidServer.getUrl(HTMLHREF), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        Assert.assertTrue(pr.stdout.contains(appletCloseString));
+        Assert.assertTrue(pr.stdout.contains(CodebasesAtts));
+        Assert.assertTrue(pr.stdout.contains("id: 2"));
+        Assert.assertTrue(pr.stdout.contains("BID0"));
+    }
+
+}
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/simple/CodebasesAtts/testcases/CodebasesAttsNoDialogsTest3.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/reproducers/simple/CodebasesAtts/testcases/CodebasesAttsNoDialogsTest3.java	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,308 @@
+/* CodebasesAttsNoDialogsTest1.java
+ Copyright (C) 2013 Red Hat, Inc.
+
+ This file is part of IcedTea.
+
+ IcedTea is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, version 2.
+
+ IcedTea is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with IcedTea; see the file COPYING.  If not, write to
+ the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301 USA.
+
+ Linking this library statically or dynamically with other modules is
+ making a combined work based on this library.  Thus, the terms and
+ conditions of the GNU General Public License cover the whole
+ combination.
+
+ As a special exception, the copyright holders of this library give you
+ permission to link this library with independent modules to produce an
+ executable, regardless of the license terms of these independent
+ modules, and to copy and distribute the resulting executable under
+ terms of your choice, provided that you also meet, for each linked
+ independent module, the terms and conditions of the license of that
+ module.  An independent module is a module which is not derived from
+ or based on this library.  If you modify this library, you may extend
+ this exception to your version of the library, but you are not
+ obligated to do so.  If you do not wish to do so, delete this
+ exception statement from your version.
+ */
+
+import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.AbstractMap;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Random;
+import net.sourceforge.jnlp.OptionsDefinitions;
+import net.sourceforge.jnlp.ProcessResult;
+import net.sourceforge.jnlp.ServerAccess;
+import net.sourceforge.jnlp.ServerLauncher;
+import net.sourceforge.jnlp.annotations.Bug;
+import net.sourceforge.jnlp.annotations.KnownToFail;
+import net.sourceforge.jnlp.annotations.NeedsDisplay;
+import net.sourceforge.jnlp.annotations.TestInBrowsers;
+import net.sourceforge.jnlp.browsertesting.Browser;
+import net.sourceforge.jnlp.browsertesting.BrowserFactory;
+import net.sourceforge.jnlp.browsertesting.BrowserTest;
+import static net.sourceforge.jnlp.browsertesting.BrowserTest.server;
+import net.sourceforge.jnlp.browsertesting.Browsers;
+import net.sourceforge.jnlp.closinglisteners.AutoErrorClosingListener;
+import net.sourceforge.jnlp.closinglisteners.AutoOkClosingListener;
+import net.sourceforge.jnlp.config.DeploymentConfiguration;
+import net.sourceforge.jnlp.runtime.ManifestAttributesChecker;
+import net.sourceforge.jnlp.security.appletextendedsecurity.AppletSecurityLevel;
+import net.sourceforge.jnlp.tools.DeploymentPropertiesModifier;
+import org.junit.AfterClass;
+
+import org.junit.Assert;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+/**
+ *
+ * null, empty, none, wrong, correct jnlp x html different codebases.
+ *
+ * no dialogs should be appeared. Second testsuite with ALL dialogs (head only)
+ *
+ *
+ */
+public class CodebasesAttsNoDialogsTest3 extends BrowserTest {
+
+    private static final String appletCloseString = CodebasesAttsNoDialogsTest1.appletCloseString;
+    private static final String[] HTMLA = CodebasesAttsNoDialogsTest1.JAVAWS_HTML_ARRAY;
+    private static final List<String> HTMLL = CodebasesAttsNoDialogsTest1.JAVAWS_HTML_LIST;
+
+    private static final String JNLPAPP = CodebasesAttsNoDialogsTest1.JNLPAPP;
+    private static final String JNLPAPPLET = CodebasesAttsNoDialogsTest1.JNLPAPPLET;
+    private static final String HTML = CodebasesAttsNoDialogsTest1.HTML;
+    private static final String HTMLHREF = CodebasesAttsNoDialogsTest1.HTMLHREF;
+    private static final String CodebasesAtts = CodebasesAttsNoDialogsTest1.CodebasesAtts;
+
+    private static ServerLauncher secondValidServer;
+    private static ServerLauncher thirdValidServer;
+    private static DeploymentPropertiesModifier.MultipleDeploymentPropertiesModifier ensuredDP;
+
+    private static final String ABS = "ABS";
+    private static boolean WAS;
+    private static final boolean Force_Outputs = false;//set to true to see outputs of apps in big test
+
+    @BeforeClass
+    public static void initSecondaryServers() throws IOException {
+        secondValidServer = ServerAccess.getIndependentInstanceOnTmpDir();
+        thirdValidServer = ServerAccess.getIndependentInstanceOnTmpDir();
+    }
+
+    @AfterClass
+    public static void stopSecondaryServers() throws IOException {
+        secondValidServer.stop();
+        thirdValidServer.stop();
+    }
+
+    @BeforeClass
+    public static void setProperties() throws IOException {
+        ensuredDP = new DeploymentPropertiesModifier.MultipleDeploymentPropertiesModifier(
+                new AbstractMap.SimpleEntry(DeploymentConfiguration.KEY_ENABLE_MANIFEST_ATTRIBUTES_CHECK, ManifestAttributesChecker.MANIFEST_ATTRIBUTES_CHECK.NONE.name()),
+                new AbstractMap.SimpleEntry(DeploymentConfiguration.KEY_SECURITY_LEVEL, AppletSecurityLevel.ALLOW_UNSIGNED.name())
+        );
+        ensuredDP.setProperties();
+    }
+
+    @AfterClass
+    public static void resetProperties() throws IOException {
+        ensuredDP.restoreProperties();
+    }
+
+    @BeforeClass
+    public static void setOutput() throws IOException {
+        WAS = ServerAccess.LOGS_REPRINT;
+    }
+
+    @AfterClass
+    public static void resetOutput() throws IOException {
+        ServerAccess.LOGS_REPRINT = WAS;
+    }
+
+    /*
+     *Most fun. jnlp/applet is on page, jnlp on second and resource on third
+     * (those should fail)
+    
+     * As adition,  jnlphref have applet on one side, jnlp on second and this one have codebase on THIRD
+     * (agian representation of that  triple bug from CodebasesAttsNoDialogsTest1
+     */
+    //@Test test is disbaled. Is not testing much more then other CodebasesAttsNoDialogsTest1-3 tests and is fragile. Also its behaviour may change, if loading form non-codebase/docbase resources will be prohibited
+    //@TestInBrowsers(testIn = Browsers.one) hacked manually. We really do not wont to iterate this test browser-times
+    public void threeServers__okValues() throws IOException, Exception {
+        Browser localBrowser = BrowserFactory.getFactory().getRandom();
+        setBrowser(localBrowser.getID());
+        Browsers browserBackup = getBrowser();
+        try {
+            int totalCounter = 0;
+            //we know that "" and "   " behaves in same way, so let sminimalize this lopp
+            //abs get substituted by hardcoded path
+            String[] validValues = new String[]{ABS, null, "", "."};
+            for (int a = 0; a < validValues.length; a++) {
+                String codebaseIn = validValues[a];
+                for (int b = 0; b < validValues.length; b++) {
+                    String jnlpHrefIn = validValues[b];
+                    for (int c = 0; c < validValues.length; c++) {
+                        String jarIn = validValues[c];
+
+                        if (jarIn != null) {
+                            if (jarIn.trim().isEmpty()) {
+                                jarIn = null;
+                            }
+                        }
+                        if (jnlpHrefIn != null) {
+                            if (jnlpHrefIn.trim().isEmpty()) {
+                                jnlpHrefIn = null;
+                            }
+                        }
+
+                        //ServerLauncher[] servers = new ServerLauncher[]{ServerAccess.getIndependentInstance(), secondValidServer, thirdValidServer};
+                        //for (abs x abs or abs x relative or  realtive x relative) x (nonm jnlp href) are enough two servers
+                        //lets yousee tmp ones, as they have aligned id and BID
+                        ServerLauncher[] servers = new ServerLauncher[]{secondValidServer, thirdValidServer};
+                        for (int i = 0; i < servers.length; i++) {
+                            ServerLauncher usedServer = servers[i];
+                            String[] codebaseJnlpHrefJar = setByServer(usedServer, codebaseIn, jnlpHrefIn, jarIn);
+                            CodebasesAttsNoDialogsTest1.prepareSingle(codebaseJnlpHrefJar[0], codebaseJnlpHrefJar[1], codebaseJnlpHrefJar[2], ("" + (i + 1)).charAt(0), usedServer.getDir(), CodebasesAttsNoDialogsTest1.files);
+                        }
+                        for (int i = 0; i < servers.length; i++) {
+                            totalCounter++;
+                            ServerLauncher usedServer = servers[i];
+                            //server is caller, only because it knows javaws/browser location
+                            ServerAccess.LOGS_REPRINT = Force_Outputs;
+                            ServerAccess.logOutputReprint(totalCounter + ") i=" + i + ", c=" + c + ", b=" + b + ", a=" + a);
+                            ServerAccess.logOutputReprint(usedServer.getUrl().toExternalForm() + ": " + codebaseIn + ", " + jnlpHrefIn + ", " + jarIn);
+                            ServerAccess.logOutputReprint("jnlpapp " + JNLPAPP);
+                            ServerAccess.LOGS_REPRINT = false;
+                            ProcessResult pr1 = server.executeJavawsUponUrl(null, usedServer.getUrl(JNLPAPP), new AutoOkClosingListener(), new AutoErrorClosingListener());
+                            ServerAccess.LOGS_REPRINT = Force_Outputs;
+                            ServerAccess.logOutputReprint(pr1.stdout);
+                            ServerAccess.logOutputReprint(pr1.stderr);
+                            generalPass(pr1);
+                            ServerAccess.logOutputReprint("jnlpapplet " + JNLPAPPLET);
+                            ServerAccess.LOGS_REPRINT = false;
+                            ProcessResult pr2 = server.executeJavawsUponUrl(null, usedServer.getUrl(JNLPAPPLET), new AutoOkClosingListener(), new AutoErrorClosingListener());
+                            ServerAccess.LOGS_REPRINT = Force_Outputs;
+                            ServerAccess.logOutputReprint(pr2.stdout);
+                            ServerAccess.logOutputReprint(pr2.stderr);
+                            generalPass(pr2);
+                            ServerAccess.logOutputReprint("html " + HTML);
+                            ServerAccess.LOGS_REPRINT = false;
+                            ProcessResult pr3 = server.executeBrowser(null, usedServer.getUrl(HTML), new AutoOkClosingListener(), new AutoErrorClosingListener());
+                            ServerAccess.LOGS_REPRINT = Force_Outputs;
+                            ServerAccess.logOutputReprint(pr3.stdout);
+                            ServerAccess.logOutputReprint(pr3.stderr);
+                            generalPass(pr3);
+                            ServerAccess.logOutputReprint("javaws html " + HTML);
+                            ServerAccess.LOGS_REPRINT = false;
+                            ProcessResult pr33 = server.executeJavawsUponUrl(HTMLL, usedServer.getUrl(HTML), new AutoOkClosingListener(), new AutoErrorClosingListener());
+                            ServerAccess.LOGS_REPRINT = Force_Outputs;
+                            ServerAccess.logOutputReprint(pr33.stdout);
+                            ServerAccess.logOutputReprint(pr33.stderr);
+                            generalPass(pr33);
+                            ServerAccess.logOutputReprint("htmlhref " + HTMLHREF);
+                            ServerAccess.LOGS_REPRINT = false;
+                            ProcessResult pr4 = server.executeBrowser(null, usedServer.getUrl(HTMLHREF), new AutoOkClosingListener(), new AutoErrorClosingListener());
+                            ServerAccess.LOGS_REPRINT = Force_Outputs;
+                            ServerAccess.logOutputReprint(pr4.stdout);
+                            ServerAccess.logOutputReprint(pr4.stderr);
+                            generalPass(pr4);
+                            ServerAccess.logOutputReprint("javaws htmlhref " + HTMLHREF);
+                            ServerAccess.LOGS_REPRINT = false;
+                            ProcessResult pr44 = server.executeJavawsUponUrl(HTMLL, usedServer.getUrl(HTMLHREF), new AutoOkClosingListener(), new AutoErrorClosingListener());
+                            ServerAccess.LOGS_REPRINT = Force_Outputs;
+                            ServerAccess.logOutputReprint(pr44.stdout);
+                            ServerAccess.logOutputReprint(pr44.stderr);
+                            generalPass(pr44);
+                        }
+
+                    }
+                }
+            }
+        } finally {
+            setBrowser(browserBackup);
+        }
+    }
+
+    //@Test
+    @TestInBrowsers(testIn = Browsers.one)
+    //all three are valid, but on l one bug is supported now
+    @Bug(id = "http://mail.openjdk.java.net/pipermail/distro-pkg-dev/2016-January/034446.html")
+    //@Bug(id = "http://icedtea.classpath.org/hg/release/icedtea-web-1.6/rev/0d9faf51357d")
+    //@Bug(id = "http://icedtea.classpath.org/hg/icedtea-web/rev/22b7becd48a
+    public void threeServers_resourceIsElsewhere1_html() throws IOException, Exception {
+        CodebasesAttsNoDialogsTest1.prepareSingle((String) null, secondValidServer.getUrl().toExternalForm(), null, '1', ServerAccess.getInstance().getDir(), CodebasesAttsNoDialogsTest1.files);
+        CodebasesAttsNoDialogsTest1.prepareSingle((String) null, null, thirdValidServer.getUrl().toExternalForm(), '2', secondValidServer.getDir(), CodebasesAttsNoDialogsTest1.files);
+        CodebasesAttsNoDialogsTest1.prepareSingle((String) null, null, null, '3', thirdValidServer.getDir(), CodebasesAttsNoDialogsTest1.files);
+        ServerAccess.LOGS_REPRINT = Force_Outputs;
+        ServerAccess.logOutputReprint("htmlhref " + HTMLHREF);
+        ServerAccess.LOGS_REPRINT = false;
+        ProcessResult pr4 = server.executeBrowser(null, ServerAccess.getInstance().getUrl(HTMLHREF), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        ServerAccess.LOGS_REPRINT = Force_Outputs;
+        ServerAccess.logOutputReprint(pr4.stdout);
+        ServerAccess.logOutputReprint(pr4.stderr);
+        Assert.assertTrue(pr4.stdout.contains("id: 1")); //param is from applet page
+        Assert.assertTrue(pr4.stdout.contains("BID3"));
+        ServerAccess.LOGS_REPRINT = WAS;
+    }
+
+    @Test
+    @Bug(id = "PR2805")
+    @KnownToFail
+    //all three are valid, but on l one bug is supported now, but 2805 have priority
+    //@Bug(id = "http://mail.openjdk.java.net/pipermail/distro-pkg-dev/2016-January/034446.html")
+    //@Bug(id = "http://icedtea.classpath.org/hg/release/icedtea-web-1.6/rev/0d9faf51357d")
+    //@Bug(id = "http://icedtea.classpath.org/hg/icedtea-web/rev/22b7becd48a
+    public void threeServers_resourceIsElsewhere1_javawshtml() throws IOException, Exception {
+        CodebasesAttsNoDialogsTest1.prepareSingle((String) null, secondValidServer.getUrl().toExternalForm(), null, '1', ServerAccess.getInstance().getDir(), CodebasesAttsNoDialogsTest1.files);
+        CodebasesAttsNoDialogsTest1.prepareSingle((String) null, null, thirdValidServer.getUrl().toExternalForm(), '2', secondValidServer.getDir(), CodebasesAttsNoDialogsTest1.files);
+        CodebasesAttsNoDialogsTest1.prepareSingle((String) null, null, null, '3', thirdValidServer.getDir(), CodebasesAttsNoDialogsTest1.files);
+        ServerAccess.LOGS_REPRINT = Force_Outputs;
+        ServerAccess.logOutputReprint("javaws htmlhref " + HTMLHREF);
+        ServerAccess.LOGS_REPRINT = false;
+        ProcessResult pr44 = server.executeJavawsUponUrl(HTMLL, ServerAccess.getInstance().getUrl(HTMLHREF), new AutoOkClosingListener(), new AutoErrorClosingListener());
+        ServerAccess.LOGS_REPRINT = Force_Outputs;
+        ServerAccess.logOutputReprint(pr44.stdout);
+        ServerAccess.logOutputReprint(pr44.stderr);
+        //Assert.assertTrue(pr44.stdout.contains("id: 2")); //param is from jnlphreffed file. This may be considered bug
+        Assert.assertTrue(pr44.stdout.contains("BID3"));
+        Assert.assertTrue(pr44.stdout.contains("id: 1")); //should be same as threeServers_resourceIsElsewhere1_html
+        ServerAccess.LOGS_REPRINT = WAS;
+    }
+
+    private String[] setByServer(ServerLauncher instance, String codebaseIn, String jnlpHrefIn, String jarIn) throws MalformedURLException {
+        String[] codebaseJnlpHrefJar = new String[]{codebaseIn, jnlpHrefIn, jarIn};
+
+        if (ABS.equals(codebaseIn)) {
+            codebaseJnlpHrefJar[0] = instance.getUrl().toExternalForm();
+        }
+        if (ABS.equals(jnlpHrefIn)) {
+            codebaseJnlpHrefJar[1] = instance.getUrl().toExternalForm();
+        }
+        if (ABS.equals(jarIn)) {
+            codebaseJnlpHrefJar[2] = instance.getUrl().toExternalForm();
+        }
+        return codebaseJnlpHrefJar;
+    }
+
+    private void generalPass(ProcessResult pr1) {
+        generalPass(pr1.stdout);
+    }
+
+    private void generalPass(String s) {
+        Assert.assertTrue(s.contains("id: "));
+        Assert.assertTrue(s.contains("BID"));
+    }
+
+}
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/simple/SingleInstanceServiceTest/testcases/SingleInstanceTest.java
--- a/tests/reproducers/simple/SingleInstanceServiceTest/testcases/SingleInstanceTest.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/tests/reproducers/simple/SingleInstanceServiceTest/testcases/SingleInstanceTest.java	Tue Jan 26 15:18:30 2016 +0100
@@ -168,6 +168,13 @@
     @NeedsDisplay
     @TestInBrowsers(testIn = Browsers.one)
     public void htmlpAppletXhtmlpApplet() throws Exception {
+        //others really do
+        if ((server.getBrowserLocation().endsWith("midori") || server.getBrowserLocation().endsWith("epiphany"))) {
+            return;
+        }
+        if (server.getBrowserLocation().endsWith(ServerAccess.UNSET_BROWSER)) {
+            return;
+        }
         ProcessResult[] results = executeSingleInstanceCheck(htmlpApplet, htmlpApplet);
         String id = "htmlpAppletXhtmlpApplet";
         evaluateFirstInstance(results[0], id);
@@ -180,6 +187,13 @@
     @NeedsDisplay
     @TestInBrowsers(testIn = Browsers.one)
     public void htmlJnlpHrefAppletXhtmlJnlpHrefApplet() throws Exception {
+        //others really do
+        if ((server.getBrowserLocation().endsWith("midori") || server.getBrowserLocation().endsWith("epiphany"))) {
+            return;
+        }
+        if (server.getBrowserLocation().endsWith(ServerAccess.UNSET_BROWSER)) {
+            return;
+        }
         ProcessResult[] results = executeSingleInstanceCheck(htmlJnlpHrefApplet, htmlJnlpHrefApplet);
         String id = "htmlJnlpHrefAppletXhtmlJnlpHrefApplet";
         evaluateFirstInstance(results[0], id);
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/simple/simpletest1/testcases/SimpleTest1CountRequests.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/reproducers/simple/simpletest1/testcases/SimpleTest1CountRequests.java	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,109 @@
+/* SimpleTest1Test.java
+ Copyright (C) 2011 Red Hat, Inc.
+
+ This file is part of IcedTea.
+
+ IcedTea is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, version 2.
+
+ IcedTea is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with IcedTea; see the file COPYING.  If not, write to
+ the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301 USA.
+
+ Linking this library statically or dynamically with other modules is
+ making a combined work based on this library.  Thus, the terms and
+ conditions of the GNU General Public License cover the whole
+ combination.
+
+ As a special exception, the copyright holders of this library give you
+ permission to link this library with independent modules to produce an
+ executable, regardless of the license terms of these independent
+ modules, and to copy and distribute the resulting executable under
+ terms of your choice, provided that you also meet, for each linked
+ independent module, the terms and conditions of the license of that
+ module.  An independent module is a module which is not derived from
+ or based on this library.  If you modify this library, you may extend
+ this exception to your version of the library, but you are not
+ obligated to do so.  If you do not wish to do so, delete this
+ exception statement from your version.
+ */
+
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import net.sourceforge.jnlp.ProcessResult;
+import net.sourceforge.jnlp.ServerAccess;
+import net.sourceforge.jnlp.ServerLauncher;
+import net.sourceforge.jnlp.annotations.Bug;
+import org.junit.AfterClass;
+import org.junit.Assert;
+import org.junit.BeforeClass;
+
+import org.junit.Test;
+
+@Bug(id = "PR2591")
+public class SimpleTest1CountRequests {
+
+    private static final ServerAccess server = new ServerAccess();
+    private static ServerLauncher server0;
+    private static final Map<String, Map<String, Integer>> counter = new HashMap<>();
+    private static final List<String> hv = Arrays.asList(new String[]{ServerAccess.VERBOSE_OPTION, ServerAccess.HEADLES_OPTION});
+
+    @BeforeClass
+    public static void createCountingServer() {
+        server0 = ServerAccess.getIndependentInstance();
+        server0.setRequestsCounter(counter);
+    }
+
+    @AfterClass
+    public static void stopCountingServer() {
+        server0.stop();
+    }
+
+    @Bug(id = "PR2591")
+    @Test
+    public void testSimpletest1EachResourceOnePerRun() throws Exception {
+        server0.setSupportingHeadRequest(true);
+        counter.clear();
+        ProcessResult pr = ServerAccess.executeProcessUponURL(server.getJavawsLocation(),
+                hv,
+                server0.getUrl("/simpletest1.jnlp"),
+                null,
+                null
+        );
+        SimpleTest1Test.checkLaunched(pr);
+        Assert.assertTrue(counter.get("./simpletest1.jnlp").get("GET").equals(1)); //2 without bugfix
+        Assert.assertTrue(counter.get("./simpletest1.jnlp").get("HEAD").equals(1));
+        Assert.assertTrue(counter.get("./simpletest1.jar").get("GET").equals(1));//2 without bugfix
+        Assert.assertTrue(counter.get("./simpletest1.jar").get("HEAD").equals(1));
+
+    }
+
+    @Bug(id = "PR2591")
+    @Test
+    public void testSimpletest1EachResourceOnePerRunHeadsOff() throws Exception {
+        server0.setSupportingHeadRequest(false);
+        counter.clear();
+        ProcessResult pr = ServerAccess.executeProcessUponURL(server.getJavawsLocation(),
+                hv,
+                server0.getUrl("/simpletest1.jnlp"),
+                null,
+                null
+        );
+        SimpleTest1Test.checkLaunched(pr);
+        Assert.assertTrue(counter.get("./simpletest1.jnlp").get("GET").equals(2)); //3 without bugfix
+        Assert.assertTrue(counter.get("./simpletest1.jnlp").get("HEAD") == null);
+        Assert.assertTrue(counter.get("./simpletest1.jar").get("GET").equals(2));//3 without bugfix
+        Assert.assertTrue(counter.get("./simpletest1.jar").get("HEAD") == (null));
+
+    }
+
+}
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/simple/simpletest1/testcases/SimpleTest1Test.java
--- a/tests/reproducers/simple/simpletest1/testcases/SimpleTest1Test.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/tests/reproducers/simple/simpletest1/testcases/SimpleTest1Test.java	Tue Jan 26 15:18:30 2016 +0100
@@ -1,38 +1,38 @@
 /* SimpleTest1Test.java
-Copyright (C) 2011 Red Hat, Inc.
+ Copyright (C) 2011 Red Hat, Inc.
 
-This file is part of IcedTea.
+ This file is part of IcedTea.
 
-IcedTea is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License as published by
-the Free Software Foundation, version 2.
+ IcedTea is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, version 2.
 
-IcedTea is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
+ IcedTea is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with IcedTea; see the file COPYING.  If not, write to
-the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-02110-1301 USA.
+ You should have received a copy of the GNU General Public License
+ along with IcedTea; see the file COPYING.  If not, write to
+ the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301 USA.
 
-Linking this library statically or dynamically with other modules is
-making a combined work based on this library.  Thus, the terms and
-conditions of the GNU General Public License cover the whole
-combination.
+ Linking this library statically or dynamically with other modules is
+ making a combined work based on this library.  Thus, the terms and
+ conditions of the GNU General Public License cover the whole
+ combination.
 
-As a special exception, the copyright holders of this library give you
-permission to link this library with independent modules to produce an
-executable, regardless of the license terms of these independent
-modules, and to copy and distribute the resulting executable under
-terms of your choice, provided that you also meet, for each linked
-independent module, the terms and conditions of the license of that
-module.  An independent module is a module which is not derived from
-or based on this library.  If you modify this library, you may extend
-this exception to your version of the library, but you are not
-obligated to do so.  If you do not wish to do so, delete this
-exception statement from your version.
+ As a special exception, the copyright holders of this library give you
+ permission to link this library with independent modules to produce an
+ executable, regardless of the license terms of these independent
+ modules, and to copy and distribute the resulting executable under
+ terms of your choice, provided that you also meet, for each linked
+ independent module, the terms and conditions of the license of that
+ module.  An independent module is a module which is not derived from
+ or based on this library.  If you modify this library, you may extend
+ this exception to your version of the library, but you are not
+ obligated to do so.  If you do not wish to do so, delete this
+ exception statement from your version.
  */
 
 import java.io.File;
@@ -50,14 +50,18 @@
 
 public class SimpleTest1Test {
 
-    private static ServerAccess server = new ServerAccess();
+    private static final ServerAccess server = new ServerAccess();
     private static final List<String> strict = Arrays.asList(new String[]{"-strict", ServerAccess.VERBOSE_OPTION});
 
-    private void checkLaunched(ProcessResult pr) {
+    static void checkLaunched(ProcessResult pr) {
         checkLaunched(pr, false);
     }
 
-    private void checkLaunched(ProcessResult pr, boolean negate) {
+    static void checkLaunched(ProcessResult pr, boolean negate) {
+        checkLaunched(pr, negate, true);
+    }
+
+    static void checkLaunched(ProcessResult pr, boolean negate, boolean checkTermination) {
         String s = "Good simple javaws exapmle";
         if (negate) {
             Assert.assertFalse("testSimpletest1lunchOk stdout should NOT contains " + s + " bud did", pr.stdout.contains(s));
@@ -71,8 +75,14 @@
             //disabled, unnecessary exceptions may occure
             //Assert.assertFalse("testSimpletest1lunchOk stderr should not contains " + ss + " but did", pr.stderr.contains(ss));
         }
-        Assert.assertFalse(pr.wasTerminated);
-        Assert.assertEquals((Integer) 0, pr.returnValue);
+        if (checkTermination) {
+            Assert.assertFalse(pr.wasTerminated);
+            if (negate) {
+                Assert.assertEquals((Integer) 1, pr.returnValue);
+            } else {
+                Assert.assertEquals((Integer) 0, pr.returnValue);
+            }
+       }
     }
 
     @Test
diff -r ba6519dd5e79 -r 263e152a6084 tests/reproducers/simple/simpletest1/testcases/SimpleTestDefaultRedirects.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tests/reproducers/simple/simpletest1/testcases/SimpleTestDefaultRedirects.java	Tue Jan 26 15:18:30 2016 +0100
@@ -0,0 +1,290 @@
+/* SimpleTest1Test.java
+ Copyright (C) 2011 Red Hat, Inc.
+
+ This file is part of IcedTea.
+
+ IcedTea is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, version 2.
+
+ IcedTea is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with IcedTea; see the file COPYING.  If not, write to
+ the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301 USA.
+
+ Linking this library statically or dynamically with other modules is
+ making a combined work based on this library.  Thus, the terms and
+ conditions of the GNU General Public License cover the whole
+ combination.
+
+ As a special exception, the copyright holders of this library give you
+ permission to link this library with independent modules to produce an
+ executable, regardless of the license terms of these independent
+ modules, and to copy and distribute the resulting executable under
+ terms of your choice, provided that you also meet, for each linked
+ independent module, the terms and conditions of the license of that
+ module.  An independent module is a module which is not derived from
+ or based on this library.  If you modify this library, you may extend
+ this exception to your version of the library, but you are not
+ obligated to do so.  If you do not wish to do so, delete this
+ exception statement from your version.
+ */
+
+import java.net.MalformedURLException;
+import java.util.Arrays;
+import java.util.List;
+import net.sourceforge.jnlp.OptionsDefinitions;
+import net.sourceforge.jnlp.ProcessResult;
+import net.sourceforge.jnlp.ServerAccess;
+import net.sourceforge.jnlp.ServerLauncher;
+import org.junit.Assert;
+
+import org.junit.Test;
+
+public class SimpleTestDefaultRedirects {
+
+    private static final ServerAccess server = new ServerAccess();
+
+    private static final String D = "-J-Dhttp.maxRedirects=20"; //default - https://docs.oracle.com/javase/7/docs/api/java/net/doc-files/net-properties.html ,  but...
+    //unluckily, setting http.maxRedirects to eg 1 do not have testing benefit
+    //as httpconnection then jsut throws exception instead of returning header to app's investigations
+    //I doubt it is worthy to struggle with setInstanceFollowRedirects in production code
+    
+    private static final List<String> hr = Arrays.asList(new String[]{D, ServerAccess.HEADLES_OPTION, OptionsDefinitions.OPTIONS.REDIRECT.option});
+    private static final List<String> hrv = Arrays.asList(new String[]{D, ServerAccess.VERBOSE_OPTION, ServerAccess.HEADLES_OPTION, OptionsDefinitions.OPTIONS.REDIRECT.option});
+    private static final List<String> hv = Arrays.asList(new String[]{D, ServerAccess.VERBOSE_OPTION, ServerAccess.HEADLES_OPTION});
+
+/* creates redirecting instances so oe can debug itw against it */
+//    public static void main(String[] args) throws InterruptedException, MalformedURLException {
+//        ServerLauncher[] servers = new ServerLauncher[3];
+//
+//        ServerLauncher server0 = ServerAccess.getIndependentInstance();
+//        server0.setRedirect(ServerAccess.getInstance()); //redirecting to normal server singleton
+//        server0.setRedirectCode(301);
+//        servers[0] = server0;
+//
+//        ServerLauncher server1 = ServerAccess.getIndependentInstance();
+//        server1.setRedirect(server0);
+//        server1.setRedirectCode(301);
+//        servers[1] = server1;
+//
+//        ServerLauncher server2 = ServerAccess.getIndependentInstance();
+//        server2.setRedirect(server1);
+//        server2.setRedirectCode(301);
+//        servers[2] = server2;
+//
+//        System.out.println(server0);
+//        System.out.println(server1);
+//        System.out.println(server2);
+//
+//        try {
+//            System.out.println(server0.getUrl("/" + "simpletest1.jnlp"));
+//            System.out.println(server1.getUrl("/" + "simpletest1.jnlp"));
+//            System.out.println(server2.getUrl("/" + "simpletest1.jnlp"));
+//            while (true) {
+//                Thread.sleep(100);
+//            }
+//        } finally {
+//            for (ServerLauncher server : servers) {
+//                server.stop();
+//            }
+//        }
+//    }
+
+    public void testbody(List<String> args, boolean pass, int... redirectCodes) throws Exception {
+        testbody(args, pass, -1, redirectCodes);
+    }
+
+    public void testbody(List<String> args, boolean pass, int breakChain, int... redirectCodes) throws Exception {
+        if (redirectCodes.length < 1) {
+            throw new RuntimeException("At least one redrection server pelase");
+        }
+        ServerLauncher[] servers = new ServerLauncher[redirectCodes.length];
+
+        ServerLauncher server0 = ServerAccess.getIndependentInstance();
+        server0.setRedirect(ServerAccess.getInstance()); //redirecting to normal server singleton
+        server0.setRedirectCode(redirectCodes[0]); //redirecting by first code
+        servers[0] = server0;
+
+        //create redirect chain
+        for (int i = 1; i < redirectCodes.length; i++) {
+            ServerLauncher serverI = ServerAccess.getIndependentInstance();
+            serverI.setRedirect(servers[i - 1]); //redirecting to pevious in chain
+            serverI.setRedirectCode(redirectCodes[i]); //by  given code
+            servers[i] = serverI;
+
+        }
+        testbody(args, pass, breakChain, servers);
+    }
+
+    public void testbody(List<String> args, boolean pass, int breakChain, ServerLauncher[] servers) throws Exception {
+        if (breakChain >= 0) {
+            servers[breakChain].setRedirect(null);
+            servers[breakChain].stop();
+        }
+        ServerLauncher server3012378 = servers[servers.length - 1];
+        try {
+            //now connect to last in chain and we should always get reposnse from ServerAccess.getInstance()
+            ProcessResult pr = ServerAccess.executeProcessUponURL(server.getJavawsLocation(),
+                    args,
+                    server3012378.getUrl("/" + "simpletest1.jnlp"),
+                    null,
+                    null
+            );
+            SimpleTest1Test.checkLaunched(pr, !pass, false);
+            if (pass) {
+                Assert.assertTrue(0 == pr.returnValue);
+            } else {
+                //1.6 have wrong handling of pr.return value
+                //Assert.assertFalse(0 == pr.returnValue);
+            }
+        } finally {
+            for (int i = 0; i < servers.length; i++) {
+                if (i != breakChain) {
+                    ServerLauncher serverI = servers[i];
+                    try {
+                        serverI.setRedirect(null);
+                        serverI.stop();
+                    } catch (Exception ex) {
+                        ServerAccess.logException(ex);
+                    }
+                }
+            }
+        }
+    }
+
+    // note, tonly 308 needs help form ITW,others are redirected autmatically in http connection
+    // https://docs.oracle.com/javase/7/docs/api/java/net/HttpURLConnection.html#setInstanceFollowRedirects%28boolean%29
+    public void testbody308(boolean pass, int... redirectCodes) throws Exception {
+        if (pass) {
+            testbody(hr, pass, redirectCodes);
+        } else {
+            testbody(hv, pass, redirectCodes);
+        }
+    }
+
+    public void testbodyOthers(boolean pass, int... redirectCodes) throws Exception {
+        if (pass) {
+            testbody(hr, true, redirectCodes);
+        } else {
+            testbody(hv, true, redirectCodes);
+        }
+    }
+
+    //some chains tests
+    @Test
+    public void testSimpletest1RedirectChain1AllowedOk() throws Exception {
+        testbodyOthers(true, 301, 302, 303, 307);
+    }
+
+    @Test
+    public void testSimpletest1RedirectChain1NotAllowedOk() throws Exception {
+        testbodyOthers(false, 301, 302, 303, 307);
+    }
+
+    @Test
+    public void testSimpletest1RedirectChain2AllowedOk() throws Exception {
+        testbody308(true, 301, 308, 302, 303, 307);
+    }
+
+    @Test
+    public void testSimpletest1RedirectChain2NotAllowedOk() throws Exception {
+        server.executeJavawsClearCache();
+        testbody308(false, 301, 308, 302, 303, 307);
+    }
+
+    @Test
+    public void testSimpletest1RedirectChain3AllowedBroken() throws Exception {
+        server.executeJavawsClearCache();
+        testbody(hrv, false, 1, new int[]{301, 302, 302, 303, 307});
+    }
+
+    @Test
+    public void testSimpletest1RedirectChain3NotAllowedBroken() throws Exception {
+        server.executeJavawsClearCache();
+        testbody(hv, false, 1, new int[]{301, 302, 302, 303, 307});
+    }
+
+    @Test
+    public void testSimpletest1RedirectChain3AlowedCycle() throws Exception {
+        server.executeJavawsClearCache();
+        ServerLauncher[] servers = new ServerLauncher[3];
+
+        ServerLauncher server0 = ServerAccess.getIndependentInstance();
+        server0.setRedirect(ServerAccess.getInstance()); //redirecting to normal server singleton
+        server0.setRedirectCode(301);
+        servers[0] = server0;
+
+        ServerLauncher server1 = ServerAccess.getIndependentInstance();
+        server1.setRedirectCode(301);
+        servers[1] = server1;
+
+        ServerLauncher server2 = ServerAccess.getIndependentInstance();
+        server2.setRedirectCode(301);
+        servers[2] = server2;
+
+        server1.setRedirect(server2);
+        server2.setRedirect(server1);
+        testbody(hrv, false, -1, servers);
+    }
+
+    //end chains
+    // basic tests
+    @Test
+    public void testSimpletest1Redirect301AllowedOk() throws Exception {
+        testbodyOthers(true, 301);
+    }
+
+    @Test
+    public void testSimpletest1Redirect301NotAllowedOk() throws Exception {
+        testbodyOthers(false, 301);
+    }
+
+    @Test
+    public void testSimpletest1Redirect302AllowedOk() throws Exception {
+        testbodyOthers(true, 302);
+    }
+
+    @Test
+    public void testSimpletest1Redirect302NotAllowedOk() throws Exception {
+        testbodyOthers(false, 302);
+    }
+
+    @Test
+    public void testSimpletest1Redirect303AllowedOk() throws Exception {
+        testbodyOthers(true, 303);
+    }
+
+    @Test
+    public void testSimpletest1Redirect331NotAllowedOk() throws Exception {
+        testbodyOthers(false, 303);
+    }
+
+    @Test
+    public void testSimpletest1Redirect307AllowedOk() throws Exception {
+        testbodyOthers(true, 307);
+    }
+
+    @Test
+    public void testSimpletest1Redirect307NotAllowedOk() throws Exception {
+        testbodyOthers(false, 307);
+    }
+
+    @Test
+    public void testSimpletest1Redirect308AllowedOk() throws Exception {
+        testbody308(true, 308);
+    }
+
+    @Test
+    public void testSimpletest1Redirect308NotAllowedOk() throws Exception {
+        server.executeJavawsClearCache();
+        testbody308(false, 308);
+    }
+    // end basic tests
+
+}
diff -r ba6519dd5e79 -r 263e152a6084 tests/test-extensions/net/sourceforge/jnlp/ServerAccess.java
--- a/tests/test-extensions/net/sourceforge/jnlp/ServerAccess.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/tests/test-extensions/net/sourceforge/jnlp/ServerAccess.java	Tue Jan 26 15:18:30 2016 +0100
@@ -228,7 +228,20 @@
     public static ServerLauncher getIndependentInstance(String dir, int port) {
         return getIndependentInstance(dir, port, true);
     }
-    public static ServerLauncher getIndependentInstance(String dir, int port,boolean daemon) {
+
+    public static ServerLauncher getIndependentInstance(String dir) throws IOException {
+        return getIndependentInstance(dir, findFreePort(), true);
+    }
+
+    public static ServerLauncher getIndependentInstanceOnTmpDir() throws IOException {
+        File f = File.createTempFile("itwReproducers_", "_anotherDeployDir");
+        f.delete();
+        f.mkdir();
+        f.deleteOnExit();
+        return getIndependentInstance(f.getAbsolutePath(), findFreePort(), true);
+    }
+
+    public static ServerLauncher getIndependentInstance(String dir, int port, boolean daemon) {
 
 
         if (dir == null || dir.trim().length() == 0 || !new File(dir).exists() || !new File(dir).isDirectory()) {
@@ -647,6 +660,12 @@
         rpw.setReactingProcess(getCurrentBrowser());//current browser may be null, but it does not metter
         return rpw.execute();
     }
+    
+    public ProcessResult executeBrowser(List<String> otherargs, URL url, ContentReaderListener stdoutl, ContentReaderListener stderrl) throws Exception {
+        ProcessWrapper rpw = new ProcessWrapper(getBrowserLocation(), otherargs, url, stdoutl, stderrl, null);
+        rpw.setReactingProcess(getCurrentBrowser());//current browser may be null, but it does not metter
+        return rpw.execute();
+    }
 
     public ProcessResult executeBrowser(List<String> otherargs,    String resource, List<ContentReaderListener> stdoutl, List<ContentReaderListener> stderrl) throws Exception {
         ProcessWrapper rpw = new ProcessWrapper(getBrowserLocation(), otherargs, getUrlUponThisInstance(resource), stdoutl, stderrl, null);
diff -r ba6519dd5e79 -r 263e152a6084 tests/test-extensions/net/sourceforge/jnlp/ServerLauncher.java
--- a/tests/test-extensions/net/sourceforge/jnlp/ServerLauncher.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/tests/test-extensions/net/sourceforge/jnlp/ServerLauncher.java	Tue Jan 26 15:18:30 2016 +0100
@@ -1,46 +1,46 @@
 /* ServerLauncher.java
-Copyright (C) 2011,2012 Red Hat, Inc.
+ Copyright (C) 2011,2012 Red Hat, Inc.
 
-This file is part of IcedTea.
+ This file is part of IcedTea.
 
-IcedTea is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License as published by
-the Free Software Foundation, version 2.
+ IcedTea is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, version 2.
 
-IcedTea is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
+ IcedTea is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with IcedTea; see the file COPYING.  If not, write to
-the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-02110-1301 USA.
+ You should have received a copy of the GNU General Public License
+ along with IcedTea; see the file COPYING.  If not, write to
+ the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301 USA.
 
-Linking this library statically or dynamically with other modules is
-making a combined work based on this library.  Thus, the terms and
-conditions of the GNU General Public License cover the whole
-combination.
+ Linking this library statically or dynamically with other modules is
+ making a combined work based on this library.  Thus, the terms and
+ conditions of the GNU General Public License cover the whole
+ combination.
 
-As a special exception, the copyright holders of this library give you
-permission to link this library with independent modules to produce an
-executable, regardless of the license terms of these independent
-modules, and to copy and distribute the resulting executable under
-terms of your choice, provided that you also meet, for each linked
-independent module, the terms and conditions of the license of that
-module.  An independent module is a module which is not derived from
-or based on this library.  If you modify this library, you may extend
-this exception to your version of the library, but you are not
-obligated to do so.  If you do not wish to do so, delete this
-exception statement from your version.
+ As a special exception, the copyright holders of this library give you
+ permission to link this library with independent modules to produce an
+ executable, regardless of the license terms of these independent
+ modules, and to copy and distribute the resulting executable under
+ terms of your choice, provided that you also meet, for each linked
+ independent module, the terms and conditions of the license of that
+ module.  An independent module is a module which is not derived from
+ or based on this library.  If you modify this library, you may extend
+ this exception to your version of the library, but you are not
+ obligated to do so.  If you do not wish to do so, delete this
+ exception statement from your version.
  */
-
 package net.sourceforge.jnlp;
 
 import java.io.File;
 import java.net.MalformedURLException;
 import java.net.ServerSocket;
 import java.net.URL;
+import java.util.Map;
 
 /**
  * wrapper around tiny http server to separate lunch configurations and servers.
@@ -49,8 +49,8 @@
 public class ServerLauncher implements Runnable {
 
     /**
-     * default url name part.
-     * This can be changed in runtime, but will affect all following tasks upon those server
+     * default url name part. This can be changed in runtime, but will affect
+     * all following tasks upon those server
      */
     private String serverName = ServerAccess.DEFAULT_LOCALHOST_NAME;
     private boolean running;
@@ -108,12 +108,42 @@
         this(8181, new File(System.getProperty("user.dir")));
     }
 
+    /**
+     * When redirect is set, the requests to this server will just redirect to
+     * the underlying ServerLauncher
+     */
+    private ServerLauncher redirect = null;
+    /**
+     * one of: 301, 302,303, 307, 308,
+     */
+    private int redirectCode = 302;
+
+    public void setRedirect(ServerLauncher redirect) {
+        this.redirect = redirect;
+
+    }
+
+    public void setRedirectCode(int redirectPort) {
+        this.redirectCode = redirectPort;
+    }
+
+    //resoource -> request -> number of requests on of this rsource on this server
+    // eg   simpletest1.jnlp -> GET -> 3
+    private Map<String, Map<String, Integer>> requestsCounter;
+
+    public void setRequestsCounter(Map<String, Map<String, Integer>> requestsCounter) {
+        this.requestsCounter = requestsCounter;
+    }
+
     public void run() {
         running = true;
         try {
             serverSocket = new ServerSocket(port);
             while (running) {
                 TinyHttpdImpl server = new TinyHttpdImpl(serverSocket.accept(), dir, false);
+                server.setRedirect(redirect);
+                server.setRedirectCode(redirectCode);
+                server.setRequestsCounter(requestsCounter);
                 server.setSupportingHeadRequest(isSupportingHeadRequest());
                 server.start();
             }
diff -r ba6519dd5e79 -r 263e152a6084 tests/test-extensions/net/sourceforge/jnlp/TinyHttpdImpl.java
--- a/tests/test-extensions/net/sourceforge/jnlp/TinyHttpdImpl.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/tests/test-extensions/net/sourceforge/jnlp/TinyHttpdImpl.java	Tue Jan 26 15:18:30 2016 +0100
@@ -1,40 +1,39 @@
 /* TinyHttpdImpl.java
-Copyright (C) 2011,2012 Red Hat, Inc.
+ Copyright (C) 2011,2012 Red Hat, Inc.
 
-This file is part of IcedTea.
+ This file is part of IcedTea.
 
-IcedTea is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License as published by
-the Free Software Foundation, version 2.
+ IcedTea is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, version 2.
 
-IcedTea is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
+ IcedTea is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with IcedTea; see the file COPYING.  If not, write to
-the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-02110-1301 USA.
+ You should have received a copy of the GNU General Public License
+ along with IcedTea; see the file COPYING.  If not, write to
+ the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301 USA.
 
-Linking this library statically or dynamically with other modules is
-making a combined work based on this library.  Thus, the terms and
-conditions of the GNU General Public License cover the whole
-combination.
+ Linking this library statically or dynamically with other modules is
+ making a combined work based on this library.  Thus, the terms and
+ conditions of the GNU General Public License cover the whole
+ combination.
 
-As a special exception, the copyright holders of this library give you
-permission to link this library with independent modules to produce an
-executable, regardless of the license terms of these independent
-modules, and to copy and distribute the resulting executable under
-terms of your choice, provided that you also meet, for each linked
-independent module, the terms and conditions of the license of that
-module.  An independent module is a module which is not derived from
-or based on this library.  If you modify this library, you may extend
-this exception to your version of the library, but you are not
-obligated to do so.  If you do not wish to do so, delete this
-exception statement from your version.
+ As a special exception, the copyright holders of this library give you
+ permission to link this library with independent modules to produce an
+ executable, regardless of the license terms of these independent
+ modules, and to copy and distribute the resulting executable under
+ terms of your choice, provided that you also meet, for each linked
+ independent module, the terms and conditions of the license of that
+ module.  An independent module is a module which is not derived from
+ or based on this library.  If you modify this library, you may extend
+ this exception to your version of the library, but you are not
+ obligated to do so.  If you do not wish to do so, delete this
+ exception statement from your version.
  */
-
 package net.sourceforge.jnlp;
 
 import java.io.BufferedReader;
@@ -47,19 +46,20 @@
 import java.net.Socket;
 import java.net.SocketException;
 import java.net.URLDecoder;
-import java.security.cert.CRL;
 import java.util.Date;
+import java.util.HashMap;
+import java.util.Map;
 import java.util.StringTokenizer;
 
 import net.sourceforge.jnlp.cache.ResourceTracker;
 
 /**
- * based on http://www.mcwalter.org/technology/java/httpd/tiny/index.html
- * Very small implementation of http return headers for our served resources
- * Originally Licenced under GPLv2.0 
+ * based on http://www.mcwalter.org/technology/java/httpd/tiny/index.html Very
+ * small implementation of http return headers for our served resources
+ * Originally Licenced under GPLv2.0
  *
- * When resource starts with XslowX prefix, then resouce (without XslowX)
- * is returned, but its delivery is delayed
+ * When resource starts with XslowX prefix, then resouce (without XslowX) is
+ * returned, but its delivery is delayed
  */
 public class TinyHttpdImpl extends Thread {
 
@@ -143,52 +143,77 @@
                     String filePath = t.nextToken();
                     boolean slowSend = filePath.startsWith(XSX);
 
-                    if (slowSend) {
-                        filePath = filePath.replace(XSX, "/");
+                    if (requestsCounter != null) {
+                        String resource = filePath.replace(XSX, "/");
+                        resource = urlToFilePath(resource);
+                        Map<String, Integer> reosurceRecord = requestsCounter.get(resource);
+                        if (reosurceRecord == null) {
+                            reosurceRecord = new HashMap<>();
+                            requestsCounter.put(resource, reosurceRecord);
+                        }
+                        Integer i = reosurceRecord.get(request);
+                        if (i == null) {
+                            i = 0;
+                        }
+                        i++;
+                        reosurceRecord.put(request, i);
                     }
 
-                    ServerAccess.logOutputReprint("Getting- " + request + ": " + filePath);
-                    filePath = urlToFilePath(filePath);
+                    if (redirect != null) {
+                        String where = redirect.getUrl(filePath).toExternalForm();
+                        ServerAccess.logOutputReprint("Redirecting " + request + "as " + redirectCode + " to " + where);
+                        writer.writeBytes("HTTP/1.0 " + redirectCode + " Moved" + CRLF);
+                        writer.writeBytes("Location: " + where + CRLF);
+                        writer.writeBytes(CRLF);
+                    } else {
 
-                    File resource = new File(this.testDir, filePath);
+                        if (slowSend) {
+                            filePath = filePath.replace(XSX, "/");
+                        }
 
-                    if (!(resource.isFile() && resource.canRead())) {
-                        ServerAccess.logOutputReprint("Could not open file " + filePath);
-                        writer.writeBytes(HTTP_NOT_FOUND);
-                        continue;
-                    }
-                    ServerAccess.logOutputReprint("Serving- " + request + ": " + filePath);
+                        ServerAccess.logOutputReprint("Getting- " + request + ": " + filePath);
+                        filePath = urlToFilePath(filePath);
 
-                    int resourceLength = (int) resource.length();
-                    byte[] buff = new byte[resourceLength];
-                    FileInputStream fis = new FileInputStream(resource);
-                    fis.read(buff);
-                    fis.close();
+                        File resource = new File(this.testDir, filePath);
 
-                    String contentType = "Content-Type: ";
-                    if (filePath.toLowerCase().endsWith(".jnlp")) {
-                        contentType += "application/x-java-jnlp-file";
-                    } else if (filePath.toLowerCase().endsWith(".jar")) {
-                        contentType += "application/x-jar";
-                    } else {
-                        contentType += "text/html";
-                    }
-                    String lastModified = "";
-                    if (supportLastModified) {
-                        lastModified = "Last-Modified: " + new Date(resource.lastModified()) + CRLF;
-                    }
-                    writer.writeBytes(HTTP_OK + "Content-Length:" + resourceLength + CRLF + lastModified + contentType + CRLF + CRLF);
+                        if (!(resource.isFile() && resource.canRead())) {
+                            ServerAccess.logOutputReprint("Could not open file " + filePath);
+                            writer.writeBytes(HTTP_NOT_FOUND);
+                            continue;
+                        }
+                        ServerAccess.logOutputReprint("Serving- " + request + ": " + filePath);
 
-                    if (isGetRequest) {
-                        if (slowSend) {
-                            byte[][] bb = splitArray(buff, 10);
-                            for (int j = 0; j < bb.length; j++) {
-                                Thread.sleep(2000);
-                                byte[] bs = bb[j];
-                                writer.write(bs, 0, bs.length);
+                        int resourceLength = (int) resource.length();
+                        byte[] buff = new byte[resourceLength];
+                        FileInputStream fis = new FileInputStream(resource);
+                        fis.read(buff);
+                        fis.close();
+
+                        String contentType = "Content-Type: ";
+                        if (filePath.toLowerCase().endsWith(".jnlp")) {
+                            contentType += "application/x-java-jnlp-file";
+                        } else if (filePath.toLowerCase().endsWith(".jar")) {
+                            contentType += "application/x-jar";
+                        } else {
+                            contentType += "text/html";
+                        }
+                        String lastModified = "";
+                        if (supportLastModified) {
+                            lastModified = "Last-Modified: " + new Date(resource.lastModified()) + CRLF;
+                        }
+                        writer.writeBytes(HTTP_OK + "Content-Length:" + resourceLength + CRLF + lastModified + contentType + CRLF + CRLF);
+
+                        if (isGetRequest) {
+                            if (slowSend) {
+                                byte[][] bb = splitArray(buff, 10);
+                                for (int j = 0; j < bb.length; j++) {
+                                    Thread.sleep(2000);
+                                    byte[] bs = bb[j];
+                                    writer.write(bs, 0, bs.length);
+                                }
+                            } else {
+                                writer.write(buff, 0, resourceLength);
                             }
-                        } else {
-                            writer.write(buff, 0, resourceLength);
                         }
                     }
                 }
@@ -207,13 +232,14 @@
     }
 
     /**
-     * This function splits input array to severasl pieces
-     * from byte[length] splitt to n pieces s is retrunrd byte[n][length/n], except
-     * last piece which contains length%n
+     * This function splits input array to severasl pieces from byte[length]
+     * splitt to n pieces s is retrunrd byte[n][length/n], except last piece
+     * which contains length%n
      *
      * @param input - array to be splitted
      * @param pieces - to how many pieces it should be broken
-     * @return inidividual pices of original array, which concatet again givs original array
+     * @return inidividual pices of original array, which concatet again givs
+     * original array
      */
     public static byte[][] splitArray(byte[] input, int pieces) {
         int rest = input.length;
@@ -239,12 +265,13 @@
     }
 
     /**
-    * This function transforms a request URL into a path to a file which the server
-    * will return to the requester.
-    * @param url - the request URL
-    * @return a String representation of the local path to the file
-    * @throws UnsupportedEncodingException
-    */
+     * This function transforms a request URL into a path to a file which the
+     * server will return to the requester.
+     *
+     * @param url - the request URL
+     * @return a String representation of the local path to the file
+     * @throws UnsupportedEncodingException
+     */
     public static String urlToFilePath(String url) throws UnsupportedEncodingException {
         url = URLDecoder.decode(url, "UTF-8"); // Decode URL encoded charaters, eg "%3B" becomes ';'
         if (url.startsWith(XSX)) {
@@ -261,8 +288,9 @@
     }
 
     /**
-     * This function removes the HTTP Path Parameter from a given JAR URL, assuming that the
-     * path param delimiter is a semicolon
+     * This function removes the HTTP Path Parameter from a given JAR URL,
+     * assuming that the path param delimiter is a semicolon
+     *
      * @param url - the URL from which to remove the path parameter
      * @return the URL with the path parameter removed
      */
@@ -282,4 +310,31 @@
         }
         return url;
     }
+
+    /**
+     * When redirect is set, the requests to this server will just redirect to
+     * the underlying ServerLauncher
+     */
+    private ServerLauncher redirect = null;
+
+    void setRedirect(ServerLauncher redirect) {
+        this.redirect = redirect;
+    }
+
+    /**
+     * one of: 301, 302,303, 307, 308,
+     */
+    private int redirectCode = 302;
+
+    void setRedirectCode(int redirectPort) {
+        this.redirectCode = redirectPort;
+    }
+
+    //resoource -> request -> number of requests on of this rsource on this server
+    // eg   simpletest1.jnlp -> GET -> 3
+    private Map<String, Map<String, Integer>> requestsCounter;
+
+    public void setRequestsCounter(Map<String, Map<String, Integer>> requestsCounter) {
+        this.requestsCounter = requestsCounter;
+    }
 }
diff -r ba6519dd5e79 -r 263e152a6084 tests/test-extensions/net/sourceforge/jnlp/browsertesting/browsers/firefox/FirefoxProfilesOperator.java
--- a/tests/test-extensions/net/sourceforge/jnlp/browsertesting/browsers/firefox/FirefoxProfilesOperator.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/tests/test-extensions/net/sourceforge/jnlp/browsertesting/browsers/firefox/FirefoxProfilesOperator.java	Tue Jan 26 15:18:30 2016 +0100
@@ -129,11 +129,9 @@
         FileInputStream is = new FileInputStream(from);
         FileOutputStream fos = new FileOutputStream(to);
         FileChannel f = is.getChannel();
-        FileChannel f2 = fos.getChannel();
-        try {
+        try (FileChannel f2 = fos.getChannel()) {
             f.transferTo(0, f.size(), f2);
         } finally {
-            f2.close();
             f.close();
         }
     }
diff -r ba6519dd5e79 -r 263e152a6084 tests/test-extensions/net/sourceforge/jnlp/closinglisteners/AutoErrorClosingListener.java
--- a/tests/test-extensions/net/sourceforge/jnlp/closinglisteners/AutoErrorClosingListener.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/tests/test-extensions/net/sourceforge/jnlp/closinglisteners/AutoErrorClosingListener.java	Tue Jan 26 15:18:30 2016 +0100
@@ -1,38 +1,38 @@
 /* AutoErrorClosingListener.java
-Copyright (C) 2012 Red Hat, Inc.
+ Copyright (C) 2012 Red Hat, Inc.
 
-This file is part of IcedTea.
+ This file is part of IcedTea.
 
-IcedTea is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License as published by
-the Free Software Foundation, version 2.
+ IcedTea is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, version 2.
 
-IcedTea is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
+ IcedTea is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with IcedTea; see the file COPYING.  If not, write to
-the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-02110-1301 USA.
+ You should have received a copy of the GNU General Public License
+ along with IcedTea; see the file COPYING.  If not, write to
+ the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ 02110-1301 USA.
 
-Linking this library statically or dynamically with other modules is
-making a combined work based on this library.  Thus, the terms and
-conditions of the GNU General Public License cover the whole
-combination.
+ Linking this library statically or dynamically with other modules is
+ making a combined work based on this library.  Thus, the terms and
+ conditions of the GNU General Public License cover the whole
+ combination.
 
-As a special exception, the copyright holders of this library give you
-permission to link this library with independent modules to produce an
-executable, regardless of the license terms of these independent
-modules, and to copy and distribute the resulting executable under
-terms of your choice, provided that you also meet, for each linked
-independent module, the terms and conditions of the license of that
-module.  An independent module is a module which is not derived from
-or based on this library.  If you modify this library, you may extend
-this exception to your version of the library, but you are not
-obligated to do so.  If you do not wish to do so, delete this
-exception statement from your version.
+ As a special exception, the copyright holders of this library give you
+ permission to link this library with independent modules to produce an
+ executable, regardless of the license terms of these independent
+ modules, and to copy and distribute the resulting executable under
+ terms of your choice, provided that you also meet, for each linked
+ independent module, the terms and conditions of the license of that
+ module.  An independent module is a module which is not derived from
+ or based on this library.  If you modify this library, you may extend
+ this exception to your version of the library, but you are not
+ obligated to do so.  If you do not wish to do so, delete this
+ exception statement from your version.
  */
 package net.sourceforge.jnlp.closinglisteners;
 
@@ -43,4 +43,14 @@
     public AutoErrorClosingListener() {
         super(MAGICAL_ERROR_CLOSING_STRING);
     }
+
+    @Override
+    public void lineReaded(String s) {
+        if (s.contains("FAILED ASSERTION")) {
+            //dont terminate if it is rhino's org.mozilla.javascript.Kit 
+        } else {
+            super.lineReaded(s);
+        }
+    }
+
 }
diff -r ba6519dd5e79 -r 263e152a6084 tests/test-extensions/net/sourceforge/jnlp/closinglisteners/StringBasedClosingListener.java
--- a/tests/test-extensions/net/sourceforge/jnlp/closinglisteners/StringBasedClosingListener.java	Fri Sep 11 14:57:30 2015 +0200
+++ b/tests/test-extensions/net/sourceforge/jnlp/closinglisteners/StringBasedClosingListener.java	Tue Jan 26 15:18:30 2016 +0100
@@ -40,7 +40,7 @@
 
 public  class StringBasedClosingListener extends ClosingListener {
 
-    private  final String condition;
+    protected  final String condition;
 
     public StringBasedClosingListener(String condition) {
         this.condition = condition;
